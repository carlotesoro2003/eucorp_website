import {
  $11d87f3f76e88657$export$b4a036af3fc0b032,
  $14e0f24ef4ac5c92$export$2061056d06d7cdf7,
  $14e0f24ef4ac5c92$export$629b0a497aa65267,
  $14e0f24ef4ac5c92$export$a18c89cbd24170ff,
  $14e0f24ef4ac5c92$export$a2258d9c4118825c,
  $14e0f24ef4ac5c92$export$a5a3b454ada2268e,
  $14e0f24ef4ac5c92$export$aa8b41735afcabd2,
  $14e0f24ef4ac5c92$export$ea39ec197993aef0,
  $35ea8db9cb2ccb90$export$99faa760c7908e4f,
  $35ea8db9cb2ccb90$export$ca871e8dbb80966f,
  $35ea8db9cb2ccb90$export$d3b7288e7994edea,
  $fae977aafc393c5c$export$588937bcd60ade55,
  $fae977aafc393c5c$export$6b862160d295c8e,
  $fae977aafc393c5c$export$fd7893f06e92a6a4,
  $fb18d541ea1ad717$export$ad991b66133851cf
} from "./chunk-PGN35BPM.js";
import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  hide,
  limitShift,
  offset,
  shift,
  size
} from "./chunk-PKX2IIMH.js";
import {
  esm_default
} from "./chunk-E573SMLN.js";
import "./chunk-XFWVV2NI.js";
import "./chunk-FNVMBFKB.js";
import {
  clsx
} from "./chunk-U7P2NEEE.js";
import "./chunk-CPDTQROR.js";
import {
  SvelteMap
} from "./chunk-FXLCVXHA.js";
import "./chunk-NWV74YFA.js";
import {
  add_locations,
  append_styles,
  bind_this,
  bind_value,
  check_target,
  cleanup_styles,
  component,
  each,
  element,
  handle_lazy_img,
  hmr,
  if_block,
  index,
  init,
  key_block,
  legacy_api,
  log_if_contains_state,
  onMount,
  prop,
  remove_input_defaults,
  rest_props,
  set_attribute,
  set_attributes,
  set_style,
  snapshot,
  snippet,
  spread_props,
  validate_binding,
  validate_dynamic_element_tag,
  validate_prop_bindings,
  validate_void_dynamic_element,
  wrap_snippet
} from "./chunk-TEG7OJR5.js";
import {
  append,
  comment,
  mount,
  set_text,
  template,
  text,
  unmount
} from "./chunk-KHOLETJR.js";
import {
  ADD_OWNER,
  FILENAME,
  HMR,
  NAMESPACE_SVG,
  add_owner,
  add_owner_effect,
  child,
  derived,
  derived_safe_equal,
  effect_root,
  effect_tracking,
  equals,
  first_child,
  get,
  getAllContexts,
  getContext,
  hasContext,
  mark_module_end,
  mark_module_start,
  next,
  noop,
  pop,
  proxy,
  push,
  replay_events,
  reset,
  set,
  setContext,
  sibling,
  state,
  strict_equals,
  template_effect,
  tick,
  untrack,
  user_effect,
  user_pre_effect
} from "./chunk-MFQBWCSV.js";
import {
  BROWSER,
  DEV
} from "./chunk-CWMVYRNN.js";
import {
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-UQOTJTBP.js";

// node_modules/bits-ui/dist/bits/accordion/exports.js
var exports_exports = {};
__export(exports_exports, {
  Content: () => accordion_content_default,
  Header: () => accordion_header_default,
  Item: () => accordion_item_default,
  Root: () => accordion_default,
  Trigger: () => accordion_trigger_default
});

// node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}

// node_modules/svelte-toolbelt/dist/box/box.svelte.js
var BoxSymbol = Symbol("box");
var isWritableSymbol = Symbol("is-writable");
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return box.isBox(value) && isWritableSymbol in value;
}
function box(initialValue) {
  let current = state(proxy(initialValue));
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, proxy(v, null, current));
    }
  };
}
function boxWith(getter, setter) {
  const derived2 = derived(getter);
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived2);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function boxFrom(value) {
  if (box.isBox(value)) return value;
  if (isFunction(value)) return box.with(value);
  return box(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key, b]) => {
      if (!box.isBox(b)) {
        return Object.assign(acc, { [key]: b });
      }
      if (box.isWritableBox(b)) {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          },
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!box.isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/svelte-toolbelt/dist/utils/compose-handlers.js
function composeHandlers(...handlers) {
  return function(e) {
    var _a;
    for (const handler of handlers) {
      if (!handler)
        continue;
      if (e.defaultPrevented)
        return;
      if (typeof handler === "function") {
        handler.call(this, e);
      } else {
        (_a = handler.current) == null ? void 0 : _a.call(this, e);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/strings.js
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char))
    return void 0;
  return char !== char.toLowerCase();
}
function splitByCase(str) {
  const parts = [];
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = STR_SPLITTERS.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function pascalCase(str) {
  if (!str)
    return "";
  return splitByCase(str).map((p2) => upperFirst(p2)).join("");
}
function camelCase(str) {
  return lowerFirst(pascalCase(str || ""));
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}

// node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js
function cssToStyleObj(css) {
  if (!css)
    return {};
  const styleObj = {};
  function iterator(name, value) {
    if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
      styleObj[pascalCase(name)] = value;
      return;
    }
    if (name.startsWith("--")) {
      styleObj[name] = value;
      return;
    }
    styleObj[camelCase(name)] = value;
  }
  esm_default(css, iterator);
  return styleObj;
}

// node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/svelte-toolbelt/dist/utils/merge-props.js
function isEventHandler(key) {
  var _a;
  return key.length > 2 && key.startsWith("on") && key[2] === ((_a = key[2]) == null ? void 0 : _a.toLowerCase());
}
function mergeProps(...args) {
  const result = { ...args[0] };
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    for (const key in props) {
      const a2 = result[key];
      const b = props[key];
      const aIsFunction = typeof a2 === "function";
      const bIsFunction = typeof b === "function";
      if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {
        const aHandler = a2;
        const bHandler = b;
        result[key] = composeHandlers(aHandler, bHandler);
      } else if (aIsFunction && bIsFunction) {
        result[key] = executeCallbacks(a2, b);
      } else if (key === "class" && typeof a2 === "string" && typeof b === "string") {
        result[key] = clsx(a2, b);
      } else if (key === "style") {
        const aIsObject = typeof a2 === "object";
        const bIsObject = typeof b === "object";
        const aIsString = typeof a2 === "string";
        const bIsString = typeof b === "string";
        if (aIsObject && bIsObject) {
          result[key] = { ...a2, ...b };
        } else if (aIsObject && bIsString) {
          const parsedStyle = cssToStyleObj(b);
          result[key] = { ...a2, ...parsedStyle };
        } else if (aIsString && bIsObject) {
          const parsedStyle = cssToStyleObj(a2);
          result[key] = { ...parsedStyle, ...b };
        } else if (aIsString && bIsString) {
          const parsedStyleA = cssToStyleObj(a2);
          const parsedStyleB = cssToStyleObj(b);
          result[key] = { ...parsedStyleA, ...parsedStyleB };
        } else if (aIsObject) {
          result[key] = a2;
        } else if (bIsObject) {
          result[key] = b;
        }
      } else {
        result[key] = b !== void 0 ? b : a2;
      }
    }
  }
  if (typeof result.style === "object") {
    result.style = styleToString(result.style).replaceAll("\n", " ");
  }
  if (result.hidden !== true) {
    result.hidden = void 0;
  }
  if (result.disabled !== true) {
    result.disabled = void 0;
  }
  return result;
}

// node_modules/svelte-toolbelt/dist/utils/use-ref-by-id.svelte.js
function useRefById({
  id,
  ref,
  deps = () => true,
  onRefChange = () => {
  },
  getRootNode = () => strict_equals(typeof document, "undefined", false) ? document : void 0
}) {
  const dependencies = derived(() => deps());
  const rootNode = derived(() => getRootNode());
  user_effect(() => {
    id.current;
    get(dependencies);
    get(rootNode);
    return untrack(() => {
      var _a;
      const node = (_a = get(rootNode)) == null ? void 0 : _a.getElementById(id.current);
      if (node) {
        ref.current = node;
      } else {
        ref.current = null;
      }
      onRefChange(ref.current);
    });
  });
  user_effect(() => {
    return () => {
      ref.current = null;
      onRefChange(null);
    };
  });
}

// node_modules/svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js
function onDestroyEffect(fn) {
  user_effect(() => {
    return () => {
      fn();
    };
  });
}

// node_modules/svelte-toolbelt/dist/utils/after-sleep.js
function afterSleep(ms, cb) {
  setTimeout(cb, ms);
}

// node_modules/svelte-toolbelt/dist/utils/after-tick.js
function afterTick(fn) {
  tick().then(fn);
}

// node_modules/bits-ui/dist/internal/attrs.js
function getDataOpenClosed(condition) {
  return condition ? "open" : "closed";
}
function getDataChecked(condition) {
  return condition ? "checked" : "unchecked";
}
function getAriaDisabled(condition) {
  return condition ? "true" : "false";
}
function getAriaReadonly(condition) {
  return condition ? "true" : "false";
}
function getAriaExpanded(condition) {
  return condition ? "true" : "false";
}
function getDataDisabled(condition) {
  return condition ? "" : void 0;
}
function getAriaRequired(condition) {
  return condition ? "true" : "false";
}
function getAriaSelected(condition) {
  return condition ? "true" : "false";
}
function getAriaChecked(checked, indeterminate) {
  if (indeterminate) {
    return "mixed";
  }
  return checked ? "true" : "false";
}
function getAriaOrientation(orientation) {
  return orientation;
}
function getAriaHidden(condition) {
  return condition ? "true" : void 0;
}
function getAriaInvalid(condition) {
  return condition ? "true" : void 0;
}
function getDataOrientation(orientation) {
  return orientation;
}
function getDataInvalid(condition) {
  return condition ? "" : void 0;
}
function getDataRequired(condition) {
  return condition ? "" : void 0;
}
function getDataReadonly(condition) {
  return condition ? "" : void 0;
}
function getDataSelected(condition) {
  return condition ? "" : void 0;
}
function getDataUnavailable(condition) {
  return condition ? "" : void 0;
}
function getHidden(condition) {
  return condition ? true : void 0;
}
function getDisabled(condition) {
  return condition ? true : void 0;
}
function getAriaPressed(condition) {
  return condition ? "true" : "false";
}
function getRequired(condition) {
  return condition ? true : void 0;
}

// node_modules/bits-ui/dist/internal/kbd-constants.js
var kbd_constants_exports = {};
__export(kbd_constants_exports, {
  A: () => A,
  ALT: () => ALT,
  ARROW_DOWN: () => ARROW_DOWN,
  ARROW_LEFT: () => ARROW_LEFT,
  ARROW_RIGHT: () => ARROW_RIGHT,
  ARROW_UP: () => ARROW_UP,
  ASTERISK: () => ASTERISK,
  BACKSPACE: () => BACKSPACE,
  CAPS_LOCK: () => CAPS_LOCK,
  CONTROL: () => CONTROL,
  CTRL: () => CTRL,
  DELETE: () => DELETE,
  END: () => END,
  ENTER: () => ENTER,
  ESCAPE: () => ESCAPE,
  F1: () => F1,
  F10: () => F10,
  F11: () => F11,
  F12: () => F12,
  F2: () => F2,
  F3: () => F3,
  F4: () => F4,
  F5: () => F5,
  F6: () => F6,
  F7: () => F7,
  F8: () => F8,
  F9: () => F9,
  HOME: () => HOME,
  META: () => META,
  P: () => P,
  PAGE_DOWN: () => PAGE_DOWN,
  PAGE_UP: () => PAGE_UP,
  SHIFT: () => SHIFT,
  SPACE: () => SPACE,
  TAB: () => TAB,
  a: () => a,
  j: () => j,
  k: () => k,
  n: () => n,
  p: () => p
});
var ALT = "Alt";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var BACKSPACE = "Backspace";
var CAPS_LOCK = "CapsLock";
var CONTROL = "Control";
var DELETE = "Delete";
var END = "End";
var ENTER = "Enter";
var ESCAPE = "Escape";
var F1 = "F1";
var F10 = "F10";
var F11 = "F11";
var F12 = "F12";
var F2 = "F2";
var F3 = "F3";
var F4 = "F4";
var F5 = "F5";
var F6 = "F6";
var F7 = "F7";
var F8 = "F8";
var F9 = "F9";
var HOME = "Home";
var META = "Meta";
var PAGE_DOWN = "PageDown";
var PAGE_UP = "PageUp";
var SHIFT = "Shift";
var SPACE = " ";
var TAB = "Tab";
var CTRL = "Control";
var ASTERISK = "*";
var a = "a";
var P = "P";
var A = "A";
var p = "p";
var n = "n";
var j = "j";
var k = "k";

// node_modules/bits-ui/dist/internal/locale.js
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}

// node_modules/bits-ui/dist/internal/get-directional-keys.js
var FIRST_KEYS = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd_constants_exports.SPACE, kbd_constants_exports.ENTER];
function getNextKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT,
    vertical: kbd_constants_exports.ARROW_DOWN
  }[orientation];
}
function getPrevKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT,
    vertical: kbd_constants_exports.ARROW_UP
  }[orientation];
}
function getDirectionalKeys(dir = "ltr", orientation = "horizontal") {
  if (!["ltr", "rtl"].includes(dir))
    dir = "ltr";
  if (!["horizontal", "vertical"].includes(orientation))
    orientation = "horizontal";
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
}

// node_modules/bits-ui/dist/internal/is.js
var isBrowser = typeof document !== "undefined";
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isBrowser && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && // eslint-disable-next-line regexp/no-unused-capturing-group
  (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
  ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function isHTMLElement(element2) {
  return element2 instanceof HTMLElement;
}
function isElement(element2) {
  return element2 instanceof Element;
}
function isElementOrSVGElement(element2) {
  return element2 instanceof Element || element2 instanceof SVGElement;
}
function isNumberString(value) {
  return !Number.isNaN(Number(value)) && !Number.isNaN(Number.parseFloat(value));
}
function isNull(value) {
  return value === null;
}
function isTouch(e) {
  return e.pointerType === "touch";
}
function isFocusVisible(element2) {
  return element2.matches(":focus-visible");
}
function isNotNull(value) {
  return value !== null;
}
function isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}
function isElementHidden(node, stopAt) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (stopAt !== void 0 && node === stopAt)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}

// node_modules/bits-ui/dist/internal/use-roving-focus.svelte.js
function useRovingFocus(props) {
  const currentTabStopId = props.currentTabStopId ? props.currentTabStopId : box(null);
  function getCandidateNodes() {
    if (!isBrowser) return [];
    const node = document.getElementById(props.rootNodeId.current);
    if (!node) return [];
    if (props.candidateSelector) {
      const candidates = Array.from(node.querySelectorAll(props.candidateSelector));
      return candidates;
    } else {
      const candidates = Array.from(node.querySelectorAll(`[${props.candidateAttr}]:not([data-disabled])`));
      return candidates;
    }
  }
  function focusFirstCandidate() {
    var _a;
    const items = getCandidateNodes();
    if (!items.length) return;
    (_a = items[0]) == null ? void 0 : _a.focus();
  }
  function handleKeydown(node, e, both = false) {
    var _a;
    const rootNode = document.getElementById(props.rootNodeId.current);
    if (!rootNode || !node) return;
    const items = getCandidateNodes();
    if (!items.length) return;
    const currentIndex = items.indexOf(node);
    const dir = getElemDirection(rootNode);
    const { nextKey, prevKey } = getDirectionalKeys(dir, props.orientation.current);
    const loop = props.loop.current;
    const keyToIndex = {
      [nextKey]: currentIndex + 1,
      [prevKey]: currentIndex - 1,
      [kbd_constants_exports.HOME]: 0,
      [kbd_constants_exports.END]: items.length - 1
    };
    if (both) {
      const altNextKey = strict_equals(nextKey, kbd_constants_exports.ARROW_DOWN) ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_DOWN;
      const altPrevKey = strict_equals(prevKey, kbd_constants_exports.ARROW_UP) ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_UP;
      keyToIndex[altNextKey] = currentIndex + 1;
      keyToIndex[altPrevKey] = currentIndex - 1;
    }
    let itemIndex = keyToIndex[e.key];
    if (strict_equals(itemIndex, void 0)) return;
    e.preventDefault();
    if (itemIndex < 0 && loop) {
      itemIndex = items.length - 1;
    } else if (strict_equals(itemIndex, items.length) && loop) {
      itemIndex = 0;
    }
    const itemToFocus = items[itemIndex];
    if (!itemToFocus) return;
    itemToFocus.focus();
    currentTabStopId.current = itemToFocus.id;
    (_a = props.onCandidateFocus) == null ? void 0 : _a.call(props, itemToFocus);
    return itemToFocus;
  }
  function getTabIndex(node) {
    const items = getCandidateNodes();
    const anyActive = strict_equals(currentTabStopId.current, null, false);
    if (node && !anyActive && strict_equals(items[0], node)) {
      currentTabStopId.current = node.id;
      return 0;
    } else if (strict_equals(node == null ? void 0 : node.id, currentTabStopId.current)) {
      return 0;
    }
    return -1;
  }
  return {
    setCurrentTabStopId(id) {
      currentTabStopId.current = id;
    },
    getTabIndex,
    handleKeydown,
    focusFirstCandidate,
    currentTabStopId
  };
}

// node_modules/bits-ui/dist/internal/create-context.js
function setContext2(key, value) {
  return setContext(key, value);
}
function getContext2(key, fallback) {
  const trueKey = typeof key === "symbol" ? key : key;
  const description = typeof key === "symbol" ? key.description : key;
  if (!hasContext(trueKey)) {
    if (fallback === void 0) {
      throw new Error(`Missing context dependency: ${description} and no fallback was provided.`);
    }
    return fallback;
  }
  return getContext(key);
}
function getSymbolDescription(providerComponentName, contextName) {
  if (contextName !== void 0)
    return contextName;
  if (typeof providerComponentName === "string" && contextName === void 0) {
    return `${providerComponentName}Context`;
  } else if (Array.isArray(providerComponentName) && contextName === void 0) {
    return `${providerComponentName[0]}Context`;
  } else {
    if (contextName !== void 0)
      return contextName;
    return `${providerComponentName}Context`;
  }
}
function createContext(providerComponentName, contextName, useSymbol = true) {
  const symbolDescription = getSymbolDescription(providerComponentName, contextName);
  const symbol = Symbol.for(`bits-ui.${symbolDescription}`);
  const key = symbolDescription;
  function getCtx(fallback) {
    const context = getContext2(useSymbol ? symbol : key, fallback);
    if (context === void 0) {
      throw new Error(`Context \`${symbolDescription}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(", ")}` : `\`${providerComponentName}\``}`);
    }
    if (context === null)
      return context;
    return context;
  }
  function setCtx(value) {
    if (useSymbol) {
      return setContext2(symbol, value);
    } else {
      return setContext2(key, value);
    }
  }
  return [setCtx, getCtx];
}

// node_modules/bits-ui/dist/bits/accordion/accordion.svelte.js
var ACCORDION_ROOT_ATTR = "data-accordion-root";
var ACCORDION_TRIGGER_ATTR = "data-accordion-trigger";
var ACCORDION_CONTENT_ATTR = "data-accordion-content";
var ACCORDION_ITEM_ATTR = "data-accordion-item";
var ACCORDION_HEADER_ATTR = "data-accordion-header";
var _id, _ref, _loop, _props;
var AccordionBaseState = class {
  constructor(props) {
    __privateAdd(this, _id);
    __privateAdd(this, _ref);
    __publicField(this, "disabled");
    __privateAdd(this, _loop);
    __publicField(this, "orientation");
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _props, derived(() => ({
      id: __privateGet(this, _id).current,
      "data-orientation": getDataOrientation(this.orientation.current),
      "data-disabled": getDataDisabled(this.disabled.current),
      [ACCORDION_ROOT_ATTR]: ""
    })));
    __privateSet(this, _id, props.id);
    this.disabled = props.disabled;
    __privateSet(this, _ref, props.ref);
    useRefById({ id: props.id, ref: __privateGet(this, _ref) });
    this.orientation = props.orientation;
    __privateSet(this, _loop, props.loop);
    this.rovingFocusGroup = useRovingFocus({
      rootNodeId: __privateGet(this, _id),
      candidateAttr: ACCORDION_TRIGGER_ATTR,
      loop: __privateGet(this, _loop),
      orientation: this.orientation
    });
  }
  get props() {
    return get(__privateGet(this, _props));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props)), owner, false);
  }
};
_id = new WeakMap();
_ref = new WeakMap();
_loop = new WeakMap();
_props = new WeakMap();
var _value;
var AccordionSingleState = class extends AccordionBaseState {
  constructor(props) {
    super(props);
    __privateAdd(this, _value);
    __publicField(this, "isMulti", false);
    __publicField(this, "includesItem", (item) => {
      return strict_equals(__privateGet(this, _value).current, item);
    });
    __publicField(this, "toggleItem", (item) => {
      __privateGet(this, _value).current = this.includesItem(item) ? "" : item;
    });
    __privateSet(this, _value, props.value);
  }
};
_value = new WeakMap();
var _value2;
var AccordionMultiState = class extends AccordionBaseState {
  constructor(props) {
    super(props);
    __privateAdd(this, _value2);
    __publicField(this, "isMulti", true);
    __publicField(this, "includesItem", (item) => {
      return __privateGet(this, _value2).current.includes(item);
    });
    __publicField(this, "toggleItem", (item) => {
      if (this.includesItem(item)) {
        __privateGet(this, _value2).current = __privateGet(this, _value2).current.filter((v) => strict_equals(v, item, false));
      } else {
        __privateGet(this, _value2).current = [...__privateGet(this, _value2).current, item];
      }
    });
    __privateSet(this, _value2, props.value);
  }
};
_value2 = new WeakMap();
var _id2, _ref2, _isActive, _isDisabled, _props2;
var AccordionItemState = class {
  constructor(props) {
    __privateAdd(this, _id2);
    __privateAdd(this, _ref2);
    __publicField(this, "value");
    __publicField(this, "disabled");
    __publicField(this, "root");
    __privateAdd(this, _isActive, derived(() => this.root.includesItem(this.value.current)));
    __privateAdd(this, _isDisabled, derived(() => this.disabled.current || this.root.disabled.current));
    __publicField(this, "updateValue", () => {
      this.root.toggleItem(this.value.current);
    });
    __privateAdd(this, _props2, derived(() => ({
      id: __privateGet(this, _id2).current,
      "data-state": getDataOpenClosed(this.isActive),
      "data-disabled": getDataDisabled(this.isDisabled),
      "data-orientation": getDataOrientation(this.root.orientation.current),
      [ACCORDION_ITEM_ATTR]: ""
    })));
    this.value = props.value;
    this.disabled = props.disabled;
    this.root = props.rootState;
    __privateSet(this, _id2, props.id);
    __privateSet(this, _ref2, props.ref);
    useRefById({
      id: __privateGet(this, _id2),
      ref: __privateGet(this, _ref2),
      deps: () => this.isActive
    });
  }
  get isActive() {
    return get(__privateGet(this, _isActive));
  }
  set isActive(_) {
    throw new Error("Cannot update a derived property ('isActive')");
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled));
  }
  set isDisabled(_) {
    throw new Error("Cannot update a derived property ('isDisabled')");
  }
  get props() {
    return get(__privateGet(this, _props2));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isActive)), owner, false);
    add_owner(get(__privateGet(this, _isDisabled)), owner, false);
    add_owner(get(__privateGet(this, _props2)), owner, false);
  }
};
_id2 = new WeakMap();
_ref2 = new WeakMap();
_isActive = new WeakMap();
_isDisabled = new WeakMap();
_props2 = new WeakMap();
var _ref3, _disabled, _id3, _root, _itemState, _isDisabled2, _onpointerdown, _onpointerup, _onkeydown, _props3;
var AccordionTriggerState = class {
  constructor(props, itemState) {
    __privateAdd(this, _ref3);
    __privateAdd(this, _disabled);
    __privateAdd(this, _id3);
    __privateAdd(this, _root);
    __privateAdd(this, _itemState);
    __privateAdd(this, _isDisabled2, derived(() => __privateGet(this, _disabled).current || __privateGet(this, _itemState).disabled.current || __privateGet(this, _root).disabled.current));
    __privateAdd(this, _onpointerdown, (e) => {
      if (get(__privateGet(this, _isDisabled2))) return;
      if (strict_equals(e.pointerType, "touch") || strict_equals(e.button, 0, false)) return e.preventDefault();
      __privateGet(this, _itemState).updateValue();
    });
    __privateAdd(this, _onpointerup, (e) => {
      if (get(__privateGet(this, _isDisabled2))) return;
      if (strict_equals(e.pointerType, "touch")) {
        e.preventDefault();
        __privateGet(this, _itemState).updateValue();
      }
    });
    __privateAdd(this, _onkeydown, (e) => {
      if (get(__privateGet(this, _isDisabled2))) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        e.preventDefault();
        __privateGet(this, _itemState).updateValue();
        return;
      }
      __privateGet(this, _root).rovingFocusGroup.handleKeydown(__privateGet(this, _ref3).current, e);
    });
    __privateAdd(this, _props3, derived(() => ({
      id: __privateGet(this, _id3).current,
      disabled: get(__privateGet(this, _isDisabled2)),
      "aria-expanded": getAriaExpanded(__privateGet(this, _itemState).isActive),
      "aria-disabled": getAriaDisabled(get(__privateGet(this, _isDisabled2))),
      "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled2))),
      "data-state": getDataOpenClosed(__privateGet(this, _itemState).isActive),
      "data-orientation": getDataOrientation(__privateGet(this, _root).orientation.current),
      [ACCORDION_TRIGGER_ATTR]: "",
      tabindex: 0,
      //
      onpointerdown: __privateGet(this, _onpointerdown),
      onpointerup: __privateGet(this, _onpointerup),
      onkeydown: __privateGet(this, _onkeydown)
    })));
    __privateSet(this, _disabled, props.disabled);
    __privateSet(this, _itemState, itemState);
    __privateSet(this, _root, itemState.root);
    __privateSet(this, _id3, props.id);
    __privateSet(this, _ref3, props.ref);
    useRefById({ id: props.id, ref: __privateGet(this, _ref3) });
  }
  get props() {
    return get(__privateGet(this, _props3));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props3)), owner, false);
  }
};
_ref3 = new WeakMap();
_disabled = new WeakMap();
_id3 = new WeakMap();
_root = new WeakMap();
_itemState = new WeakMap();
_isDisabled2 = new WeakMap();
_onpointerdown = new WeakMap();
_onpointerup = new WeakMap();
_onkeydown = new WeakMap();
_props3 = new WeakMap();
var _ref4, _id4, _originalStyles, _isMountAnimationPrevented, _width, _height, _forceMount, _present, _snippetProps, _props4;
var AccordionContentState = class {
  constructor(props, item) {
    __publicField(this, "item");
    __privateAdd(this, _ref4);
    __privateAdd(this, _id4);
    __privateAdd(this, _originalStyles);
    __privateAdd(this, _isMountAnimationPrevented, false);
    __privateAdd(this, _width, state(0));
    __privateAdd(this, _height, state(0));
    __privateAdd(this, _forceMount);
    __privateAdd(this, _present, derived(() => __privateGet(this, _forceMount).current || this.item.isActive));
    __privateAdd(this, _snippetProps, derived(() => ({ open: this.item.isActive })));
    __privateAdd(this, _props4, derived(() => ({
      id: __privateGet(this, _id4).current,
      "data-state": getDataOpenClosed(this.item.isActive),
      "data-disabled": getDataDisabled(this.item.isDisabled),
      "data-orientation": getDataOrientation(this.item.root.orientation.current),
      [ACCORDION_CONTENT_ATTR]: "",
      style: {
        "--bits-accordion-content-height": `${get(__privateGet(this, _height))}px`,
        "--bits-accordion-content-width": `${get(__privateGet(this, _width))}px`
      }
    })));
    this.item = item;
    __privateSet(this, _forceMount, props.forceMount);
    __privateSet(this, _isMountAnimationPrevented, this.item.isActive);
    __privateSet(this, _id4, props.id);
    __privateSet(this, _ref4, props.ref);
    useRefById({ id: __privateGet(this, _id4), ref: __privateGet(this, _ref4) });
    user_pre_effect(() => {
      const rAF = requestAnimationFrame(() => {
        __privateSet(this, _isMountAnimationPrevented, false);
      });
      return () => {
        cancelAnimationFrame(rAF);
      };
    });
    user_effect(() => {
      this.present;
      const node = __privateGet(this, _ref4).current;
      if (!node) return;
      afterTick(() => {
        if (!__privateGet(this, _ref4).current) return;
        __privateSet(this, _originalStyles, __privateGet(this, _originalStyles) || {
          transitionDuration: node.style.transitionDuration,
          animationName: node.style.animationName
        });
        node.style.transitionDuration = "0s";
        node.style.animationName = "none";
        const rect = node.getBoundingClientRect();
        set(__privateGet(this, _height), proxy(rect.height, null, __privateGet(this, _height)));
        set(__privateGet(this, _width), proxy(rect.width, null, __privateGet(this, _width)));
        if (!__privateGet(this, _isMountAnimationPrevented)) {
          const { animationName, transitionDuration } = __privateGet(this, _originalStyles);
          node.style.transitionDuration = transitionDuration;
          node.style.animationName = animationName;
        }
      });
    });
  }
  get present() {
    return get(__privateGet(this, _present));
  }
  set present(_) {
    throw new Error("Cannot update a derived property ('present')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props4));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _present)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps)), owner, false);
    add_owner(get(__privateGet(this, _props4)), owner, false);
  }
};
_ref4 = new WeakMap();
_id4 = new WeakMap();
_originalStyles = new WeakMap();
_isMountAnimationPrevented = new WeakMap();
_width = new WeakMap();
_height = new WeakMap();
_forceMount = new WeakMap();
_present = new WeakMap();
_snippetProps = new WeakMap();
_props4 = new WeakMap();
var _id5, _ref5, _level, _item, _props5;
var AccordionHeaderState = class {
  constructor(props, item) {
    __privateAdd(this, _id5);
    __privateAdd(this, _ref5);
    __privateAdd(this, _level);
    __privateAdd(this, _item);
    __privateAdd(this, _props5, derived(() => ({
      id: __privateGet(this, _id5).current,
      role: "heading",
      "aria-level": __privateGet(this, _level).current,
      "data-heading-level": __privateGet(this, _level).current,
      "data-state": getDataOpenClosed(__privateGet(this, _item).isActive),
      "data-orientation": getDataOrientation(__privateGet(this, _item).root.orientation.current),
      [ACCORDION_HEADER_ATTR]: ""
    })));
    __privateSet(this, _level, props.level);
    __privateSet(this, _id5, props.id);
    __privateSet(this, _ref5, props.ref);
    useRefById({ id: __privateGet(this, _id5), ref: __privateGet(this, _ref5) });
    __privateSet(this, _item, item);
  }
  get props() {
    return get(__privateGet(this, _props5));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props5)), owner, false);
  }
};
_id5 = new WeakMap();
_ref5 = new WeakMap();
_level = new WeakMap();
_item = new WeakMap();
_props5 = new WeakMap();
var [
  setAccordionRootContext,
  getAccordionRootContext
] = createContext("Accordion.Root");
var [
  setAccordionItemContext,
  getAccordionItemContext
] = createContext("Accordion.Item");
function useAccordionRoot(props) {
  const { type, ...rest } = props;
  const rootState = strict_equals(type, "single") ? new AccordionSingleState(rest) : new AccordionMultiState(rest);
  return setAccordionRootContext(rootState);
}
function useAccordionItem(props) {
  const rootState = getAccordionRootContext();
  return setAccordionItemContext(new AccordionItemState({ ...props, rootState }));
}
function useAccordionTrigger(props) {
  const item = getAccordionItemContext();
  return new AccordionTriggerState(props, item);
}
function useAccordionContent(props) {
  const item = getAccordionItemContext();
  return new AccordionContentState(props, item);
}
function useAccordionHeader(props) {
  const item = getAccordionItemContext();
  return new AccordionHeaderState(props, item);
}

// node_modules/bits-ui/dist/internal/use-id.js
var count = 0;
function useId(prefix = "bits") {
  count++;
  return `${prefix}-${count}`;
}

// node_modules/bits-ui/dist/internal/noop.js
function noop2() {
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte
mark_module_start();
Accordion[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte";
var root_2 = add_locations(template(`<div><!></div>`), Accordion[FILENAME], [[54, 1]]);
function Accordion($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Accordion);
  validate_prop_bindings($$props, ["value", "ref"], [], Accordion);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), onValueChange = prop($$props, "onValueChange", 3, noop2), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "vertical"), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "type",
      "value",
      "ref",
      "id",
      "onValueChange",
      "loop",
      "orientation",
      "controlledValue"
    ],
    "restProps"
  );
  strict_equals(value(), void 0) && value(strict_equals($$props.type, "single") ? "" : []);
  const rootState = useAccordionRoot({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion = hmr(Accordion, () => Accordion[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion[HMR].source;
    set(Accordion[HMR].source, module.default[HMR].original);
  });
}
var accordion_default = Accordion;
mark_module_end(Accordion);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte
mark_module_start();
Accordion_item[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte";
var root_22 = add_locations(template(`<div><!></div>`), Accordion_item[FILENAME], [[33, 1]]);
function Accordion_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Accordion_item);
  validate_prop_bindings($$props, ["ref"], [], Accordion_item);
  let id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "value",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const itemState = useAccordionItem({
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_22();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_item = hmr(Accordion_item, () => Accordion_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_item[HMR].source;
    set(Accordion_item[HMR].source, module.default[HMR].original);
  });
}
var accordion_item_default = Accordion_item;
mark_module_end(Accordion_item);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte
mark_module_start();
Accordion_header[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte";
var root_23 = add_locations(template(`<div><!></div>`), Accordion_header[FILENAME], [[31, 1]]);
function Accordion_header($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Accordion_header);
  validate_prop_bindings($$props, ["ref"], [], Accordion_header);
  let id = prop($$props, "id", 19, useId), level = prop($$props, "level", 3, 2), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "level",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const headerState = useAccordionHeader({
    id: box.with(() => id()),
    level: box.with(() => level()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, headerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_23();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_header = hmr(Accordion_header, () => Accordion_header[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_header[HMR].source;
    set(Accordion_header[HMR].source, module.default[HMR].original);
  });
}
var accordion_header_default = Accordion_header;
mark_module_end(Accordion_header);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte
mark_module_start();
Accordion_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte";
var root_24 = add_locations(template(`<button><!></button>`), Accordion_trigger[FILENAME], [[31, 1]]);
function Accordion_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Accordion_trigger);
  validate_prop_bindings($$props, ["ref"], [], Accordion_trigger);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "ref",
      "id",
      "children",
      "child"
    ],
    "restProps"
  );
  const triggerState = useAccordionTrigger({
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_24();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { type: "button", ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_trigger = hmr(Accordion_trigger, () => Accordion_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_trigger[HMR].source;
    set(Accordion_trigger[HMR].source, module.default[HMR].original);
  });
}
var accordion_trigger_default = Accordion_trigger;
mark_module_end(Accordion_trigger);

// node_modules/runed/dist/utilities/Readable/readable.svelte.js
var _current, _start, _subscribers, _stop, _Readable_instances, subscribe_fn, unsubscribe_fn;
var Readable = class {
  constructor(initialValue, start) {
    __privateAdd(this, _Readable_instances);
    __privateAdd(this, _current, state());
    __privateAdd(this, _start);
    __privateAdd(this, _subscribers, 0);
    __privateAdd(this, _stop, null);
    __privateGet(this, _current).v = proxy(initialValue, null, __privateGet(this, _current));
    __privateSet(this, _start, start);
  }
  get current() {
    if (effect_tracking()) {
      user_effect(() => {
        __privateWrapper(this, _subscribers)._++;
        if (strict_equals(__privateGet(this, _subscribers), 1)) {
          __privateMethod(this, _Readable_instances, subscribe_fn).call(this, true);
        }
        return () => {
          tick().then(() => {
            __privateWrapper(this, _subscribers)._--;
            if (strict_equals(__privateGet(this, _subscribers), 0)) {
              __privateMethod(this, _Readable_instances, unsubscribe_fn).call(this);
            }
          });
        };
      });
    } else if (strict_equals(__privateGet(this, _subscribers), 0)) {
      __privateMethod(this, _Readable_instances, subscribe_fn).call(this, false);
      __privateMethod(this, _Readable_instances, unsubscribe_fn).call(this);
    }
    return get(__privateGet(this, _current));
  }
};
_current = new WeakMap();
_start = new WeakMap();
_subscribers = new WeakMap();
_stop = new WeakMap();
_Readable_instances = new WeakSet();
subscribe_fn = function(inEffect) {
  __privateSet(this, _stop, __privateGet(this, _start).call(this, (value) => {
    set(__privateGet(this, _current), proxy(value, null, __privateGet(this, _current)));
  }, inEffect) ?? null);
};
unsubscribe_fn = function() {
  if (strict_equals(__privateGet(this, _stop), null)) return;
  __privateGet(this, _stop).call(this);
  __privateSet(this, _stop, null);
};

// node_modules/runed/dist/utilities/activeElement/activeElement.svelte.js
var activeElement = new Readable(null, (set2, insideEffect) => {
  function update() {
    if (!BROWSER) return;
    set2(document.activeElement);
  }
  update();
  if (!insideEffect) return;
  document.addEventListener("focusin", update);
  document.addEventListener("focusout", update);
  return () => {
    document.removeEventListener("focusin", update);
    document.removeEventListener("focusout", update);
  };
});

// node_modules/runed/dist/utilities/useDebounce/useDebounce.svelte.js
function useDebounce(callback, wait = 250) {
  let context = state(null);
  function debounced(...args) {
    if (get(context)) {
      if (get(context).timeout) {
        clearTimeout(get(context).timeout);
      }
    } else {
      let resolve;
      let reject;
      let promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      set(context, proxy({ timeout: null, promise, resolve, reject }, null, context));
    }
    get(context).timeout = setTimeout(
      async () => {
        if (!get(context)) return;
        const ctx = get(context);
        set(context, null);
        try {
          ctx.resolve(await callback.apply(this, args));
        } catch (error) {
          ctx.reject(error);
        }
      },
      strict_equals(typeof wait, "function") ? wait() : wait
    );
    return get(context).promise;
  }
  debounced.cancel = async () => {
    if (!get(context) || strict_equals(get(context).timeout, null)) {
      await new Promise((resolve) => setTimeout(resolve, 0));
      if (!get(context) || strict_equals(get(context).timeout, null)) return;
    }
    clearTimeout(get(context).timeout);
    get(context).reject("Cancelled");
    set(context, null);
  };
  Object.defineProperty(debounced, "pending", {
    enumerable: true,
    get() {
      var _a;
      return !!((_a = get(context)) == null ? void 0 : _a.timeout);
    }
  });
  return debounced;
}

// node_modules/runed/dist/internal/utils/is.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/runed/dist/internal/utils/get.js
function get2(value) {
  if (isFunction2(value)) {
    return value();
  }
  return value;
}

// node_modules/runed/dist/utilities/ElementSize/ElementSize.svelte.js
var _size;
var ElementSize = class {
  constructor(node, options = { box: "border-box" }) {
    __privateAdd(this, _size, state(proxy({ width: 0, height: 0 })));
    var _a, _b;
    __privateGet(this, _size).v = proxy(
      {
        width: ((_a = options.initialSize) == null ? void 0 : _a.width) ?? 0,
        height: ((_b = options.initialSize) == null ? void 0 : _b.height) ?? 0
      },
      null,
      __privateGet(this, _size)
    );
    user_effect(() => {
      const node$ = get2(node);
      if (!node$) return;
      const observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const boxSize = strict_equals(options.box, "content-box") ? entry.contentBoxSize : entry.borderBoxSize;
          const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];
          get(__privateGet(this, _size)).width = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.inlineSize), 0);
          get(__privateGet(this, _size)).height = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.blockSize), 0);
        }
      });
      observer.observe(node$);
      return () => {
        observer.disconnect();
      };
    });
  }
  get width() {
    return get(__privateGet(this, _size)).width;
  }
  get height() {
    return get(__privateGet(this, _size)).height;
  }
};
_size = new WeakMap();

// node_modules/runed/dist/utilities/extract/extract.svelte.js
function extract(value, defaultValue) {
  if (isFunction2(value)) {
    const getter = value;
    return getter() ?? defaultValue ?? getter();
  }
  return value ?? defaultValue ?? value;
}

// node_modules/runed/dist/internal/utils/event.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  for (const event2 of events) {
    target.addEventListener(event2, handler, options);
  }
  return () => {
    for (const event2 of events) {
      target.removeEventListener(event2, handler, options);
    }
  };
}

// node_modules/runed/dist/utilities/useEventListener/useEventListener.svelte.js
function useEventListener(_target2, _events, handler, options) {
  user_effect(() => {
    const target = extract(_target2);
    const events = extract(_events);
    if (strict_equals(target, void 0) || strict_equals(target, null)) return;
    return addEventListener(target, events, handler, options);
  });
}

// node_modules/runed/dist/utilities/IsIdle/IsIdle.svelte.js
var DEFAULT_EVENTS = [
  "keypress",
  "mousemove",
  "touchmove",
  "click",
  "scroll"
];
var DEFAULT_OPTIONS = {
  events: DEFAULT_EVENTS,
  initialState: false,
  timeout: 6e4
};
var _current2, _lastActive;
var IsIdle = class {
  constructor(_options) {
    __privateAdd(this, _current2, state(false));
    __privateAdd(this, _lastActive, state(proxy(Date.now())));
    const options = { ...DEFAULT_OPTIONS, ..._options };
    const timeout = derived(() => extract(options.timeout));
    const events = derived(() => extract(options.events));
    const detectVisibilityChanges = derived(() => extract(options.detectVisibilityChanges));
    this.current = options.initialState;
    const debouncedReset = useDebounce(
      () => {
        this.current = true;
      },
      () => get(timeout)
    );
    debouncedReset();
    const handleActivity = () => {
      this.current = false;
      set(__privateGet(this, _lastActive), proxy(Date.now(), null, __privateGet(this, _lastActive)));
      debouncedReset();
    };
    useEventListener(
      () => window,
      get(events),
      () => {
        handleActivity();
      },
      { passive: true }
    );
    user_effect(() => {
      if (!get(detectVisibilityChanges)) return;
      useEventListener(document, ["visibilitychange"], () => {
        if (document.hidden) return;
        handleActivity();
      });
    });
  }
  get current() {
    return get(__privateGet(this, _current2));
  }
  set current(value) {
    set(__privateGet(this, _current2), proxy(value, null, __privateGet(this, _current2)));
  }
  get lastActive() {
    return get(__privateGet(this, _lastActive));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _current2)), owner, false);
  }
};
_current2 = new WeakMap();
_lastActive = new WeakMap();

// node_modules/runed/dist/utilities/IsMounted/IsMounted.svelte.js
var _isMounted;
var IsMounted = class {
  constructor() {
    __privateAdd(this, _isMounted, state(false));
    user_effect(() => {
      untrack(() => set(__privateGet(this, _isMounted), true));
      return () => {
        set(__privateGet(this, _isMounted), false);
      };
    });
  }
  get current() {
    return get(__privateGet(this, _isMounted));
  }
};
_isMounted = new WeakMap();

// node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/runed/dist/utilities/StateHistory/StateHistory.svelte.js
var _redoStack, _ignoreUpdate, _set, _log, _canUndo, _canRedo;
var StateHistory = class {
  constructor(value, set2, options) {
    __privateAdd(this, _redoStack, state(proxy([])));
    __privateAdd(this, _ignoreUpdate, false);
    __privateAdd(this, _set);
    __privateAdd(this, _log, state(proxy([])));
    __privateAdd(this, _canUndo, derived(() => this.log.length > 1));
    __privateAdd(this, _canRedo, derived(() => get(__privateGet(this, _redoStack)).length > 0));
    __publicField(this, "undo", () => {
      const [prev2, curr] = this.log.slice(-2);
      if (!curr || !prev2) return;
      __privateSet(this, _ignoreUpdate, true);
      get(__privateGet(this, _redoStack)).push(curr);
      this.log.pop();
      __privateGet(this, _set).call(this, prev2.snapshot);
    });
    __publicField(this, "redo", () => {
      const nextEvent = get(__privateGet(this, _redoStack)).pop();
      if (!nextEvent) return;
      __privateSet(this, _ignoreUpdate, true);
      this.log.push(nextEvent);
      __privateGet(this, _set).call(this, nextEvent.snapshot);
    });
    __privateGet(this, _redoStack).v = proxy([], null, __privateGet(this, _redoStack));
    __privateSet(this, _set, set2);
    const addEvent = (event) => {
      this.log.push(event);
      const capacity$ = get2(options == null ? void 0 : options.capacity);
      if (capacity$ && this.log.length > capacity$) {
        this.log = this.log.slice(-capacity$);
      }
    };
    watch(() => get2(value), (v) => {
      if (__privateGet(this, _ignoreUpdate)) {
        __privateSet(this, _ignoreUpdate, false);
        return;
      }
      addEvent({
        snapshot: v,
        timestamp: (/* @__PURE__ */ new Date()).getTime()
      });
      set(__privateGet(this, _redoStack), proxy([], null, __privateGet(this, _redoStack)));
    });
    watch(() => get2(options == null ? void 0 : options.capacity), (c) => {
      if (!c) return;
      this.log = this.log.slice(-c);
    });
  }
  get log() {
    return get(__privateGet(this, _log));
  }
  set log(value) {
    set(__privateGet(this, _log), proxy(value, null, __privateGet(this, _log)));
  }
  get canUndo() {
    return get(__privateGet(this, _canUndo));
  }
  set canUndo(_) {
    throw new Error("Cannot update a derived property ('canUndo')");
  }
  get canRedo() {
    return get(__privateGet(this, _canRedo));
  }
  set canRedo(_) {
    throw new Error("Cannot update a derived property ('canRedo')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _log)), owner, false);
    add_owner(get(__privateGet(this, _canUndo)), owner, false);
    add_owner(get(__privateGet(this, _canRedo)), owner, false);
  }
};
_redoStack = new WeakMap();
_ignoreUpdate = new WeakMap();
_set = new WeakMap();
_log = new WeakMap();
_canUndo = new WeakMap();
_canRedo = new WeakMap();

// node_modules/runed/dist/utilities/Previous/Previous.svelte.js
var _previous, _curr;
var Previous = class {
  constructor(getter) {
    __privateAdd(this, _previous, state());
    __privateAdd(this, _curr);
    user_effect(() => {
      set(__privateGet(this, _previous), proxy(__privateGet(this, _curr), null, __privateGet(this, _previous)));
      __privateSet(this, _curr, getter());
    });
  }
  get current() {
    return get(__privateGet(this, _previous));
  }
};
_previous = new WeakMap();
_curr = new WeakMap();

// node_modules/runed/dist/utilities/IsFocusWithin/IsFocusWithin.svelte.js
var _node, _target, _current3;
var IsFocusWithin = class {
  constructor(node) {
    __privateAdd(this, _node);
    __privateAdd(this, _target, derived(() => extract(__privateGet(this, _node))));
    __privateAdd(this, _current3, derived(() => {
      if (!get(__privateGet(this, _target)) || !activeElement.current) return false;
      return get(__privateGet(this, _target)).contains(activeElement.current);
    }));
    __privateSet(this, _node, node);
  }
  get current() {
    return get(__privateGet(this, _current3));
  }
  set current(_) {
    throw new Error("Cannot update a derived property ('current')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _current3)), owner, false);
  }
};
_node = new WeakMap();
_target = new WeakMap();
_current3 = new WeakMap();

// node_modules/bits-ui/dist/internal/use-state-machine.svelte.js
function useStateMachine(initialState, machine) {
  const state2 = box(initialState);
  function reducer(event) {
    const nextState = machine[state2.current][event];
    return nextState ?? state2.current;
  }
  const dispatch = (event) => {
    state2.current = reducer(event);
  };
  return { state: state2, dispatch };
}

// node_modules/bits-ui/dist/bits/utilities/presence-layer/usePresence.svelte.js
function usePresence(present, id) {
  let styles = state(proxy({}));
  let prevAnimationNameState = state("none");
  const initialState = present.current ? "mounted" : "unmounted";
  let node = state(null);
  const prevPresent = new Previous(() => present.current);
  user_effect(() => {
    if (!id.current) return;
    if (!present.current) return;
    afterTick(() => {
      set(node, proxy(document.getElementById(id.current), null, node));
    });
  });
  const { state: state2, dispatch } = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
    unmounted: { MOUNT: "mounted" }
  });
  user_effect(() => {
    const currPresent = present.current;
    untrack(() => {
      if (!get(node)) {
        set(node, proxy(document.getElementById(id.current), null, node));
      }
      if (!get(node)) return;
      const hasPresentChanged = strict_equals(currPresent, prevPresent.current, false);
      if (!hasPresentChanged) return;
      const prevAnimationName = get(prevAnimationNameState);
      const currAnimationName = getAnimationName(get(node));
      if (currPresent) {
        dispatch("MOUNT");
      } else if (strict_equals(currAnimationName, "none") || strict_equals(get(styles).display, "none")) {
        dispatch("UNMOUNT");
      } else {
        const isAnimating = strict_equals(prevAnimationName, currAnimationName, false);
        if (prevPresent && isAnimating) {
          dispatch("ANIMATION_OUT");
        } else {
          dispatch("UNMOUNT");
        }
      }
    });
  });
  function handleAnimationEnd(event) {
    if (!get(node)) {
      set(node, proxy(document.getElementById(id.current), null, node));
    }
    if (!get(node)) return;
    const currAnimationName = getAnimationName(get(node));
    const isCurrentAnimation = currAnimationName.includes(event.animationName) || strict_equals(currAnimationName, "none");
    if (strict_equals(event.target, get(node)) && isCurrentAnimation) {
      dispatch("ANIMATION_END");
    }
  }
  function handleAnimationStart(event) {
    if (!get(node)) {
      set(node, proxy(document.getElementById(id.current), null, node));
    }
    if (!get(node)) return;
    if (strict_equals(event.target, get(node))) {
      set(prevAnimationNameState, proxy(getAnimationName(get(node)), null, prevAnimationNameState));
    }
  }
  user_effect(() => {
    state2.current;
    untrack(() => {
      if (!get(node)) {
        set(node, proxy(document.getElementById(id.current), null, node));
      }
      if (!get(node)) return;
      const currAnimationName = getAnimationName(get(node));
      set(prevAnimationNameState, proxy(strict_equals(state2.current, "mounted") ? currAnimationName : "none", null, prevAnimationNameState));
    });
  });
  user_effect(() => {
    if (!get(node)) return;
    set(styles, proxy(getComputedStyle(get(node)), null, styles));
    get(node).addEventListener("animationstart", handleAnimationStart);
    get(node).addEventListener("animationcancel", handleAnimationEnd);
    get(node).addEventListener("animationend", handleAnimationEnd);
    return () => {
      var _a, _b, _c;
      (_a = get(node)) == null ? void 0 : _a.removeEventListener("animationstart", handleAnimationStart);
      (_b = get(node)) == null ? void 0 : _b.removeEventListener("animationcancel", handleAnimationEnd);
      (_c = get(node)) == null ? void 0 : _c.removeEventListener("animationend", handleAnimationEnd);
    };
  });
  const isPresentDerived = derived(() => ["mounted", "unmountSuspended"].includes(state2.current));
  return {
    get current() {
      return get(isPresentDerived);
    }
  };
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}

// node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte
mark_module_start();
Presence_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte";
function Presence_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Presence_layer);
  validate_prop_bindings($$props, [], [], Presence_layer);
  const isPresent = usePresence(box.with(() => $$props.present), box.with(() => $$props.id));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => $$props.forceMount || $$props.present || isPresent.current, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    snippet(node_1, () => $$props.presence ?? noop, () => ({ present: isPresent }));
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Presence_layer = hmr(Presence_layer, () => Presence_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Presence_layer[HMR].source;
    set(Presence_layer[HMR].source, module.default[HMR].original);
  });
}
var presence_layer_default = Presence_layer;
mark_module_end(Presence_layer);

// node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte
mark_module_start();
Accordion_content[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte";
var root_3 = add_locations(template(`<div><!></div>`), Accordion_content[FILENAME], [[38, 3]]);
function Accordion_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Accordion_content);
  validate_prop_bindings($$props, ["ref"], [], Accordion_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "ref",
      "id",
      "forceMount",
      "children"
    ],
    "restProps"
  );
  const contentState = useAccordionContent({
    forceMount: box.with(() => forceMount()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Accordion_content, ($$anchor2, $$arg0) => {
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      const mergedProps = derived(() => mergeProps(restProps, contentState.props, {
        hidden: forceMount() ? void 0 : !present().current
      }));
      get(mergedProps);
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({
            props: get(mergedProps),
            ...contentState.snippetProps
          }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var div = root_3();
          let attributes;
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
          append($$anchor3, div);
        }
      );
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      forceMount: true,
      get present() {
        return contentState.present;
      },
      get id() {
        return id();
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_content = hmr(Accordion_content, () => Accordion_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_content[HMR].source;
    set(Accordion_content[HMR].source, module.default[HMR].original);
  });
}
var accordion_content_default = Accordion_content;
mark_module_end(Accordion_content);

// node_modules/bits-ui/dist/bits/alert-dialog/exports.js
var exports_exports2 = {};
__export(exports_exports2, {
  Action: () => alert_dialog_action_default,
  Cancel: () => alert_dialog_cancel_default,
  Content: () => alert_dialog_content_default,
  Description: () => dialog_description_default,
  Overlay: () => dialog_overlay_default,
  Portal: () => portal_default,
  Root: () => alert_dialog_default,
  Title: () => dialog_title_default,
  Trigger: () => dialog_trigger_default
});

// node_modules/bits-ui/dist/bits/dialog/dialog.svelte.js
function createAttrs(variant) {
  return {
    content: `data-${variant}-content`,
    trigger: `data-${variant}-trigger`,
    overlay: `data-${variant}-overlay`,
    title: `data-${variant}-title`,
    description: `data-${variant}-description`,
    close: `data-${variant}-close`,
    cancel: `data-${variant}-cancel`,
    action: `data-${variant}-action`
  };
}
var _triggerNode, _titleNode, _contentNode, _descriptionNode, _contentId, _titleId, _triggerId, _descriptionId, _cancelNode, _attrs, _sharedProps;
var DialogRootState = class {
  constructor(props) {
    __publicField(this, "open");
    __publicField(this, "variant");
    __privateAdd(this, _triggerNode, state(null));
    __privateAdd(this, _titleNode, state(null));
    __privateAdd(this, _contentNode, state(null));
    __privateAdd(this, _descriptionNode, state(null));
    __privateAdd(this, _contentId, state(void 0));
    __privateAdd(this, _titleId, state(void 0));
    __privateAdd(this, _triggerId, state(void 0));
    __privateAdd(this, _descriptionId, state(void 0));
    __privateAdd(this, _cancelNode, state(null));
    __privateAdd(this, _attrs, derived(() => createAttrs(this.variant.current)));
    __publicField(this, "handleOpen", () => {
      if (this.open.current) return;
      this.open.current = true;
    });
    __publicField(this, "handleClose", () => {
      if (!this.open.current) return;
      this.open.current = false;
    });
    __privateAdd(this, _sharedProps, derived(() => ({
      "data-state": getDataOpenClosed(this.open.current)
    })));
    this.open = props.open;
    this.variant = props.variant;
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode), proxy(value, null, __privateGet(this, _triggerNode)));
  }
  get titleNode() {
    return get(__privateGet(this, _titleNode));
  }
  set titleNode(value) {
    set(__privateGet(this, _titleNode), proxy(value, null, __privateGet(this, _titleNode)));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode), proxy(value, null, __privateGet(this, _contentNode)));
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode), proxy(value, null, __privateGet(this, _descriptionNode)));
  }
  get contentId() {
    return get(__privateGet(this, _contentId));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId), proxy(value, null, __privateGet(this, _contentId)));
  }
  get titleId() {
    return get(__privateGet(this, _titleId));
  }
  set titleId(value) {
    set(__privateGet(this, _titleId), proxy(value, null, __privateGet(this, _titleId)));
  }
  get triggerId() {
    return get(__privateGet(this, _triggerId));
  }
  set triggerId(value) {
    set(__privateGet(this, _triggerId), proxy(value, null, __privateGet(this, _triggerId)));
  }
  get descriptionId() {
    return get(__privateGet(this, _descriptionId));
  }
  set descriptionId(value) {
    set(__privateGet(this, _descriptionId), proxy(value, null, __privateGet(this, _descriptionId)));
  }
  get cancelNode() {
    return get(__privateGet(this, _cancelNode));
  }
  set cancelNode(value) {
    set(__privateGet(this, _cancelNode), proxy(value, null, __privateGet(this, _cancelNode)));
  }
  get attrs() {
    return get(__privateGet(this, _attrs));
  }
  set attrs(_) {
    throw new Error("Cannot update a derived property ('attrs')");
  }
  get sharedProps() {
    return get(__privateGet(this, _sharedProps));
  }
  set sharedProps(_) {
    throw new Error("Cannot update a derived property ('sharedProps')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _triggerNode)), owner, false);
    add_owner(get(__privateGet(this, _titleNode)), owner, false);
    add_owner(get(__privateGet(this, _contentNode)), owner, false);
    add_owner(get(__privateGet(this, _descriptionNode)), owner, false);
    add_owner(get(__privateGet(this, _contentId)), owner, false);
    add_owner(get(__privateGet(this, _titleId)), owner, false);
    add_owner(get(__privateGet(this, _triggerId)), owner, false);
    add_owner(get(__privateGet(this, _descriptionId)), owner, false);
    add_owner(get(__privateGet(this, _cancelNode)), owner, false);
    add_owner(get(__privateGet(this, _attrs)), owner, false);
    add_owner(get(__privateGet(this, _sharedProps)), owner, false);
  }
};
_triggerNode = new WeakMap();
_titleNode = new WeakMap();
_contentNode = new WeakMap();
_descriptionNode = new WeakMap();
_contentId = new WeakMap();
_titleId = new WeakMap();
_triggerId = new WeakMap();
_descriptionId = new WeakMap();
_cancelNode = new WeakMap();
_attrs = new WeakMap();
_sharedProps = new WeakMap();
var _id6, _ref6, _root2, _disabled2, _onclick, _onpointerdown2, _onkeydown2, _props6;
var DialogTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _id6);
    __privateAdd(this, _ref6);
    __privateAdd(this, _root2);
    __privateAdd(this, _disabled2);
    __privateAdd(this, _onclick, (e) => {
      if (__privateGet(this, _disabled2).current) return;
      if (e.button > 0) return;
      __privateGet(this, _root2).handleOpen();
    });
    __privateAdd(this, _onpointerdown2, (e) => {
      if (__privateGet(this, _disabled2).current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      if (e.button > 0) return;
      e.preventDefault();
      __privateGet(this, _root2).handleOpen();
    });
    __privateAdd(this, _onkeydown2, (e) => {
      if (__privateGet(this, _disabled2).current) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        e.preventDefault();
        __privateGet(this, _root2).handleOpen();
      }
    });
    __privateAdd(this, _props6, derived(() => ({
      id: __privateGet(this, _id6).current,
      "aria-haspopup": "dialog",
      "aria-expanded": getAriaExpanded(__privateGet(this, _root2).open.current),
      "aria-controls": __privateGet(this, _root2).contentId,
      [__privateGet(this, _root2).attrs.trigger]: "",
      onpointerdown: __privateGet(this, _onpointerdown2),
      onkeydown: __privateGet(this, _onkeydown2),
      onclick: __privateGet(this, _onclick),
      ...__privateGet(this, _root2).sharedProps
    })));
    __privateSet(this, _id6, props.id);
    __privateSet(this, _root2, root17);
    __privateSet(this, _ref6, props.ref);
    __privateSet(this, _disabled2, props.disabled);
    useRefById({
      id: __privateGet(this, _id6),
      ref: __privateGet(this, _ref6),
      onRefChange: (node) => {
        __privateGet(this, _root2).triggerNode = node;
        __privateGet(this, _root2).triggerId = node == null ? void 0 : node.id;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props6));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props6)), owner, false);
  }
};
_id6 = new WeakMap();
_ref6 = new WeakMap();
_root2 = new WeakMap();
_disabled2 = new WeakMap();
_onclick = new WeakMap();
_onpointerdown2 = new WeakMap();
_onkeydown2 = new WeakMap();
_props6 = new WeakMap();
var _id7, _ref7, _root3, _variant, _disabled3, _attr, _onclick2, _onpointerdown3, _onkeydown3, _props7;
var DialogCloseState = class {
  constructor(props, root17) {
    __privateAdd(this, _id7);
    __privateAdd(this, _ref7);
    __privateAdd(this, _root3);
    __privateAdd(this, _variant);
    __privateAdd(this, _disabled3);
    __privateAdd(this, _attr, derived(() => __privateGet(this, _root3).attrs[__privateGet(this, _variant).current]));
    __privateAdd(this, _onclick2, (e) => {
      if (__privateGet(this, _disabled3).current) return;
      if (e.button > 0) return;
      __privateGet(this, _root3).handleClose();
    });
    __privateAdd(this, _onpointerdown3, (e) => {
      if (__privateGet(this, _disabled3).current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      if (e.button > 0) return;
      e.preventDefault();
      __privateGet(this, _root3).handleClose();
    });
    __privateAdd(this, _onkeydown3, (e) => {
      if (__privateGet(this, _disabled3).current) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        e.preventDefault();
        __privateGet(this, _root3).handleClose();
      }
    });
    __privateAdd(this, _props7, derived(() => ({
      id: __privateGet(this, _id7).current,
      [get(__privateGet(this, _attr))]: "",
      onpointerdown: __privateGet(this, _onpointerdown3),
      onclick: __privateGet(this, _onclick2),
      onkeydown: __privateGet(this, _onkeydown3),
      ...__privateGet(this, _root3).sharedProps
    })));
    __privateSet(this, _root3, root17);
    __privateSet(this, _ref7, props.ref);
    __privateSet(this, _id7, props.id);
    __privateSet(this, _variant, props.variant);
    __privateSet(this, _disabled3, props.disabled);
    useRefById({
      id: __privateGet(this, _id7),
      ref: __privateGet(this, _ref7),
      deps: () => __privateGet(this, _root3).open.current
    });
  }
  get props() {
    return get(__privateGet(this, _props7));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props7)), owner, false);
  }
};
_id7 = new WeakMap();
_ref7 = new WeakMap();
_root3 = new WeakMap();
_variant = new WeakMap();
_disabled3 = new WeakMap();
_attr = new WeakMap();
_onclick2 = new WeakMap();
_onpointerdown3 = new WeakMap();
_onkeydown3 = new WeakMap();
_props7 = new WeakMap();
var _id8, _ref8, _root4, _attr2, _props8;
var DialogActionState = class {
  constructor(props, root17) {
    __privateAdd(this, _id8);
    __privateAdd(this, _ref8);
    __privateAdd(this, _root4);
    __privateAdd(this, _attr2, derived(() => __privateGet(this, _root4).attrs.action));
    __privateAdd(this, _props8, derived(() => ({
      id: __privateGet(this, _id8).current,
      [get(__privateGet(this, _attr2))]: "",
      ...__privateGet(this, _root4).sharedProps
    })));
    __privateSet(this, _id8, props.id);
    __privateSet(this, _ref8, props.ref);
    __privateSet(this, _root4, root17);
    useRefById({ id: __privateGet(this, _id8), ref: __privateGet(this, _ref8) });
  }
  get props() {
    return get(__privateGet(this, _props8));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props8)), owner, false);
  }
};
_id8 = new WeakMap();
_ref8 = new WeakMap();
_root4 = new WeakMap();
_attr2 = new WeakMap();
_props8 = new WeakMap();
var _id9, _ref9, _root5, _level2, _props9;
var DialogTitleState = class {
  constructor(props, root17) {
    __privateAdd(this, _id9);
    __privateAdd(this, _ref9);
    __privateAdd(this, _root5);
    __privateAdd(this, _level2);
    __privateAdd(this, _props9, derived(() => ({
      id: __privateGet(this, _id9).current,
      role: "heading",
      "aria-level": __privateGet(this, _level2).current,
      [__privateGet(this, _root5).attrs.title]: "",
      ...__privateGet(this, _root5).sharedProps
    })));
    __privateSet(this, _id9, props.id);
    __privateSet(this, _root5, root17);
    __privateSet(this, _ref9, props.ref);
    __privateSet(this, _level2, props.level);
    useRefById({
      id: __privateGet(this, _id9),
      ref: __privateGet(this, _ref9),
      onRefChange: (node) => {
        __privateGet(this, _root5).titleNode = node;
        __privateGet(this, _root5).titleId = node == null ? void 0 : node.id;
      },
      deps: () => __privateGet(this, _root5).open.current
    });
  }
  get props() {
    return get(__privateGet(this, _props9));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props9)), owner, false);
  }
};
_id9 = new WeakMap();
_ref9 = new WeakMap();
_root5 = new WeakMap();
_level2 = new WeakMap();
_props9 = new WeakMap();
var _id10, _ref10, _root6, _props10;
var DialogDescriptionState = class {
  constructor(props, root17) {
    __privateAdd(this, _id10);
    __privateAdd(this, _ref10);
    __privateAdd(this, _root6);
    __privateAdd(this, _props10, derived(() => ({
      id: __privateGet(this, _id10).current,
      [__privateGet(this, _root6).attrs.description]: "",
      ...__privateGet(this, _root6).sharedProps
    })));
    __privateSet(this, _id10, props.id);
    __privateSet(this, _root6, root17);
    __privateSet(this, _ref10, props.ref);
    useRefById({
      id: __privateGet(this, _id10),
      ref: __privateGet(this, _ref10),
      deps: () => __privateGet(this, _root6).open.current,
      onRefChange: (node) => {
        __privateGet(this, _root6).descriptionNode = node;
        __privateGet(this, _root6).descriptionId = node == null ? void 0 : node.id;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props10));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props10)), owner, false);
  }
};
_id10 = new WeakMap();
_ref10 = new WeakMap();
_root6 = new WeakMap();
_props10 = new WeakMap();
var _id11, _ref11, _snippetProps2, _props11;
var DialogContentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id11);
    __privateAdd(this, _ref11);
    __publicField(this, "root");
    __privateAdd(this, _snippetProps2, derived(() => ({ open: this.root.open.current })));
    __privateAdd(this, _props11, derived(() => ({
      id: __privateGet(this, _id11).current,
      role: strict_equals(this.root.variant.current, "alert-dialog") ? "alertdialog" : "dialog",
      "aria-describedby": this.root.descriptionId,
      "aria-labelledby": this.root.titleId,
      [this.root.attrs.content]: "",
      style: { pointerEvents: "auto" },
      ...this.root.sharedProps
    })));
    __privateSet(this, _id11, props.id);
    this.root = root17;
    __privateSet(this, _ref11, props.ref);
    useRefById({
      id: __privateGet(this, _id11),
      ref: __privateGet(this, _ref11),
      deps: () => this.root.open.current,
      onRefChange: (node) => {
        this.root.contentNode = node;
        this.root.contentId = node == null ? void 0 : node.id;
      }
    });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps2));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props11));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps2)), owner, false);
    add_owner(get(__privateGet(this, _props11)), owner, false);
  }
};
_id11 = new WeakMap();
_ref11 = new WeakMap();
_snippetProps2 = new WeakMap();
_props11 = new WeakMap();
var _id12, _ref12, _snippetProps3, _props12;
var DialogOverlayState = class {
  constructor(props, root17) {
    __privateAdd(this, _id12);
    __privateAdd(this, _ref12);
    __publicField(this, "root");
    __privateAdd(this, _snippetProps3, derived(() => ({ open: this.root.open.current })));
    __privateAdd(this, _props12, derived(() => ({
      id: __privateGet(this, _id12).current,
      [this.root.attrs.overlay]: "",
      style: { pointerEvents: "auto" },
      ...this.root.sharedProps
    })));
    __privateSet(this, _id12, props.id);
    __privateSet(this, _ref12, props.ref);
    this.root = root17;
    useRefById({
      id: __privateGet(this, _id12),
      ref: __privateGet(this, _ref12),
      deps: () => this.root.open.current
    });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps3));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props12));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps3)), owner, false);
    add_owner(get(__privateGet(this, _props12)), owner, false);
  }
};
_id12 = new WeakMap();
_ref12 = new WeakMap();
_snippetProps3 = new WeakMap();
_props12 = new WeakMap();
var _id13, _ref13, _root7, _disabled4, _onclick3, _onpointerdown4, _onkeydown4, _props13;
var AlertDialogCancelState = class {
  constructor(props, root17) {
    __privateAdd(this, _id13);
    __privateAdd(this, _ref13);
    __privateAdd(this, _root7);
    __privateAdd(this, _disabled4);
    __privateAdd(this, _onclick3, (e) => {
      if (__privateGet(this, _disabled4).current) return;
      if (e.button > 0) return;
      __privateGet(this, _root7).handleClose();
    });
    __privateAdd(this, _onpointerdown4, (e) => {
      if (__privateGet(this, _disabled4).current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      if (e.button > 0) return;
      e.preventDefault();
      __privateGet(this, _root7).handleClose();
    });
    __privateAdd(this, _onkeydown4, (e) => {
      if (__privateGet(this, _disabled4).current) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        e.preventDefault();
        __privateGet(this, _root7).handleClose();
      }
    });
    __privateAdd(this, _props13, derived(() => ({
      id: __privateGet(this, _id13).current,
      [__privateGet(this, _root7).attrs.cancel]: "",
      onpointerdown: __privateGet(this, _onpointerdown4),
      onclick: __privateGet(this, _onclick3),
      onkeydown: __privateGet(this, _onkeydown4),
      ...__privateGet(this, _root7).sharedProps
    })));
    __privateSet(this, _id13, props.id);
    __privateSet(this, _ref13, props.ref);
    __privateSet(this, _root7, root17);
    __privateSet(this, _disabled4, props.disabled);
    useRefById({
      id: __privateGet(this, _id13),
      ref: __privateGet(this, _ref13),
      deps: () => __privateGet(this, _root7).open.current,
      onRefChange: (node) => {
        __privateGet(this, _root7).cancelNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props13));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props13)), owner, false);
  }
};
_id13 = new WeakMap();
_ref13 = new WeakMap();
_root7 = new WeakMap();
_disabled4 = new WeakMap();
_onclick3 = new WeakMap();
_onpointerdown4 = new WeakMap();
_onkeydown4 = new WeakMap();
_props13 = new WeakMap();
var [setDialogRootContext, getDialogRootContext] = createContext("Dialog.Root");
function useDialogRoot(props) {
  return setDialogRootContext(new DialogRootState(props));
}
function useDialogTrigger(props) {
  const root17 = getDialogRootContext();
  return new DialogTriggerState(props, root17);
}
function useDialogTitle(props) {
  return new DialogTitleState(props, getDialogRootContext());
}
function useDialogContent(props) {
  return new DialogContentState(props, getDialogRootContext());
}
function useDialogOverlay(props) {
  return new DialogOverlayState(props, getDialogRootContext());
}
function useDialogDescription(props) {
  return new DialogDescriptionState(props, getDialogRootContext());
}
function useDialogClose(props) {
  return new DialogCloseState(props, getDialogRootContext());
}
function useAlertDialogCancel(props) {
  return new AlertDialogCancelState(props, getDialogRootContext());
}
function useAlertDialogAction(props) {
  return new DialogActionState(props, getDialogRootContext());
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte
mark_module_start();
Alert_dialog[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte";
function Alert_dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Alert_dialog);
  validate_prop_bindings($$props, ["open"], [], Alert_dialog);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), controlledOpen = prop($$props, "controlledOpen", 3, false);
  useDialogRoot({
    variant: box.with(() => "alert-dialog"),
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    })
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog = hmr(Alert_dialog, () => Alert_dialog[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog[HMR].source;
    set(Alert_dialog[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_default = Alert_dialog;
mark_module_end(Alert_dialog);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte
mark_module_start();
Dialog_title[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte";
var root_25 = add_locations(template(`<div><!></div>`), Dialog_title[FILENAME], [[31, 1]]);
function Dialog_title($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog_title);
  validate_prop_bindings($$props, ["ref"], [], Dialog_title);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), level = prop($$props, "level", 3, 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "level"
    ],
    "restProps"
  );
  const titleState = useDialogTitle({
    id: box.with(() => id()),
    level: box.with(() => level()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, titleState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_25();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_title = hmr(Dialog_title, () => Dialog_title[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_title[HMR].source;
    set(Dialog_title[HMR].source, module.default[HMR].original);
  });
}
var dialog_title_default = Dialog_title;
mark_module_end(Dialog_title);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte
mark_module_start();
Alert_dialog_action[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte";
var root_26 = add_locations(template(`<button><!></button>`), Alert_dialog_action[FILENAME], [[29, 1]]);
function Alert_dialog_action($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Alert_dialog_action);
  validate_prop_bindings($$props, ["ref"], [], Alert_dialog_action);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const actionState = useAlertDialogAction({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, actionState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_26();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_action = hmr(Alert_dialog_action, () => Alert_dialog_action[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_action[HMR].source;
    set(Alert_dialog_action[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_action_default = Alert_dialog_action;
mark_module_end(Alert_dialog_action);

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte
mark_module_start();
Alert_dialog_cancel[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte";
var root_27 = add_locations(template(`<button><!></button>`), Alert_dialog_cancel[FILENAME], [[31, 1]]);
function Alert_dialog_cancel($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Alert_dialog_cancel);
  validate_prop_bindings($$props, ["ref"], [], Alert_dialog_cancel);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "disabled"
    ],
    "restProps"
  );
  const cancelState = useAlertDialogCancel({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = derived(() => mergeProps(restProps, cancelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_27();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_cancel = hmr(Alert_dialog_cancel, () => Alert_dialog_cancel[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_cancel[HMR].source;
    set(Alert_dialog_cancel[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_cancel_default = Alert_dialog_cancel;
mark_module_end(Alert_dialog_cancel);

// node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte
mark_module_start();
Portal_consumer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte";
function Portal_consumer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal_consumer);
  validate_prop_bindings($$props, [], [], Portal_consumer);
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => $$props.children, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    snippet(node_1, () => $$props.children ?? noop);
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal_consumer = hmr(Portal_consumer, () => Portal_consumer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal_consumer[HMR].source;
    set(Portal_consumer[HMR].source, module.default[HMR].original);
  });
}
var portal_consumer_default = Portal_consumer;
mark_module_end(Portal_consumer);

// node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte
mark_module_start();
Portal[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte";
function Portal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal);
  validate_prop_bindings($$props, [], [], Portal);
  let to = prop($$props, "to", 3, "body");
  const context = getAllContexts();
  let target = derived(getTarget);
  function getTarget() {
    if (!isBrowser || $$props.disabled) return null;
    let localTarget = null;
    if (strict_equals(typeof to(), "string")) {
      localTarget = document.querySelector(to());
      if (strict_equals(localTarget, null)) {
        if (DEV) {
          throw new Error(`Target element "${to()}" not found.`);
        }
      }
    } else if (to() instanceof HTMLElement || to() instanceof DocumentFragment) {
      localTarget = to();
    } else {
      if (DEV) {
        throw new TypeError(`Unknown portal target type: ${strict_equals(to(), null) ? "null" : typeof to()}. Allowed types: string (query selector), HTMLElement, or DocumentFragment.`);
      }
    }
    return localTarget;
  }
  let instance;
  user_effect(() => {
    if (!get(target) || $$props.disabled) {
      if (instance) {
        unmount(instance);
        instance = null;
      }
      return;
    }
    untrack(() => instance = mount(portal_consumer_default, {
      target: get(target),
      props: { children: $$props.children },
      context
    }));
    return () => {
      if (instance) {
        unmount(instance);
        instance = null;
      }
    };
  });
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => $$props.disabled, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    snippet(node_1, () => $$props.children ?? noop);
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal = hmr(Portal, () => Portal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal[HMR].source;
    set(Portal[HMR].source, module.default[HMR].original);
  });
}
var portal_default = Portal;
mark_module_end(Portal);

// node_modules/bits-ui/dist/internal/events.js
function addEventListener2(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}

// node_modules/bits-ui/dist/internal/debounce.js
function debounce(fn, wait = 500) {
  let timeout = null;
  const debounced = (...args) => {
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn(...args);
    }, wait);
  };
  debounced.destroy = () => {
    if (timeout !== null) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}

// node_modules/bits-ui/dist/internal/elements.js
function isOrContainsTarget(node, target) {
  return node === target || node.contains(target);
}
function getOwnerDocument(el) {
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/useDismissibleLayer.svelte.js
globalThis.bitsDismissableLayers ?? (globalThis.bitsDismissableLayers = /* @__PURE__ */ new Map());
var _interactOutsideProp, _behaviorType, _interceptedEvents, _isResponsibleLayer, _documentObj, _enabled, _isFocusInsideDOMTree, _onFocusOutside, _currNode, _isValidEventProp, _unsubClickListener, _handleFocus, _DismissibleLayerState_instances, addEventListeners_fn, _handleDismiss, _handleInteractOutside, _markInterceptedEvent, _markNonInterceptedEvent, _markResponsibleLayer, _isTargetWithinLayer, _resetState, isAnyEventIntercepted_fn, _onfocuscapture, _onblurcapture;
var DismissibleLayerState = class {
  constructor(props) {
    __privateAdd(this, _DismissibleLayerState_instances);
    __privateAdd(this, _interactOutsideProp);
    __privateAdd(this, _behaviorType);
    __privateAdd(this, _interceptedEvents, { pointerdown: false });
    __privateAdd(this, _isResponsibleLayer, false);
    __publicField(this, "node", box(null));
    __privateAdd(this, _documentObj);
    __privateAdd(this, _enabled);
    __privateAdd(this, _isFocusInsideDOMTree, state(false));
    __privateAdd(this, _onFocusOutside);
    __privateAdd(this, _currNode, state(null));
    __privateAdd(this, _isValidEventProp);
    __privateAdd(this, _unsubClickListener, noop2);
    __privateAdd(this, _handleFocus, (event) => {
      if (event.defaultPrevented) return;
      if (!this.currNode) return;
      afterTick(() => {
        var _a, _b;
        if (!this.currNode || __privateGet(this, _isTargetWithinLayer).call(this, event.target)) return;
        if (event.target && !get(__privateGet(this, _isFocusInsideDOMTree))) {
          (_b = (_a = __privateGet(this, _onFocusOutside)).current) == null ? void 0 : _b.call(_a, event);
        }
      });
    });
    __privateAdd(this, _handleDismiss, (e) => {
      let event = e;
      if (event.defaultPrevented) {
        event = createWrappedEvent(e);
      }
      __privateGet(this, _interactOutsideProp).current(e);
    });
    __privateAdd(this, _handleInteractOutside, debounce(
      (e) => {
        if (!this.currNode) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        const isEventValid = __privateGet(this, _isValidEventProp).current(e, this.currNode) || isValidEvent(e, this.currNode);
        if (!__privateGet(this, _isResponsibleLayer) || __privateMethod(this, _DismissibleLayerState_instances, isAnyEventIntercepted_fn).call(this) || !isEventValid) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        let event = e;
        if (event.defaultPrevented) {
          event = createWrappedEvent(event);
        }
        if (strict_equals(__privateGet(this, _behaviorType).current, "close", false) && strict_equals(__privateGet(this, _behaviorType).current, "defer-otherwise-close", false)) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        if (strict_equals(e.pointerType, "touch")) {
          __privateGet(this, _unsubClickListener).call(this);
          __privateSet(this, _unsubClickListener, addEventListener2(__privateGet(this, _documentObj), "click", __privateGet(this, _handleDismiss), { once: true }));
        } else {
          __privateGet(this, _interactOutsideProp).current(event);
        }
      },
      10
    ));
    __privateAdd(this, _markInterceptedEvent, (e) => {
      __privateGet(this, _interceptedEvents)[e.type] = true;
    });
    __privateAdd(this, _markNonInterceptedEvent, (e) => {
      __privateGet(this, _interceptedEvents)[e.type] = false;
    });
    __privateAdd(this, _markResponsibleLayer, () => {
      if (!this.node.current) return;
      __privateSet(this, _isResponsibleLayer, isResponsibleLayer(this.node.current));
    });
    __privateAdd(this, _isTargetWithinLayer, (target) => {
      if (!this.node.current) return false;
      return isOrContainsTarget(this.node.current, target);
    });
    __privateAdd(this, _resetState, debounce(
      () => {
        for (const eventType in __privateGet(this, _interceptedEvents)) {
          __privateGet(this, _interceptedEvents)[eventType] = false;
        }
        __privateSet(this, _isResponsibleLayer, false);
      },
      20
    ));
    __privateAdd(this, _onfocuscapture, () => {
      set(__privateGet(this, _isFocusInsideDOMTree), true);
    });
    __privateAdd(this, _onblurcapture, () => {
      set(__privateGet(this, _isFocusInsideDOMTree), false);
    });
    __publicField(this, "props", {
      onfocuscapture: __privateGet(this, _onfocuscapture),
      onblurcapture: __privateGet(this, _onblurcapture)
    });
    __privateSet(this, _enabled, props.enabled);
    __privateSet(this, _isValidEventProp, props.isValidEvent);
    useRefById({
      id: props.id,
      ref: this.node,
      deps: () => __privateGet(this, _enabled).current,
      onRefChange: (node) => {
        this.currNode = node;
      }
    });
    __privateSet(this, _behaviorType, props.interactOutsideBehavior);
    __privateSet(this, _interactOutsideProp, props.onInteractOutside);
    __privateSet(this, _onFocusOutside, props.onFocusOutside);
    user_effect(() => {
      __privateSet(this, _documentObj, getOwnerDocument(this.currNode));
    });
    let unsubEvents = noop2;
    const cleanup = () => {
      __privateGet(this, _resetState).call(this);
      globalThis.bitsDismissableLayers.delete(this);
      __privateGet(this, _handleInteractOutside).destroy();
      unsubEvents();
    };
    user_effect(() => {
      if (__privateGet(this, _enabled).current && this.currNode) {
        afterSleep(1, () => {
          if (!this.currNode) return;
          globalThis.bitsDismissableLayers.set(this, untrack(() => __privateGet(this, _behaviorType)));
          unsubEvents();
          unsubEvents = __privateMethod(this, _DismissibleLayerState_instances, addEventListeners_fn).call(this);
        });
      }
      return () => {
        cleanup();
      };
    });
    onDestroyEffect(() => {
      __privateGet(this, _resetState).destroy();
      globalThis.bitsDismissableLayers.delete(this);
      __privateGet(this, _handleInteractOutside).destroy();
      __privateGet(this, _unsubClickListener).call(this);
      unsubEvents();
    });
  }
  get currNode() {
    return get(__privateGet(this, _currNode));
  }
  set currNode(value) {
    set(__privateGet(this, _currNode), proxy(value, null, __privateGet(this, _currNode)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _currNode)), owner, false);
  }
};
_interactOutsideProp = new WeakMap();
_behaviorType = new WeakMap();
_interceptedEvents = new WeakMap();
_isResponsibleLayer = new WeakMap();
_documentObj = new WeakMap();
_enabled = new WeakMap();
_isFocusInsideDOMTree = new WeakMap();
_onFocusOutside = new WeakMap();
_currNode = new WeakMap();
_isValidEventProp = new WeakMap();
_unsubClickListener = new WeakMap();
_handleFocus = new WeakMap();
_DismissibleLayerState_instances = new WeakSet();
addEventListeners_fn = function() {
  return executeCallbacks(
    /**
    * CAPTURE INTERACTION START
    * mark interaction-start event as intercepted.
    * mark responsible layer during interaction start
    * to avoid checking if is responsible layer during interaction end
    * when a new floating element may have been opened.
    */
    addEventListener2(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markInterceptedEvent), __privateGet(this, _markResponsibleLayer)), true),
    /**
    * BUBBLE INTERACTION START
    * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
    * to avoid prematurely checking if other events were intercepted.
    */
    addEventListener2(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markNonInterceptedEvent), __privateGet(this, _handleInteractOutside))),
    /**
    * HANDLE FOCUS OUTSIDE
    */
    addEventListener2(__privateGet(this, _documentObj), "focusin", __privateGet(this, _handleFocus))
  );
};
_handleDismiss = new WeakMap();
_handleInteractOutside = new WeakMap();
_markInterceptedEvent = new WeakMap();
_markNonInterceptedEvent = new WeakMap();
_markResponsibleLayer = new WeakMap();
_isTargetWithinLayer = new WeakMap();
_resetState = new WeakMap();
isAnyEventIntercepted_fn = function() {
  const i = Object.values(__privateGet(this, _interceptedEvents)).some(Boolean);
  return i;
};
_onfocuscapture = new WeakMap();
_onblurcapture = new WeakMap();
function useDismissibleLayer(props) {
  return new DismissibleLayerState(props);
}
function getTopMostLayer(layersArr) {
  return layersArr.findLast(([_, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
}
function isResponsibleLayer(node) {
  const layersArr = [...globalThis.bitsDismissableLayers];
  const topMostLayer = getTopMostLayer(layersArr);
  if (topMostLayer) return strict_equals(topMostLayer[0].node.current, node);
  const [firstLayerNode] = layersArr[0];
  return strict_equals(firstLayerNode.node.current, node);
}
function isValidEvent(e, node) {
  if ("button" in e && e.button > 0) return false;
  const target = e.target;
  if (!isElement(target)) return false;
  const ownerDocument = getOwnerDocument(target);
  const isValid = ownerDocument.documentElement.contains(target) && !isOrContainsTarget(node, target);
  return isValid;
}
function createWrappedEvent(e) {
  const capturedCurrentTarget = e.currentTarget;
  const capturedTarget = e.target;
  let newEvent;
  if (e instanceof PointerEvent) {
    newEvent = new PointerEvent(e.type, e);
  } else {
    newEvent = new PointerEvent("pointerdown", e);
  }
  let isPrevented = false;
  const wrappedEvent = new Proxy(newEvent, {
    get: (target, prop2) => {
      if (strict_equals(prop2, "currentTarget")) {
        return capturedCurrentTarget;
      }
      if (strict_equals(prop2, "target")) {
        return capturedTarget;
      }
      if (strict_equals(prop2, "preventDefault")) {
        return () => {
          isPrevented = true;
          if (strict_equals(typeof target.preventDefault, "function")) {
            target.preventDefault();
          }
        };
      }
      if (strict_equals(prop2, "defaultPrevented")) {
        return isPrevented;
      }
      if (prop2 in target) {
        return target[prop2];
      }
      return e[prop2];
    }
  });
  return wrappedEvent;
}

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte
mark_module_start();
Dismissible_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte";
function Dismissible_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dismissible_layer);
  validate_prop_bindings($$props, [], [], Dismissible_layer);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), onFocusOutside = prop($$props, "onFocusOutside", 3, noop2), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false);
  const dismissibleLayerState = useDismissibleLayer({
    id: box.with(() => $$props.id),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    onInteractOutside: box.with(() => onInteractOutside()),
    enabled: box.with(() => $$props.enabled),
    onFocusOutside: box.with(() => onFocusOutside()),
    isValidEvent: box.with(() => isValidEvent2())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop, () => ({ props: dismissibleLayerState.props }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dismissible_layer = hmr(Dismissible_layer, () => Dismissible_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dismissible_layer[HMR].source;
    set(Dismissible_layer[HMR].source, module.default[HMR].original);
  });
}
var dismissible_layer_default = Dismissible_layer;
mark_module_end(Dismissible_layer);

// node_modules/bits-ui/dist/bits/utilities/escape-layer/useEscapeLayer.svelte.js
globalThis.bitsEscapeLayers ?? (globalThis.bitsEscapeLayers = /* @__PURE__ */ new Map());
var _onEscapeProp, _behaviorType2, _enabled2, _addEventListener, _onkeydown5;
var EscapeLayerState = class {
  constructor(props) {
    __privateAdd(this, _onEscapeProp);
    __privateAdd(this, _behaviorType2);
    __privateAdd(this, _enabled2);
    __privateAdd(this, _addEventListener, () => {
      return addEventListener2(document, "keydown", __privateGet(this, _onkeydown5), { passive: false });
    });
    __privateAdd(this, _onkeydown5, (e) => {
      if (strict_equals(e.key, kbd_constants_exports.ESCAPE, false) || !isResponsibleEscapeLayer(this)) return;
      const clonedEvent = new KeyboardEvent(e.type, e);
      e.preventDefault();
      const behaviorType = __privateGet(this, _behaviorType2).current;
      if (strict_equals(behaviorType, "close", false) && strict_equals(behaviorType, "defer-otherwise-close", false)) return;
      __privateGet(this, _onEscapeProp).current(clonedEvent);
    });
    __privateSet(this, _behaviorType2, props.escapeKeydownBehavior);
    __privateSet(this, _onEscapeProp, props.onEscapeKeydown);
    __privateSet(this, _enabled2, props.enabled);
    let unsubEvents = noop2;
    user_effect(() => {
      if (__privateGet(this, _enabled2).current) {
        globalThis.bitsEscapeLayers.set(this, untrack(() => __privateGet(this, _behaviorType2)));
        unsubEvents = __privateGet(this, _addEventListener).call(this);
      }
      return () => {
        unsubEvents();
        globalThis.bitsEscapeLayers.delete(this);
      };
    });
  }
};
_onEscapeProp = new WeakMap();
_behaviorType2 = new WeakMap();
_enabled2 = new WeakMap();
_addEventListener = new WeakMap();
_onkeydown5 = new WeakMap();
function useEscapeLayer(props) {
  return new EscapeLayerState(props);
}
function isResponsibleEscapeLayer(instance) {
  const layersArr = [...globalThis.bitsEscapeLayers];
  const topMostLayer = layersArr.findLast(([_, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
  if (topMostLayer) return strict_equals(topMostLayer[0], instance);
  const [firstLayerNode] = layersArr[0];
  return strict_equals(firstLayerNode, instance);
}

// node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte
mark_module_start();
Escape_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte";
function Escape_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Escape_layer);
  validate_prop_bindings($$props, [], [], Escape_layer);
  let escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2);
  useEscapeLayer({
    escapeKeydownBehavior: box.with(() => escapeKeydownBehavior()),
    onEscapeKeydown: box.with(() => onEscapeKeydown()),
    enabled: box.with(() => $$props.enabled)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Escape_layer = hmr(Escape_layer, () => Escape_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Escape_layer[HMR].source;
    set(Escape_layer[HMR].source, module.default[HMR].original);
  });
}
var escape_layer_default = Escape_layer;
mark_module_end(Escape_layer);

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope-stack.svelte.js
var focusStack = box([]);
function createFocusScopeStack() {
  const stack = focusStack;
  return {
    add(focusScope) {
      const activeFocusScope = stack.current[0];
      if (strict_equals(focusScope.id, activeFocusScope == null ? void 0 : activeFocusScope.id, false)) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack.current = removeFromFocusScopeArray(stack.current, focusScope);
      stack.current.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack.current = removeFromFocusScopeArray(stack.current, focusScope);
      (_a = stack.current[0]) == null ? void 0 : _a.resume();
    }
  };
}
function createFocusScopeAPI() {
  let paused = state(false);
  return {
    id: useId(),
    get paused() {
      return get(paused);
    },
    pause() {
      set(paused, true);
    },
    resume() {
      set(paused, false);
    }
  };
}
function removeFromFocusScopeArray(arr, item) {
  return [...arr].filter((i) => strict_equals(i.id, item.id, false));
}
function removeLinks(items) {
  return items.filter((item) => strict_equals(item.tagName, "A", false));
}

// node_modules/bits-ui/dist/internal/focus.js
function focus(element2, { select = false } = {}) {
  if (!(element2 && element2.focus))
    return;
  const previouslyFocusedElement = document.activeElement;
  element2.focus({ preventScroll: true });
  if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select) {
    element2.select();
  }
}
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) {
      return true;
    }
  }
}
function findVisible(elements, container) {
  for (const element2 of elements) {
    if (!isElementHidden(element2, container))
      return element2;
  }
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    // eslint-disable-next-line ts/no-explicit-any
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}

// node_modules/bits-ui/dist/bits/utilities/focus-scope/useFocusScope.svelte.js
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_DESTROY = "focusScope.autoFocusOnDestroy";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
function useFocusScope({
  id,
  loop,
  enabled,
  onOpenAutoFocus,
  onCloseAutoFocus,
  forceMount
}) {
  const focusScopeStack = createFocusScopeStack();
  const focusScope = createFocusScopeAPI();
  const ref = box(null);
  useRefById({ id, ref, deps: () => enabled.current });
  let lastFocusedElement = state(null);
  user_effect(() => {
    const container = ref.current;
    if (!container) return;
    if (!enabled.current) return;
    function handleFocusIn(event) {
      if (focusScope.paused || !container) return;
      const target = event.target;
      if (!isHTMLElement(target)) return;
      if (container.contains(target)) {
        set(lastFocusedElement, proxy(target, null, lastFocusedElement));
      } else {
        focus(get(lastFocusedElement), { select: true });
      }
    }
    function handleFocusOut(event) {
      if (focusScope.paused || !container) return;
      const relatedTarget = event.relatedTarget;
      if (!isHTMLElement(relatedTarget)) return;
      if (strict_equals(relatedTarget, null)) return;
      if (!container.contains(relatedTarget)) focus(get(lastFocusedElement), { select: true });
    }
    function handleMutations(_) {
      const lastFocusedElementExists = container == null ? void 0 : container.contains(get(lastFocusedElement));
      if (!lastFocusedElementExists) {
        focus(container);
      }
    }
    return untrack(() => {
      const unsubEvents = executeCallbacks(addEventListener2(document, "focusin", handleFocusIn), addEventListener2(document, "focusout", handleFocusOut));
      const mutationObserver = new MutationObserver(handleMutations);
      mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        unsubEvents();
        mutationObserver.disconnect();
      };
    });
  });
  user_effect(() => {
    if (forceMount.current) return;
    let container = ref.current;
    const previouslyFocusedElement = document.activeElement;
    untrack(() => {
      handleMount(container, previouslyFocusedElement);
    });
    return () => {
      if (!container) return;
      handleDestroy(previouslyFocusedElement);
    };
  });
  user_effect(() => {
    if (!forceMount.current) return;
    enabled.current;
    const container = ref.current;
    const previouslyFocusedElement = document.activeElement;
    untrack(() => {
      handleMount(container, previouslyFocusedElement);
    });
    return () => {
      if (!container) return;
      handleDestroy(previouslyFocusedElement);
    };
  });
  function handleMount(container, prevFocusedElement) {
    if (!container) container = document.getElementById(id.current);
    if (!container) return;
    focusScopeStack.add(focusScope);
    const hasFocusedCandidate = container.contains(prevFocusedElement);
    if (!hasFocusedCandidate) {
      const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
      onOpenAutoFocus.current(mountEvent);
      if (!mountEvent.defaultPrevented) {
        afterTick(() => {
          if (!container) return;
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (strict_equals(document.activeElement, prevFocusedElement)) {
            focus(container);
          }
        });
      }
    }
  }
  function handleDestroy(prevFocusedElement) {
    const destroyEvent = new CustomEvent(AUTOFOCUS_ON_DESTROY, EVENT_OPTIONS);
    onCloseAutoFocus.current(destroyEvent);
    setTimeout(
      () => {
        if (!destroyEvent.defaultPrevented && prevFocusedElement) {
          focus(prevFocusedElement ?? document.body, { select: true });
        }
        focusScopeStack.remove(focusScope);
      },
      0
    );
  }
  function handleKeydown(e) {
    if (!enabled.current) return;
    if (!loop.current && !enabled.current) return;
    if (focusScope.paused) return;
    const isTabKey = strict_equals(e.key, kbd_constants_exports.TAB) && !e.ctrlKey && !e.altKey && !e.metaKey;
    const focusedElement = document.activeElement;
    if (!(isTabKey && focusedElement)) return;
    const container = ref.current;
    if (!container) return;
    const [first, last] = getTabbableEdges(container);
    const hasTabbableElementsInside = first && last;
    if (!hasTabbableElementsInside) {
      if (strict_equals(focusedElement, container)) {
        e.preventDefault();
      }
    } else {
      if (!e.shiftKey && strict_equals(focusedElement, last)) {
        e.preventDefault();
        if (loop.current) focus(first, { select: true });
      } else if (e.shiftKey && strict_equals(focusedElement, first)) {
        e.preventDefault();
        if (loop.current) focus(last, { select: true });
      }
    }
  }
  const props = derived(() => ({
    id: id.current,
    tabindex: -1,
    onkeydown: handleKeydown
  }));
  return {
    get props() {
      return get(props);
    }
  };
}

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte
mark_module_start();
Focus_scope[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte";
function Focus_scope($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Focus_scope);
  validate_prop_bindings($$props, [], [], Focus_scope);
  let trapFocus = prop($$props, "trapFocus", 3, false), loop = prop($$props, "loop", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop2), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop2), forceMount = prop($$props, "forceMount", 3, false);
  const focusScopeState = useFocusScope({
    enabled: box.with(() => trapFocus()),
    loop: box.with(() => loop()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus()),
    id: box.with(() => $$props.id),
    forceMount: box.with(() => forceMount())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.focusScope ?? noop, () => ({ props: focusScopeState.props }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Focus_scope = hmr(Focus_scope, () => Focus_scope[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Focus_scope[HMR].source;
    set(Focus_scope[HMR].source, module.default[HMR].original);
  });
}
var focus_scope_default = Focus_scope;
mark_module_end(Focus_scope);

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/useTextSelectionLayer.svelte.js
globalThis.bitsTextSelectionLayers ?? (globalThis.bitsTextSelectionLayers = /* @__PURE__ */ new Map());
var _id14, _onPointerDownProp, _onPointerUpProp, _enabled3, _unsubSelectionLock, _ref14, _TextSelectionLayerState_instances, addEventListeners_fn2, _pointerdown, _resetSelectionLock;
var TextSelectionLayerState = class {
  constructor(props) {
    __privateAdd(this, _TextSelectionLayerState_instances);
    __privateAdd(this, _id14);
    __privateAdd(this, _onPointerDownProp);
    __privateAdd(this, _onPointerUpProp);
    __privateAdd(this, _enabled3);
    __privateAdd(this, _unsubSelectionLock, noop2);
    __privateAdd(this, _ref14, box(null));
    __privateAdd(this, _pointerdown, (e) => {
      const node = __privateGet(this, _ref14).current;
      const target = e.target;
      if (!isHTMLElement(node) || !isHTMLElement(target) || !__privateGet(this, _enabled3).current) return;
      if (!isHighestLayer(this) || !isOrContainsTarget(node, target)) return;
      __privateGet(this, _onPointerDownProp).current(e);
      if (e.defaultPrevented) return;
      __privateSet(this, _unsubSelectionLock, preventTextSelectionOverflow(node));
    });
    __privateAdd(this, _resetSelectionLock, () => {
      __privateGet(this, _unsubSelectionLock).call(this);
      __privateSet(this, _unsubSelectionLock, noop2);
    });
    __privateSet(this, _id14, props.id);
    __privateSet(this, _enabled3, props.preventOverflowTextSelection);
    __privateSet(this, _onPointerDownProp, props.onPointerDown);
    __privateSet(this, _onPointerUpProp, props.onPointerUp);
    useRefById({
      id: __privateGet(this, _id14),
      ref: __privateGet(this, _ref14),
      deps: () => __privateGet(this, _enabled3).current
    });
    let unsubEvents = noop2;
    user_effect(() => {
      if (__privateGet(this, _enabled3).current) {
        globalThis.bitsTextSelectionLayers.set(this, untrack(() => __privateGet(this, _enabled3)));
        unsubEvents = __privateMethod(this, _TextSelectionLayerState_instances, addEventListeners_fn2).call(this);
      }
      return () => {
        unsubEvents();
        __privateGet(this, _resetSelectionLock).call(this);
        globalThis.bitsTextSelectionLayers.delete(this);
      };
    });
  }
};
_id14 = new WeakMap();
_onPointerDownProp = new WeakMap();
_onPointerUpProp = new WeakMap();
_enabled3 = new WeakMap();
_unsubSelectionLock = new WeakMap();
_ref14 = new WeakMap();
_TextSelectionLayerState_instances = new WeakSet();
addEventListeners_fn2 = function() {
  return executeCallbacks(addEventListener2(document, "pointerdown", __privateGet(this, _pointerdown)), addEventListener2(document, "pointerup", composeHandlers(__privateGet(this, _resetSelectionLock), __privateGet(this, _onPointerUpProp))));
};
_pointerdown = new WeakMap();
_resetSelectionLock = new WeakMap();
function useTextSelectionLayer(props) {
  return new TextSelectionLayerState(props);
}
var getUserSelect = (node) => node.style.userSelect || node.style.webkitUserSelect;
function preventTextSelectionOverflow(node) {
  const body = document.body;
  const originalBodyUserSelect = getUserSelect(body);
  const originalNodeUserSelect = getUserSelect(node);
  setUserSelect(body, "none");
  setUserSelect(node, "text");
  return () => {
    setUserSelect(body, originalBodyUserSelect);
    setUserSelect(node, originalNodeUserSelect);
  };
}
function setUserSelect(node, value) {
  node.style.userSelect = value;
  node.style.webkitUserSelect = value;
}
function isHighestLayer(instance) {
  const layersArr = [...globalThis.bitsTextSelectionLayers];
  if (!layersArr.length) return false;
  const highestLayer = layersArr.at(-1);
  if (!highestLayer) return false;
  return strict_equals(highestLayer[0], instance);
}

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte
mark_module_start();
Text_selection_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte";
function Text_selection_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text_selection_layer);
  validate_prop_bindings($$props, [], [], Text_selection_layer);
  let preventOverflowTextSelection = prop($$props, "preventOverflowTextSelection", 3, true), onPointerDown = prop($$props, "onPointerDown", 3, noop2), onPointerUp = prop($$props, "onPointerUp", 3, noop2);
  useTextSelectionLayer({
    id: box.with(() => $$props.id),
    preventOverflowTextSelection: box.with(() => preventOverflowTextSelection()),
    onPointerDown: box.with(() => onPointerDown()),
    onPointerUp: box.with(() => onPointerUp()),
    enabled: box.with(() => $$props.enabled)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text_selection_layer = hmr(Text_selection_layer, () => Text_selection_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text_selection_layer[HMR].source;
    set(Text_selection_layer[HMR].source, module.default[HMR].original);
  });
}
var text_selection_layer_default = Text_selection_layer;
mark_module_end(Text_selection_layer);

// node_modules/bits-ui/dist/internal/create-shared-hook.svelte.js
function createSharedHook(factory) {
  let subscribers = 0;
  let state2 = state(void 0);
  let scope;
  function dispose() {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope();
      set(state2, void 0);
      scope = void 0;
    }
  }
  return (...args) => {
    subscribers += 1;
    if (strict_equals(get(state2), void 0)) {
      scope = effect_root(() => {
        set(state2, proxy(factory(...args), null, state2));
      });
    }
    user_effect(() => {
      return () => {
        dispose();
      };
    });
    return get(state2);
  };
}

// node_modules/bits-ui/dist/internal/use-body-scroll-lock.svelte.js
var useBodyLockStackCount = createSharedHook(() => {
  const map = new SvelteMap();
  const locked = derived(() => {
    for (const value of map.values()) {
      if (value) {
        return true;
      }
    }
    return false;
  });
  let initialBodyStyle = proxy({});
  let stopTouchMoveListener = null;
  function resetBodyStyle() {
    if (!isBrowser) return;
    document.body.style.paddingRight = initialBodyStyle.paddingRight ?? "";
    document.body.style.marginRight = initialBodyStyle.marginRight ?? "";
    document.body.style.pointerEvents = initialBodyStyle.pointerEvents ?? "";
    document.body.style.removeProperty("--scrollbar-width");
    document.body.style.overflow = initialBodyStyle.overflow ?? "";
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
  }
  user_effect(() => {
    const curr = get(locked);
    return untrack(() => {
      if (!curr) {
        return;
      }
      const bodyStyle = getComputedStyle(document.body);
      initialBodyStyle.overflow = bodyStyle.overflow;
      initialBodyStyle.paddingRight = bodyStyle.paddingRight;
      initialBodyStyle.marginRight = bodyStyle.marginRight;
      initialBodyStyle.pointerEvents = bodyStyle.pointerEvents;
      const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      const paddingRight = Number.parseInt(initialBodyStyle.paddingRight ?? "0", 10);
      const config = {
        padding: paddingRight + verticalScrollbarWidth,
        margin: Number.parseInt(initialBodyStyle.marginRight ?? "0", 10)
      };
      if (verticalScrollbarWidth > 0) {
        document.body.style.paddingRight = `${config.padding}px`;
        document.body.style.marginRight = `${config.margin}px`;
        document.body.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
        document.body.style.overflow = "hidden";
      }
      if (isIOS) {
        stopTouchMoveListener = addEventListener2(
          document,
          "touchmove",
          (e) => {
            if (strict_equals(e.target, document.documentElement, false)) return;
            if (e.touches.length > 1) return;
            e.preventDefault();
          },
          { passive: false }
        );
      }
      afterTick(() => {
        document.body.style.pointerEvents = "none";
        document.body.style.overflow = "hidden";
      });
    });
  });
  user_effect(() => {
    return () => {
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    };
  });
  return {
    get map() {
      return map;
    },
    resetBodyStyle
  };
});
function useBodyScrollLock(initialState, restoreScrollDelay = () => null) {
  const id = useId();
  const countState = useBodyLockStackCount();
  const _restoreScrollDelay = derived(restoreScrollDelay);
  countState.map.set(id, initialState ?? false);
  const locked = box.with(() => countState.map.get(id) ?? false, (v) => countState.map.set(id, v));
  user_effect(() => {
    return () => {
      countState.map.delete(id);
      if (isAnyLocked(countState.map)) return;
      if (strict_equals(get(_restoreScrollDelay), null)) {
        requestAnimationFrame(() => countState.resetBodyStyle());
      } else {
        afterSleep(get(_restoreScrollDelay), () => countState.resetBodyStyle());
      }
    };
  });
  return locked;
}
function isAnyLocked(map) {
  for (const [_, value] of map) {
    if (value) return true;
  }
  return false;
}

// node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte
mark_module_start();
Scroll_lock[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte";
function Scroll_lock($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_lock);
  validate_prop_bindings($$props, [], [], Scroll_lock);
  let preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null);
  useBodyScrollLock(preventScroll(), () => restoreScrollDelay());
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_lock = hmr(Scroll_lock, () => Scroll_lock[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_lock[HMR].source;
    set(Scroll_lock[HMR].source, module.default[HMR].original);
  });
}
var scroll_lock_default = Scroll_lock;
mark_module_end(Scroll_lock);

// node_modules/bits-ui/dist/internal/should-trap-focus.js
function shouldTrapFocus({ forceMount, present, trapFocus, open }) {
  if (forceMount) {
    return open && trapFocus;
  }
  return present && trapFocus && open;
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte
mark_module_start();
Alert_dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte";
var root_6 = add_locations(template(`<!> <!>`, 1), Alert_dialog_content[FILENAME], []);
var root_8 = add_locations(template(`<!> <div><!></div>`, 1), Alert_dialog_content[FILENAME], [[97, 8]]);
function Alert_dialog_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Alert_dialog_content);
  validate_prop_bindings($$props, ["ref"], [], Alert_dialog_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "ignore"), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop2), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), preventScroll = prop($$props, "preventScroll", 3, true), trapFocus = prop($$props, "trapFocus", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "forceMount",
      "interactOutsideBehavior",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onOpenAutoFocus",
      "onInteractOutside",
      "preventScroll",
      "trapFocus",
      "restoreScrollDelay"
    ],
    "restProps"
  );
  const contentState = useDialogContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  var present_1 = derived(() => contentState.root.open.current || forceMount());
  {
    const presence = wrap_snippet(Alert_dialog_content, ($$anchor2, $$arg0) => {
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var trapFocus_1 = derived(() => shouldTrapFocus({
        forceMount: forceMount(),
        present: present().current,
        trapFocus: trapFocus(),
        open: contentState.root.open.current
      }));
      {
        const focusScope = wrap_snippet(Alert_dialog_content, ($$anchor3, $$arg02) => {
          let focusScopeProps = () => $$arg02 == null ? void 0 : $$arg02().props;
          focusScopeProps();
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          escape_layer_default(node_2, spread_props(() => get(mergedProps), {
            get enabled() {
              return present().current;
            },
            onEscapeKeydown: (e) => {
              onEscapeKeydown()(e);
              if (e.defaultPrevented) return;
              contentState.root.handleClose();
            },
            children: wrap_snippet(Alert_dialog_content, ($$anchor4, $$slotProps) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              dismissible_layer_default(node_3, spread_props(() => get(mergedProps), {
                get enabled() {
                  return present().current;
                },
                get interactOutsideBehavior() {
                  return interactOutsideBehavior();
                },
                onInteractOutside: (e) => {
                  onInteractOutside()(e);
                  if (e.defaultPrevented) return;
                  contentState.root.handleClose();
                },
                children: wrap_snippet(Alert_dialog_content, ($$anchor5, $$slotProps2) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  text_selection_layer_default(node_4, spread_props(() => get(mergedProps), {
                    get enabled() {
                      return present().current;
                    },
                    children: wrap_snippet(Alert_dialog_content, ($$anchor6, $$slotProps3) => {
                      var fragment_5 = comment();
                      var node_5 = first_child(fragment_5);
                      if_block(
                        node_5,
                        () => $$props.child,
                        ($$anchor7) => {
                          var fragment_6 = root_6();
                          var node_6 = first_child(fragment_6);
                          if_block(node_6, () => contentState.root.open.current, ($$anchor8) => {
                            var fragment_7 = comment();
                            var node_7 = first_child(fragment_7);
                            scroll_lock_default(node_7, {
                              get preventScroll() {
                                return preventScroll();
                              },
                              get restoreScrollDelay() {
                                return restoreScrollDelay();
                              }
                            });
                            append($$anchor8, fragment_7);
                          });
                          var node_8 = sibling(node_6, 2);
                          var render_arg = derived_safe_equal(() => ({
                            props: mergeProps(get(mergedProps), focusScopeProps()),
                            ...contentState.snippetProps
                          }));
                          snippet(node_8, () => $$props.child, () => get(render_arg));
                          append($$anchor7, fragment_6);
                        },
                        ($$anchor7) => {
                          var fragment_8 = root_8();
                          var node_9 = first_child(fragment_8);
                          scroll_lock_default(node_9, {
                            get preventScroll() {
                              return preventScroll();
                            }
                          });
                          var div = sibling(node_9, 2);
                          const spread_with_call = derived(() => mergeProps(get(mergedProps), focusScopeProps()));
                          let attributes;
                          var node_10 = child(div);
                          snippet(node_10, () => $$props.children ?? noop);
                          reset(div);
                          template_effect(() => attributes = set_attributes(div, attributes, { ...get(spread_with_call) }));
                          append($$anchor7, fragment_8);
                        }
                      );
                      append($$anchor6, fragment_5);
                    }),
                    $$slots: { default: true }
                  }));
                  append($$anchor5, fragment_4);
                }),
                $$slots: { default: true }
              }));
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          }));
          append($$anchor3, fragment_2);
        });
        focus_scope_default(node_1, spread_props(
          {
            loop: true,
            get trapFocus() {
              return get(trapFocus_1);
            }
          },
          () => get(mergedProps),
          {
            onCloseAutoFocus: (e) => {
              var _a;
              onCloseAutoFocus()(e);
              if (e.defaultPrevented) return;
              (_a = contentState.root.triggerNode) == null ? void 0 : _a.focus();
            },
            onOpenAutoFocus: (e) => {
              var _a;
              onOpenAutoFocus()(e);
              if (e.defaultPrevented) return;
              e.preventDefault();
              (_a = contentState.root.cancelNode) == null ? void 0 : _a.focus();
            },
            focusScope,
            $$slots: { focusScope: true }
          }
        ));
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(() => get(mergedProps), {
      get forceMount() {
        return forceMount();
      },
      get present() {
        return get(present_1);
      },
      presence,
      $$slots: { presence: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_content = hmr(Alert_dialog_content, () => Alert_dialog_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_content[HMR].source;
    set(Alert_dialog_content[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_content_default = Alert_dialog_content;
mark_module_end(Alert_dialog_content);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte
mark_module_start();
Dialog_overlay[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte";
var root_32 = add_locations(template(`<div><!></div>`), Dialog_overlay[FILENAME], [[33, 3]]);
function Dialog_overlay($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog_overlay);
  validate_prop_bindings($$props, ["ref"], [], Dialog_overlay);
  let id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "forceMount",
      "child",
      "children",
      "ref"
    ],
    "restProps"
  );
  const overlayState = useDialogOverlay({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, overlayState.props));
  var fragment = comment();
  var node = first_child(fragment);
  var present = derived(() => overlayState.root.open.current || forceMount());
  {
    const presence = wrap_snippet(Dialog_overlay, ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          var render_arg = derived_safe_equal(() => ({
            props: mergeProps(get(mergedProps)),
            ...overlayState.snippetProps
          }));
          snippet(node_2, () => $$props.child, () => get(render_arg));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var div = root_32();
          const spread_with_call = derived(() => mergeProps(get(mergedProps)));
          let attributes;
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop, () => overlayState.snippetProps);
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get(spread_with_call) }));
          append($$anchor3, div);
        }
      );
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get id() {
        return id();
      },
      get present() {
        return get(present);
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_overlay = hmr(Dialog_overlay, () => Dialog_overlay[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_overlay[HMR].source;
    set(Dialog_overlay[HMR].source, module.default[HMR].original);
  });
}
var dialog_overlay_default = Dialog_overlay;
mark_module_end(Dialog_overlay);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte
mark_module_start();
Dialog_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte";
var root_28 = add_locations(template(`<button><!></button>`), Dialog_trigger[FILENAME], [[31, 1]]);
function Dialog_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog_trigger);
  validate_prop_bindings($$props, ["ref"], [], Dialog_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = useDialogTrigger({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_28();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_trigger = hmr(Dialog_trigger, () => Dialog_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_trigger[HMR].source;
    set(Dialog_trigger[HMR].source, module.default[HMR].original);
  });
}
var dialog_trigger_default = Dialog_trigger;
mark_module_end(Dialog_trigger);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte
mark_module_start();
Dialog_description[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte";
var root_29 = add_locations(template(`<div><!></div>`), Dialog_description[FILENAME], [[29, 1]]);
function Dialog_description($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog_description);
  validate_prop_bindings($$props, ["ref"], [], Dialog_description);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const descriptionState = useDialogDescription({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, descriptionState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_29();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_description = hmr(Dialog_description, () => Dialog_description[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_description[HMR].source;
    set(Dialog_description[HMR].source, module.default[HMR].original);
  });
}
var dialog_description_default = Dialog_description;
mark_module_end(Dialog_description);

// node_modules/bits-ui/dist/bits/aspect-ratio/exports.js
var exports_exports3 = {};
__export(exports_exports3, {
  Root: () => aspect_ratio_default
});

// node_modules/bits-ui/dist/bits/aspect-ratio/aspect-ratio.svelte.js
var ASPECT_RATIO_ROOT_ATTR = "data-aspect-ratio-root";
var _ref15, _id15, _ratio, _wrapperProps, _props14;
var AspectRatioRootState = class {
  constructor(props) {
    __privateAdd(this, _ref15);
    __privateAdd(this, _id15);
    __privateAdd(this, _ratio);
    __privateAdd(this, _wrapperProps, derived(() => ({
      style: {
        position: "relative",
        width: "100%",
        paddingBottom: `${__privateGet(this, _ratio).current ? 100 / __privateGet(this, _ratio).current : 0}%}`
      }
    })));
    __privateAdd(this, _props14, derived(() => ({
      id: __privateGet(this, _id15).current,
      style: {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      [ASPECT_RATIO_ROOT_ATTR]: ""
    })));
    __privateSet(this, _ref15, props.ref);
    __privateSet(this, _id15, props.id);
    __privateSet(this, _ratio, props.ratio);
    useRefById({ id: __privateGet(this, _id15), ref: __privateGet(this, _ref15) });
  }
  get wrapperProps() {
    return get(__privateGet(this, _wrapperProps));
  }
  set wrapperProps(_) {
    throw new Error("Cannot update a derived property ('wrapperProps')");
  }
  get props() {
    return get(__privateGet(this, _props14));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _wrapperProps)), owner, false);
    add_owner(get(__privateGet(this, _props14)), owner, false);
  }
};
_ref15 = new WeakMap();
_id15 = new WeakMap();
_ratio = new WeakMap();
_wrapperProps = new WeakMap();
_props14 = new WeakMap();
function useAspectRatioRoot(props) {
  return new AspectRatioRootState(props);
}

// node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte
mark_module_start();
Aspect_ratio[FILENAME] = "node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte";
var root_210 = add_locations(template(`<div><!></div>`), Aspect_ratio[FILENAME], [[32, 2]]);
var root = add_locations(template(`<div><!></div>`), Aspect_ratio[FILENAME], [[28, 0]]);
function Aspect_ratio($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Aspect_ratio);
  validate_prop_bindings($$props, ["ref"], [], Aspect_ratio);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), ratio = prop($$props, "ratio", 3, 1), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "ratio",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = useAspectRatioRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    ratio: box.with(() => ratio())
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var div = root();
  set_style(div, "position", "relative");
  set_style(div, "width", "100%");
  var node = child(div);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment);
    },
    ($$anchor2) => {
      var div_1 = root_210();
      let attributes;
      var node_2 = child(div_1);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div_1);
      template_effect(() => attributes = set_attributes(div_1, attributes, { ...get(mergedProps) }));
      append($$anchor2, div_1);
    }
  );
  reset(div);
  template_effect(() => set_style(div, "padding-bottom", `${(ratio() ? 100 / ratio() : 0) ?? ""}%`));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Aspect_ratio = hmr(Aspect_ratio, () => Aspect_ratio[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Aspect_ratio[HMR].source;
    set(Aspect_ratio[HMR].source, module.default[HMR].original);
  });
}
var aspect_ratio_default = Aspect_ratio;
mark_module_end(Aspect_ratio);

// node_modules/bits-ui/dist/bits/avatar/exports.js
var exports_exports4 = {};
__export(exports_exports4, {
  Fallback: () => avatar_fallback_default,
  Image: () => avatar_image_default,
  Root: () => avatar_default
});

// node_modules/bits-ui/dist/bits/avatar/avatar.svelte.js
var AVATAR_ROOT_ATTR = "data-avatar-root";
var AVATAR_IMAGE_ATTR = "data-avatar-image";
var AVATAR_FALLBACK_ATTR = "data-avatar-fallback";
var _id16, _ref16, _props15;
var AvatarRootState = class {
  constructor(props) {
    __privateAdd(this, _id16);
    __privateAdd(this, _ref16);
    __publicField(this, "delayMs");
    __publicField(this, "loadingStatus");
    __publicField(this, "loadImage", (src, crossorigin, referrerPolicy) => {
      let imageTimerId;
      const image = new Image();
      image.src = src;
      if (strict_equals(crossorigin, void 0, false)) image.crossOrigin = crossorigin;
      if (referrerPolicy) image.referrerPolicy = referrerPolicy;
      this.loadingStatus.current = "loading";
      image.onload = () => {
        imageTimerId = window.setTimeout(
          () => {
            this.loadingStatus.current = "loaded";
          },
          this.delayMs.current
        );
      };
      image.onerror = () => {
        this.loadingStatus.current = "error";
      };
      return () => {
        window.clearTimeout(imageTimerId);
      };
    });
    __privateAdd(this, _props15, derived(() => ({
      id: __privateGet(this, _id16).current,
      [AVATAR_ROOT_ATTR]: "",
      "data-status": this.loadingStatus.current
    })));
    this.delayMs = props.delayMs;
    this.loadingStatus = props.loadingStatus;
    __privateSet(this, _ref16, props.ref);
    __privateSet(this, _id16, props.id);
    useRefById({ id: __privateGet(this, _id16), ref: __privateGet(this, _ref16) });
  }
  get props() {
    return get(__privateGet(this, _props15));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props15)), owner, false);
  }
};
_id16 = new WeakMap();
_ref16 = new WeakMap();
_props15 = new WeakMap();
var _id17, _ref17, _crossOrigin, _referrerPolicy, _src, _root8, _props16;
var AvatarImageState = class {
  constructor(props, root17) {
    __privateAdd(this, _id17);
    __privateAdd(this, _ref17);
    __privateAdd(this, _crossOrigin);
    __privateAdd(this, _referrerPolicy);
    __privateAdd(this, _src);
    __privateAdd(this, _root8);
    __privateAdd(this, _props16, derived(() => ({
      id: __privateGet(this, _id17).current,
      style: {
        display: strict_equals(__privateGet(this, _root8).loadingStatus.current, "loaded") ? "block" : "none"
      },
      "data-status": __privateGet(this, _root8).loadingStatus.current,
      [AVATAR_IMAGE_ATTR]: "",
      src: __privateGet(this, _src).current,
      crossorigin: __privateGet(this, _crossOrigin).current,
      referrerpolicy: __privateGet(this, _referrerPolicy).current
    })));
    __privateSet(this, _root8, root17);
    __privateSet(this, _src, props.src);
    __privateSet(this, _id17, props.id);
    __privateSet(this, _ref17, props.ref);
    __privateSet(this, _crossOrigin, props.crossOrigin);
    __privateSet(this, _referrerPolicy, props.referrerPolicy);
    useRefById({ id: __privateGet(this, _id17), ref: __privateGet(this, _ref17) });
    user_pre_effect(() => {
      if (!__privateGet(this, _src).current) {
        __privateGet(this, _root8).loadingStatus.current = "error";
        return;
      }
      __privateGet(this, _crossOrigin).current;
      untrack(() => __privateGet(this, _root8).loadImage(__privateGet(this, _src).current ?? "", __privateGet(this, _crossOrigin).current, __privateGet(this, _referrerPolicy).current));
    });
  }
  get props() {
    return get(__privateGet(this, _props16));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props16)), owner, false);
  }
};
_id17 = new WeakMap();
_ref17 = new WeakMap();
_crossOrigin = new WeakMap();
_referrerPolicy = new WeakMap();
_src = new WeakMap();
_root8 = new WeakMap();
_props16 = new WeakMap();
var _id18, _ref18, _root9, _props17;
var AvatarFallbackState = class {
  constructor(props, root17) {
    __privateAdd(this, _id18);
    __privateAdd(this, _ref18);
    __privateAdd(this, _root9);
    __privateAdd(this, _props17, derived(() => ({
      style: {
        display: strict_equals(__privateGet(this, _root9).loadingStatus.current, "loaded") ? "none" : void 0
      },
      "data-status": __privateGet(this, _root9).loadingStatus.current,
      [AVATAR_FALLBACK_ATTR]: ""
    })));
    __privateSet(this, _root9, root17);
    __privateSet(this, _id18, props.id);
    __privateSet(this, _ref18, props.ref);
    useRefById({ id: __privateGet(this, _id18), ref: __privateGet(this, _ref18) });
  }
  get props() {
    return get(__privateGet(this, _props17));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props17)), owner, false);
  }
};
_id18 = new WeakMap();
_ref18 = new WeakMap();
_root9 = new WeakMap();
_props17 = new WeakMap();
var [setAvatarRootContext, getAvatarRootContext] = createContext("Avatar.Root");
function useAvatarRoot(props) {
  return setAvatarRootContext(new AvatarRootState(props));
}
function useAvatarImage(props) {
  const root17 = getAvatarRootContext();
  return new AvatarImageState(props, root17);
}
function useAvatarFallback(props) {
  const root17 = getAvatarRootContext();
  return new AvatarFallbackState(props, root17);
}

// node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte
mark_module_start();
Avatar[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte";
var root_211 = add_locations(template(`<div><!></div>`), Avatar[FILENAME], [[42, 1]]);
function Avatar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Avatar);
  validate_prop_bindings($$props, ["loadingStatus", "ref"], [], Avatar);
  let delayMs = prop($$props, "delayMs", 3, 0), loadingStatus = prop($$props, "loadingStatus", 15, "loading"), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "delayMs",
      "loadingStatus",
      "onLoadingStatusChange",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = useAvatarRoot({
    delayMs: box.with(() => delayMs()),
    loadingStatus: box.with(() => loadingStatus(), (v) => {
      var _a;
      if (strict_equals(loadingStatus(), v, false)) {
        loadingStatus(v);
        (_a = $$props.onLoadingStatusChange) == null ? void 0 : _a.call($$props, v);
      }
    }),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_211();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar = hmr(Avatar, () => Avatar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar[HMR].source;
    set(Avatar[HMR].source, module.default[HMR].original);
  });
}
var avatar_default = Avatar;
mark_module_end(Avatar);

// node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte
mark_module_start();
Avatar_image[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte";
var root_212 = add_locations(template(`<img>`), Avatar_image[FILENAME], [[34, 1]]);
function Avatar_image($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Avatar_image);
  validate_prop_bindings($$props, ["ref"], [], Avatar_image);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), crossorigin = prop($$props, "crossorigin", 3, void 0), referrerpolicy = prop($$props, "referrerpolicy", 3, void 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "child",
      "id",
      "ref",
      "crossorigin",
      "referrerpolicy"
    ],
    "restProps"
  );
  const imageState = useAvatarImage({
    src: box.with(() => $$props.src),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    crossOrigin: box.with(() => crossorigin()),
    referrerPolicy: box.with(() => referrerpolicy())
  });
  const mergedProps = derived(() => mergeProps(restProps, imageState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var img = root_212();
      let attributes;
      template_effect(() => attributes = set_attributes(img, attributes, { ...get(mergedProps), src: $$props.src }));
      handle_lazy_img(img);
      replay_events(img);
      append($$anchor2, img);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar_image = hmr(Avatar_image, () => Avatar_image[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar_image[HMR].source;
    set(Avatar_image[HMR].source, module.default[HMR].original);
  });
}
var avatar_image_default = Avatar_image;
mark_module_end(Avatar_image);

// node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte
mark_module_start();
Avatar_fallback[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte";
var root_213 = add_locations(template(`<span><!></span>`), Avatar_fallback[FILENAME], [[29, 1]]);
function Avatar_fallback($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Avatar_fallback);
  validate_prop_bindings($$props, ["ref"], [], Avatar_fallback);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const fallbackState = useAvatarFallback({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, fallbackState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_213();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar_fallback = hmr(Avatar_fallback, () => Avatar_fallback[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar_fallback[HMR].source;
    set(Avatar_fallback[HMR].source, module.default[HMR].original);
  });
}
var avatar_fallback_default = Avatar_fallback;
mark_module_end(Avatar_fallback);

// node_modules/bits-ui/dist/bits/button/exports.js
var exports_exports5 = {};
__export(exports_exports5, {
  Root: () => button_default
});

// node_modules/bits-ui/dist/bits/button/components/button.svelte
mark_module_start();
Button[FILENAME] = "node_modules/bits-ui/dist/bits/button/components/button.svelte";
function Button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Button);
  validate_prop_bindings($$props, ["ref"], [], Button);
  let ref = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "href",
      "type",
      "children",
      "ref"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  validate_void_dynamic_element(() => $$props.href ? "a" : "button");
  validate_dynamic_element_tag(() => $$props.href ? "a" : "button");
  element(
    node,
    () => $$props.href ? "a" : "button",
    false,
    ($$element, $$anchor2) => {
      bind_this($$element, ($$value) => ref($$value), () => ref());
      let attributes;
      template_effect(() => attributes = set_attributes(
        $$element,
        attributes,
        {
          type: $$props.href ? void 0 : $$props.type,
          href: $$props.href,
          tabindex: "0",
          ...restProps
        },
        void 0,
        $$element.namespaceURI === NAMESPACE_SVG,
        $$element.nodeName.includes("-")
      ));
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    void 0,
    [7, 0]
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Button = hmr(Button, () => Button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Button[HMR].source;
    set(Button[HMR].source, module.default[HMR].original);
  });
}
var button_default = Button;
mark_module_end(Button);

// node_modules/bits-ui/dist/bits/calendar/exports.js
var exports_exports6 = {};
__export(exports_exports6, {
  Cell: () => calendar_cell_default,
  Day: () => calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => calendar_default
});

// node_modules/bits-ui/dist/internal/date-time/announcer.js
function initAnnouncer() {
  if (!isBrowser)
    return null;
  let el = document.querySelector("[data-bits-announcer]");
  if (!isHTMLElement(el)) {
    const div = document.createElement("div");
    div.style.cssText = srOnlyStylesString;
    div.setAttribute("data-bits-announcer", "");
    div.appendChild(createLog("assertive"));
    div.appendChild(createLog("polite"));
    el = div;
    document.body.insertBefore(el, document.body.firstChild);
  }
  function createLog(kind) {
    const log = document.createElement("div");
    log.role = "log";
    log.ariaLive = kind;
    log.setAttribute("aria-relevant", "additions");
    return log;
  }
  function getLog(kind) {
    if (!isHTMLElement(el))
      return null;
    const log = el.querySelector(`[aria-live="${kind}"]`);
    if (!isHTMLElement(log))
      return null;
    return log;
  }
  return {
    getLog
  };
}
function getAnnouncer() {
  const announcer = initAnnouncer();
  function announce(value, kind = "assertive", timeout = 7500) {
    if (!announcer || !isBrowser)
      return;
    const log = announcer.getLog(kind);
    const content = document.createElement("div");
    if (typeof value === "number") {
      value = value.toString();
    } else if (value === null) {
      value = "Empty";
    } else {
      value = value.trim();
    }
    content.innerText = value;
    if (kind === "assertive") {
      log == null ? void 0 : log.replaceChildren(content);
    } else {
      log == null ? void 0 : log.appendChild(content);
    }
    return setTimeout(() => {
      content.remove();
    }, timeout);
  }
  return {
    announce
  };
}

// node_modules/bits-ui/dist/internal/date-time/utils.js
var defaultDateDefaults = {
  defaultValue: void 0,
  defaultPlaceholder: void 0,
  granularity: "day"
};
function getDefaultDate(props) {
  const withDefaults = { ...defaultDateDefaults, ...props };
  const { defaultValue, defaultPlaceholder, granularity } = withDefaults;
  if (Array.isArray(defaultValue) && defaultValue.length) {
    return defaultValue[defaultValue.length - 1];
  }
  if (defaultValue && !Array.isArray(defaultValue)) {
    return defaultValue;
  } else if (defaultPlaceholder) {
    return defaultPlaceholder;
  } else {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const calendarDateTimeGranularities = ["hour", "minute", "second"];
    if (calendarDateTimeGranularities.includes(granularity ?? "day")) {
      return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0);
    }
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day);
  }
}
function parseStringToDateValue(dateStr, referenceVal) {
  let dateValue;
  if (referenceVal instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    dateValue = $fae977aafc393c5c$export$fd7893f06e92a6a4(dateStr);
  } else if (referenceVal instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f) {
    dateValue = $fae977aafc393c5c$export$588937bcd60ade55(dateStr);
  } else {
    dateValue = $fae977aafc393c5c$export$6b862160d295c8e(dateStr);
  }
  return dateValue.calendar !== referenceVal.calendar ? $11d87f3f76e88657$export$b4a036af3fc0b032(dateValue, referenceVal.calendar) : dateValue;
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  if (dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    return dateValue.toDate();
  } else {
    return dateValue.toDate(tz);
  }
}
function isCalendarDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date) {
  if (date instanceof Date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return new Date(year, month, 0).getDate();
  } else {
    return date.set({ day: 100 }).day;
  }
}
function isBefore(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date, start, end) {
  return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}
function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  if (firstDayOfWeek > day) {
    return date.subtract({ days: day + 7 - firstDayOfWeek });
  }
  if (firstDayOfWeek === day) {
    return date;
  }
  return date.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  if (day === lastDayOfWeek) {
    return date;
  }
  if (day > lastDayOfWeek) {
    return date.add({ days: 7 - day + lastDayOfWeek });
  }
  return date.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled) {
  if (isUnavailable === void 0 && isDisabled === void 0) {
    return true;
  }
  let dCurrent = start.add({ days: 1 });
  if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
    return false;
  }
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    dCurrent = dCurrent.add({ days: 1 });
    if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
      return false;
    }
  }
  return true;
}

// node_modules/bits-ui/dist/internal/date-time/formatter.js
var defaultPartOptions = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
};
function createFormatter(initialLocale) {
  let locale = initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedDate(date, includeTime = true) {
    if (hasTime(date) && includeTime) {
      return custom(toDate(date), {
        dateStyle: "long",
        timeStyle: "long"
      });
    } else {
      return custom(toDate(date), {
        dateStyle: "long"
      });
    }
  }
  function fullMonthAndYear(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long", year: "numeric" }).format(date);
  }
  function fullMonth(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long" }).format(date);
  }
  function fullYear(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: "numeric" }).format(date);
  }
  function toParts(date, options) {
    if (isZonedDateTime(date)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: date.timeZone
      }).formatToParts(toDate(date));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(date));
    }
  }
  function dayOfWeek(date, length = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: length }).format(date);
  }
  function dayPeriod(date, hourCycle = void 0) {
    var _a;
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: hourCycle === 24 ? "h23" : void 0
    }).formatToParts(date);
    const value = (_a = parts.find((p2) => p2.type === "dayPeriod")) == null ? void 0 : _a.value;
    if (value === "PM") {
      return "PM";
    }
    return "AM";
  }
  function part(dateObj, type, options = {}) {
    const opts = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts);
    const part2 = parts.find((p2) => p2.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    fullMonth,
    fullYear,
    fullMonthAndYear,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedDate,
    dayOfWeek
  };
}

// node_modules/bits-ui/dist/internal/arrays.js
function chunk(arr, size2) {
  if (size2 <= 0) {
    return [];
  }
  const result = [];
  for (let i = 0; i < arr.length; i += size2) {
    result.push(arr.slice(i, i + size2));
  }
  return result;
}
function isValidIndex(index2, arr) {
  return index2 >= 0 && index2 < arr.length;
}
function next2(array, index2, loop = true) {
  if (array.length === 0 || index2 < 0 || index2 >= array.length) {
    return void 0;
  }
  if (array.length === 1 && index2 === 0) {
    return array[0];
  }
  if (index2 === array.length - 1) {
    return loop ? array[0] : void 0;
  }
  return array[index2 + 1];
}
function prev(array, index2, loop = true) {
  if (array.length === 0 || index2 < 0 || index2 >= array.length) {
    return void 0;
  }
  if (array.length === 1 && index2 === 0) {
    return array[0];
  }
  if (index2 === 0) {
    return loop ? array[array.length - 1] : void 0;
  }
  return array[index2 - 1];
}
function forward(array, index2, increment, loop = true) {
  if (array.length === 0 || index2 < 0 || index2 >= array.length) {
    return void 0;
  }
  let targetIndex = index2 + increment;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function backward(array, index2, decrement, loop = true) {
  if (array.length === 0 || index2 < 0 || index2 >= array.length) {
    return void 0;
  }
  let targetIndex = index2 - decrement;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value == null ? void 0 : value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}

// node_modules/bits-ui/dist/internal/date-time/calendar-helpers.svelte.js
function isCalendarDayNode(node) {
  if (!isHTMLElement(node)) return false;
  if (!node.hasAttribute("data-bits-day")) return false;
  return true;
}
function getDaysBetween(start, end) {
  const days = [];
  let dCurrent = start.add({ days: 1 });
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    days.push(dCurrent);
    dCurrent = dCurrent.add({ days: 1 });
  }
  return days;
}
function createMonth(props) {
  const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
  const daysInMonth = getDaysInMonth(dateObj);
  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));
  const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
  const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
  const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale);
  const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale);
  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
  if (fixedWeeks && totalDays < 42) {
    const extraDays = 42 - totalDays;
    let startFrom = nextMonthDays[nextMonthDays.length - 1];
    if (!startFrom) {
      startFrom = dateObj.add({ months: 1 }).set({ day: 1 });
    }
    let length = extraDays;
    if (strict_equals(nextMonthDays.length, 0)) {
      length = extraDays - 1;
      nextMonthDays.push(startFrom);
    }
    const extraDaysArray = Array.from({ length }, (_, i) => {
      const incr = i + 1;
      return startFrom.add({ days: incr });
    });
    nextMonthDays.push(...extraDaysArray);
  }
  const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
  const weeks = chunk(allDays, 7);
  return { value: dateObj, dates: allDays, weeks };
}
function createMonths(props) {
  const { numberOfMonths, dateObj, ...monthProps } = props;
  const months = [];
  if (!numberOfMonths || strict_equals(numberOfMonths, 1)) {
    months.push(createMonth({ ...monthProps, dateObj }));
    return months;
  }
  months.push(createMonth({ ...monthProps, dateObj }));
  for (let i = 1; i < numberOfMonths; (i += 1) - 1) {
    const nextMonth = dateObj.add({ months: i });
    months.push(createMonth({ ...monthProps, dateObj: nextMonth }));
  }
  return months;
}
function getSelectableCells(calendarNode) {
  if (!calendarNode) return [];
  const selectableSelector = `[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])`;
  return Array.from(calendarNode.querySelectorAll(selectableSelector)).filter((el) => isHTMLElement(el));
}
function setPlaceholderToNodeValue(node, placeholder) {
  const cellValue = node.getAttribute("data-value");
  if (!cellValue) return;
  placeholder.current = parseStringToDateValue(cellValue, placeholder.current);
}
function shiftCalendarFocus({
  node,
  add,
  placeholder,
  calendarNode,
  isPrevButtonDisabled,
  isNextButtonDisabled,
  months,
  numberOfMonths
}) {
  var _a, _b;
  const candidateCells = getSelectableCells(calendarNode);
  if (!candidateCells.length) return;
  const index2 = candidateCells.indexOf(node);
  const nextIndex = index2 + add;
  if (isValidIndex(nextIndex, candidateCells)) {
    const nextCell = candidateCells[nextIndex];
    setPlaceholderToNodeValue(nextCell, placeholder);
    return nextCell.focus();
  }
  if (nextIndex < 0) {
    if (isPrevButtonDisabled) return;
    const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.subtract({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = newCandidateCells.length - Math.abs(nextIndex);
      if (isValidIndex(newIndex, newCandidateCells)) {
        const newCell = newCandidateCells[newIndex];
        setPlaceholderToNodeValue(newCell, placeholder);
        return newCell.focus();
      }
    });
  }
  if (nextIndex >= candidateCells.length) {
    if (isNextButtonDisabled) return;
    const firstMonth = (_b = months[0]) == null ? void 0 : _b.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.add({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = nextIndex - candidateCells.length;
      if (isValidIndex(newIndex, newCandidateCells)) {
        const nextCell = newCandidateCells[newIndex];
        return nextCell.focus();
      }
    });
  }
}
var ARROW_KEYS = [
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT
];
var SELECT_KEYS = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
function handleCalendarKeydown({
  event,
  handleCellClick,
  shiftFocus,
  placeholderValue
}) {
  const currentCell = event.target;
  if (!isCalendarDayNode(currentCell)) return;
  if (!ARROW_KEYS.includes(event.key) && !SELECT_KEYS.includes(event.key)) return;
  event.preventDefault();
  const kbdFocusMap = {
    [kbd_constants_exports.ARROW_DOWN]: 7,
    [kbd_constants_exports.ARROW_UP]: -7,
    [kbd_constants_exports.ARROW_LEFT]: -1,
    [kbd_constants_exports.ARROW_RIGHT]: 1
  };
  if (ARROW_KEYS.includes(event.key)) {
    const add = kbdFocusMap[event.key];
    if (strict_equals(add, void 0, false)) {
      shiftFocus(currentCell, add);
    }
  }
  if (SELECT_KEYS.includes(event.key)) {
    const cellValue = currentCell.getAttribute("data-value");
    if (!cellValue) return;
    handleCellClick(event, parseStringToDateValue(cellValue, placeholderValue));
  }
}
function handleCalendarNextPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  var _a;
  const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.add({ months: numberOfMonths }));
  } else {
    const newMonths = createMonths({
      dateObj: firstMonth.add({ months: 1 }),
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setMonths(newMonths);
    const firstNewMonth = newMonths[0];
    if (!firstNewMonth) return;
    setPlaceholder(firstNewMonth.value.set({ day: 1 }));
  }
}
function handleCalendarPrevPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  var _a;
  const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.subtract({ months: numberOfMonths }));
  } else {
    const newMonths = createMonths({
      dateObj: firstMonth.subtract({ months: 1 }),
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setMonths(newMonths);
    const firstNewMonth = newMonths[0];
    if (!firstNewMonth) return;
    setPlaceholder(firstNewMonth.value.set({ day: 1 }));
  }
}
function getWeekdays({ months, formatter, weekdayFormat }) {
  if (!months.length) return [];
  const firstMonth = months[0];
  const firstWeek = firstMonth.weeks[0];
  if (!firstWeek) return [];
  return firstWeek.map((date) => formatter.dayOfWeek(toDate(date), weekdayFormat));
}
function useMonthViewOptionsSync(props) {
  const weekStartsOn = props.weekStartsOn.current;
  const locale = props.locale.current;
  const fixedWeeks = props.fixedWeeks.current;
  const numberOfMonths = props.numberOfMonths.current;
  untrack(() => {
    const placeholder = props.placeholder.current;
    if (!placeholder) return;
    const defaultMonthProps = {
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    };
    props.setMonths(createMonths({ ...defaultMonthProps, dateObj: placeholder }));
  });
}
function createAccessibleHeading({ calendarNode, label, accessibleHeadingId }) {
  const div = document.createElement("div");
  div.style.cssText = styleToString({
    border: "0px",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0px",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  });
  const h2 = document.createElement("div");
  h2.textContent = label;
  h2.id = accessibleHeadingId;
  h2.role = "heading";
  h2.ariaLevel = "2";
  calendarNode.insertBefore(div, calendarNode.firstChild);
  div.appendChild(h2);
  return () => {
    var _a;
    const h22 = document.getElementById(accessibleHeadingId);
    if (!h22) return;
    (_a = div.parentElement) == null ? void 0 : _a.removeChild(div);
    h22.remove();
  };
}
function useMonthViewPlaceholderSync({
  placeholder,
  getVisibleMonths,
  weekStartsOn,
  locale,
  fixedWeeks,
  numberOfMonths,
  setMonths
}) {
  user_effect(() => {
    placeholder.current;
    untrack(() => {
      if (getVisibleMonths().some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(month, placeholder.current))) {
        return;
      }
      const defaultMonthProps = {
        weekStartsOn: weekStartsOn.current,
        locale: locale.current,
        fixedWeeks: fixedWeeks.current,
        numberOfMonths: numberOfMonths.current
      };
      setMonths(createMonths({
        ...defaultMonthProps,
        dateObj: placeholder.current
      }));
    });
  });
}
function getIsNextButtonDisabled({ maxValue, months, disabled }) {
  var _a;
  if (!maxValue || !months.length) return false;
  if (disabled) return true;
  const lastMonthInView = (_a = months[months.length - 1]) == null ? void 0 : _a.value;
  if (!lastMonthInView) return false;
  const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });
  return isAfter(firstMonthOfNextPage, maxValue);
}
function getIsPrevButtonDisabled({ minValue, months, disabled }) {
  var _a;
  if (!minValue || !months.length) return false;
  if (disabled) return true;
  const firstMonthInView = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonthInView) return false;
  const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });
  return isBefore(lastMonthOfPrevPage, minValue);
}
function getCalendarHeadingValue({ months, locale, formatter }) {
  if (!months.length) return "";
  if (strict_equals(locale, formatter.getLocale(), false)) {
    formatter.setLocale(locale);
  }
  if (strict_equals(months.length, 1)) {
    const month = toDate(months[0].value);
    return `${formatter.fullMonthAndYear(month)}`;
  }
  const startMonth = toDate(months[0].value);
  const endMonth = toDate(months[months.length - 1].value);
  const startMonthName = formatter.fullMonth(startMonth);
  const endMonthName = formatter.fullMonth(endMonth);
  const startMonthYear = formatter.fullYear(startMonth);
  const endMonthYear = formatter.fullYear(endMonth);
  const content = strict_equals(startMonthYear, endMonthYear) ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
  return content;
}
function getCalendarElementProps({
  fullCalendarLabel,
  id,
  isInvalid,
  disabled,
  readonly
}) {
  return {
    id,
    role: "application",
    "aria-label": fullCalendarLabel,
    "data-invalid": getDataInvalid(isInvalid),
    "data-disabled": getDataDisabled(disabled),
    "data-readonly": getDataReadonly(readonly)
  };
}
function pickerOpenFocus(e) {
  const nodeToFocus = document.querySelector("[data-bits-day][data-focused]");
  if (nodeToFocus) {
    e.preventDefault();
    nodeToFocus == null ? void 0 : nodeToFocus.focus();
  }
}

// node_modules/bits-ui/dist/bits/calendar/calendar.svelte.js
var _months, _visibleMonths, _setMonths, _weekdays, _isNextButtonDisabled, _isPrevButtonDisabled, _isInvalid, _headingValue, _fullCalendarLabel, _shiftFocus, _handleMultipleUpdate, _handleSingleUpdate, _onkeydown6, _snippetProps4, _props18;
var CalendarRootState = class {
  constructor(props) {
    __publicField(this, "ref");
    __publicField(this, "id");
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "preventDeselect");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "pagedNavigation");
    __publicField(this, "weekStartsOn");
    __publicField(this, "weekdayFormat");
    __publicField(this, "isDateDisabledProp");
    __publicField(this, "isDateUnavailableProp");
    __publicField(this, "fixedWeeks");
    __publicField(this, "numberOfMonths");
    __publicField(this, "locale");
    __publicField(this, "calendarLabel");
    __publicField(this, "type");
    __publicField(this, "readonly");
    __publicField(this, "disableDaysOutsideMonth");
    __publicField(this, "onDateSelect");
    __publicField(this, "initialFocus");
    __privateAdd(this, _months, state(proxy([])));
    __privateAdd(this, _visibleMonths, derived(() => this.months.map((month) => month.value)));
    __publicField(this, "announcer");
    __publicField(this, "formatter");
    __publicField(this, "accessibleHeadingId", useId());
    __privateAdd(this, _setMonths, (months) => this.months = months);
    __privateAdd(this, _weekdays, derived(() => {
      return getWeekdays({
        months: this.months,
        formatter: this.formatter,
        weekdayFormat: this.weekdayFormat.current
      });
    }));
    /**
     * Navigates to the next page of the calendar.
     */
    __publicField(this, "nextPage", () => {
      handleCalendarNextPage({
        fixedWeeks: this.fixedWeeks.current,
        locale: this.locale.current,
        numberOfMonths: this.numberOfMonths.current,
        pagedNavigation: this.pagedNavigation.current,
        setMonths: __privateGet(this, _setMonths),
        setPlaceholder: (date) => this.placeholder.current = date,
        weekStartsOn: this.weekStartsOn.current,
        months: this.months
      });
    });
    /**
     * Navigates to the previous page of the calendar.
     */
    __publicField(this, "prevPage", () => {
      handleCalendarPrevPage({
        fixedWeeks: this.fixedWeeks.current,
        locale: this.locale.current,
        numberOfMonths: this.numberOfMonths.current,
        pagedNavigation: this.pagedNavigation.current,
        setMonths: __privateGet(this, _setMonths),
        setPlaceholder: (date) => this.placeholder.current = date,
        weekStartsOn: this.weekStartsOn.current,
        months: this.months
      });
    });
    __publicField(this, "nextYear", () => {
      this.placeholder.current = this.placeholder.current.add({ years: 1 });
    });
    __publicField(this, "prevYear", () => {
      this.placeholder.current = this.placeholder.current.subtract({ years: 1 });
    });
    __publicField(this, "setYear", (year) => {
      this.placeholder.current = this.placeholder.current.set({ year });
    });
    __publicField(this, "setMonth", (month) => {
      this.placeholder.current = this.placeholder.current.set({ month });
    });
    __privateAdd(this, _isNextButtonDisabled, derived(() => {
      return getIsNextButtonDisabled({
        maxValue: this.maxValue.current,
        months: this.months,
        disabled: this.disabled.current
      });
    }));
    __privateAdd(this, _isPrevButtonDisabled, derived(() => {
      return getIsPrevButtonDisabled({
        minValue: this.minValue.current,
        months: this.months,
        disabled: this.disabled.current
      });
    }));
    __privateAdd(this, _isInvalid, derived(() => {
      const value = this.value.current;
      const isDateDisabled = this.isDateDisabledProp.current;
      const isDateUnavailable = this.isDateUnavailableProp.current;
      if (Array.isArray(value)) {
        if (!value.length) return false;
        for (const date of value) {
          if (isDateDisabled(date)) return true;
          if (isDateUnavailable(date)) return true;
        }
      } else {
        if (!value) return false;
        if (isDateDisabled(value)) return true;
        if (isDateUnavailable(value)) return true;
      }
      return false;
    }));
    __privateAdd(this, _headingValue, derived(() => {
      return getCalendarHeadingValue({
        months: this.months,
        formatter: this.formatter,
        locale: this.locale.current
      });
    }));
    __privateAdd(this, _fullCalendarLabel, derived(() => {
      return `${this.calendarLabel.current} ${this.headingValue}`;
    }));
    __publicField(this, "isOutsideVisibleMonths", (date) => {
      return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
    });
    __publicField(this, "isDateDisabled", (date) => {
      if (this.isDateDisabledProp.current(date) || this.disabled.current) return true;
      const minValue = this.minValue.current;
      const maxValue = this.maxValue.current;
      if (minValue && isBefore(date, minValue)) return true;
      if (maxValue && isBefore(maxValue, date)) return true;
      return false;
    });
    __publicField(this, "isDateSelected", (date) => {
      const value = this.value.current;
      if (Array.isArray(value)) {
        return value.some((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
      } else if (!value) {
        return false;
      } else {
        return $14e0f24ef4ac5c92$export$ea39ec197993aef0(value, date);
      }
    });
    __privateAdd(this, _shiftFocus, (node, add) => {
      return shiftCalendarFocus({
        node,
        add,
        placeholder: this.placeholder,
        calendarNode: this.ref.current,
        isPrevButtonDisabled: this.isPrevButtonDisabled,
        isNextButtonDisabled: this.isNextButtonDisabled,
        months: this.months,
        numberOfMonths: this.numberOfMonths.current
      });
    });
    __publicField(this, "handleCellClick", (_, date) => {
      var _a, _b;
      const readonly = this.readonly.current;
      if (readonly) return;
      const isDateDisabled = this.isDateDisabledProp.current;
      const isDateUnavailable = this.isDateUnavailableProp.current;
      if ((isDateDisabled == null ? void 0 : isDateDisabled(date)) || (isDateUnavailable == null ? void 0 : isDateUnavailable(date))) return;
      const prev2 = this.value.current;
      const multiple = strict_equals(this.type.current, "multiple");
      if (multiple) {
        if (Array.isArray(prev2) || strict_equals(prev2, void 0)) {
          this.value.current = __privateGet(this, _handleMultipleUpdate).call(this, prev2, date);
        }
      } else {
        if (!Array.isArray(prev2)) {
          const next3 = __privateGet(this, _handleSingleUpdate).call(this, prev2, date);
          if (!next3) {
            this.announcer.announce("Selected date is now empty.", "polite", 5e3);
          } else {
            this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(next3, false)}`, "polite");
          }
          this.value.current = next3;
          if (strict_equals(next3, void 0, false)) {
            (_b = (_a = this.onDateSelect) == null ? void 0 : _a.current) == null ? void 0 : _b.call(_a);
          }
        }
      }
    });
    __privateAdd(this, _handleMultipleUpdate, (prev2, date) => {
      if (!prev2) return [date];
      if (!Array.isArray(prev2)) {
        if (DEV) throw new Error("Invalid value for multiple prop.");
        return;
      }
      const index2 = prev2.findIndex((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
      const preventDeselect = this.preventDeselect.current;
      if (strict_equals(index2, -1)) {
        return [...prev2, date];
      } else if (preventDeselect) {
        return prev2;
      } else {
        const next3 = prev2.filter((d) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
        if (!next3.length) {
          this.placeholder.current = date;
          return void 0;
        }
        return next3;
      }
    });
    __privateAdd(this, _handleSingleUpdate, (prev2, date) => {
      if (Array.isArray(prev2)) {
        if (DEV) throw new Error("Invalid value for single prop.");
      }
      if (!prev2) return date;
      const preventDeselect = this.preventDeselect.current;
      if (!preventDeselect && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prev2, date)) {
        this.placeholder.current = date;
        return void 0;
      }
      return date;
    });
    __privateAdd(this, _onkeydown6, (event) => {
      handleCalendarKeydown({
        event,
        handleCellClick: this.handleCellClick,
        shiftFocus: __privateGet(this, _shiftFocus),
        placeholderValue: this.placeholder.current
      });
    });
    __privateAdd(this, _snippetProps4, derived(() => ({ months: this.months, weekdays: this.weekdays })));
    __publicField(this, "getBitsAttr", (part) => {
      return `data-bits-calendar-${part}`;
    });
    __privateAdd(this, _props18, derived(() => ({
      ...getCalendarElementProps({
        fullCalendarLabel: this.fullCalendarLabel,
        id: this.id.current,
        isInvalid: this.isInvalid,
        disabled: this.disabled.current,
        readonly: this.readonly.current
      }),
      [this.getBitsAttr("root")]: "",
      //
      onkeydown: __privateGet(this, _onkeydown6)
    })));
    this.value = props.value;
    this.placeholder = props.placeholder;
    this.preventDeselect = props.preventDeselect;
    this.minValue = props.minValue;
    this.maxValue = props.maxValue;
    this.disabled = props.disabled;
    this.pagedNavigation = props.pagedNavigation;
    this.weekStartsOn = props.weekStartsOn;
    this.weekdayFormat = props.weekdayFormat;
    this.isDateDisabledProp = props.isDateDisabled;
    this.isDateUnavailableProp = props.isDateUnavailable;
    this.fixedWeeks = props.fixedWeeks;
    this.numberOfMonths = props.numberOfMonths;
    this.locale = props.locale;
    this.calendarLabel = props.calendarLabel;
    this.type = props.type;
    this.readonly = props.readonly;
    this.id = props.id;
    this.ref = props.ref;
    this.disableDaysOutsideMonth = props.disableDaysOutsideMonth;
    this.onDateSelect = props.onDateSelect;
    this.initialFocus = props.initialFocus;
    this.announcer = getAnnouncer();
    this.formatter = createFormatter(this.locale.current);
    useRefById({ id: this.id, ref: this.ref });
    this.months = createMonths({
      dateObj: this.placeholder.current,
      weekStartsOn: this.weekStartsOn.current,
      locale: this.locale.current,
      fixedWeeks: this.fixedWeeks.current,
      numberOfMonths: this.numberOfMonths.current
    });
    user_effect(() => {
      var _a;
      const initialFocus = untrack(() => this.initialFocus.current);
      if (initialFocus) {
        const firstFocusedDay = (_a = this.ref.current) == null ? void 0 : _a.querySelector(`[data-focused]`);
        if (firstFocusedDay) {
          firstFocusedDay.focus();
        }
      }
    });
    user_effect(() => {
      if (!this.ref.current) return;
      const removeHeading = createAccessibleHeading({
        calendarNode: this.ref.current,
        label: this.fullCalendarLabel,
        accessibleHeadingId: this.accessibleHeadingId
      });
      return removeHeading;
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    useMonthViewPlaceholderSync({
      placeholder: this.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.weekStartsOn,
      locale: this.locale,
      fixedWeeks: this.fixedWeeks,
      numberOfMonths: this.numberOfMonths,
      setMonths: (months) => this.months = months
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.fixedWeeks,
      locale: this.locale,
      numberOfMonths: this.numberOfMonths,
      placeholder: this.placeholder,
      setMonths: __privateGet(this, _setMonths),
      weekStartsOn: this.weekStartsOn
    });
    user_effect(() => {
      const node = document.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = this.fullCalendarLabel;
    });
    user_effect(() => {
      this.value.current;
      untrack(() => {
        const value = this.value.current;
        if (Array.isArray(value) && value.length) {
          const lastValue = value[value.length - 1];
          if (lastValue && strict_equals(this.placeholder.current, lastValue, false)) {
            this.placeholder.current = lastValue;
          }
        } else if (!Array.isArray(value) && value && strict_equals(this.placeholder.current, value, false)) {
          this.placeholder.current = value;
        }
      });
    });
  }
  get months() {
    return get(__privateGet(this, _months));
  }
  set months(value) {
    set(__privateGet(this, _months), proxy(value, null, __privateGet(this, _months)));
  }
  get visibleMonths() {
    return get(__privateGet(this, _visibleMonths));
  }
  set visibleMonths(_) {
    throw new Error("Cannot update a derived property ('visibleMonths')");
  }
  get weekdays() {
    return get(__privateGet(this, _weekdays));
  }
  set weekdays(_) {
    throw new Error("Cannot update a derived property ('weekdays')");
  }
  get isNextButtonDisabled() {
    return get(__privateGet(this, _isNextButtonDisabled));
  }
  set isNextButtonDisabled(_) {
    throw new Error("Cannot update a derived property ('isNextButtonDisabled')");
  }
  get isPrevButtonDisabled() {
    return get(__privateGet(this, _isPrevButtonDisabled));
  }
  set isPrevButtonDisabled(_) {
    throw new Error("Cannot update a derived property ('isPrevButtonDisabled')");
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid));
  }
  set isInvalid(_) {
    throw new Error("Cannot update a derived property ('isInvalid')");
  }
  get headingValue() {
    return get(__privateGet(this, _headingValue));
  }
  set headingValue(_) {
    throw new Error("Cannot update a derived property ('headingValue')");
  }
  get fullCalendarLabel() {
    return get(__privateGet(this, _fullCalendarLabel));
  }
  set fullCalendarLabel(_) {
    throw new Error("Cannot update a derived property ('fullCalendarLabel')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps4));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props18));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _months)), owner, false);
    add_owner(get(__privateGet(this, _visibleMonths)), owner, false);
    add_owner(get(__privateGet(this, _weekdays)), owner, false);
    add_owner(get(__privateGet(this, _isNextButtonDisabled)), owner, false);
    add_owner(get(__privateGet(this, _isPrevButtonDisabled)), owner, false);
    add_owner(get(__privateGet(this, _isInvalid)), owner, false);
    add_owner(get(__privateGet(this, _headingValue)), owner, false);
    add_owner(get(__privateGet(this, _fullCalendarLabel)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps4)), owner, false);
    add_owner(get(__privateGet(this, _props18)), owner, false);
  }
};
_months = new WeakMap();
_visibleMonths = new WeakMap();
_setMonths = new WeakMap();
_weekdays = new WeakMap();
_isNextButtonDisabled = new WeakMap();
_isPrevButtonDisabled = new WeakMap();
_isInvalid = new WeakMap();
_headingValue = new WeakMap();
_fullCalendarLabel = new WeakMap();
_shiftFocus = new WeakMap();
_handleMultipleUpdate = new WeakMap();
_handleSingleUpdate = new WeakMap();
_onkeydown6 = new WeakMap();
_snippetProps4 = new WeakMap();
_props18 = new WeakMap();
var _headingValue2, _props19;
var CalendarHeadingState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _headingValue2, derived(() => this.root.headingValue));
    __privateAdd(this, _props19, derived(() => ({
      id: this.id.current,
      "aria-hidden": getAriaHidden(true),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      "data-readonly": getDataReadonly(this.root.readonly.current),
      [this.root.getBitsAttr("heading")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get headingValue() {
    return get(__privateGet(this, _headingValue2));
  }
  set headingValue(_) {
    throw new Error("Cannot update a derived property ('headingValue')");
  }
  get props() {
    return get(__privateGet(this, _props19));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _headingValue2)), owner, false);
    add_owner(get(__privateGet(this, _props19)), owner, false);
  }
};
_headingValue2 = new WeakMap();
_props19 = new WeakMap();
var _cellDate, _isDisabled3, _isUnavailable, _isDateToday, _isOutsideMonth, _isOutsideVisibleMonths, _isFocusedDate, _isSelectedDate, _labelText, _snippetProps5, _ariaDisabled, _sharedDataAttrs, _props20;
var CalendarCellState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "date");
    __publicField(this, "month");
    __privateAdd(this, _cellDate, derived(() => toDate(this.date.current)));
    __privateAdd(this, _isDisabled3, derived(() => this.root.isDateDisabled(this.date.current)));
    __privateAdd(this, _isUnavailable, derived(() => this.root.isDateUnavailableProp.current(this.date.current)));
    __privateAdd(this, _isDateToday, derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())));
    __privateAdd(this, _isOutsideMonth, derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.date.current, this.month.current)));
    __privateAdd(this, _isOutsideVisibleMonths, derived(() => this.root.isOutsideVisibleMonths(this.date.current)));
    __privateAdd(this, _isFocusedDate, derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.date.current, this.root.placeholder.current)));
    __privateAdd(this, _isSelectedDate, derived(() => this.root.isDateSelected(this.date.current)));
    __privateAdd(this, _labelText, derived(() => this.root.formatter.custom(this.cellDate, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })));
    __privateAdd(this, _snippetProps5, derived(() => ({
      disabled: this.isDisabled,
      unavailable: this.isUnavailable,
      selected: this.isSelectedDate
    })));
    __privateAdd(this, _ariaDisabled, derived(() => {
      return this.isDisabled || this.isOutsideMonth && this.root.disableDaysOutsideMonth.current || this.isUnavailable;
    }));
    __privateAdd(this, _sharedDataAttrs, derived(() => ({
      "data-unavailable": getDataUnavailable(this.isUnavailable),
      "data-today": this.isDateToday ? "" : void 0,
      "data-outside-month": this.isOutsideMonth ? "" : void 0,
      "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
      "data-focused": this.isFocusedDate ? "" : void 0,
      "data-selected": getDataSelected(this.isSelectedDate),
      "data-value": this.date.current.toString(),
      "data-disabled": getDataDisabled(this.isDisabled || this.isOutsideMonth && this.root.disableDaysOutsideMonth.current)
    })));
    __privateAdd(this, _props20, derived(() => ({
      id: this.id.current,
      role: "gridcell",
      "aria-selected": getAriaSelected(this.isSelectedDate),
      "aria-disabled": getAriaDisabled(this.ariaDisabled),
      ...this.sharedDataAttrs,
      [this.root.getBitsAttr("cell")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    this.date = props.date;
    this.month = props.month;
    useRefById({ id: this.id, ref: this.ref });
  }
  get cellDate() {
    return get(__privateGet(this, _cellDate));
  }
  set cellDate(_) {
    throw new Error("Cannot update a derived property ('cellDate')");
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled3));
  }
  set isDisabled(_) {
    throw new Error("Cannot update a derived property ('isDisabled')");
  }
  get isUnavailable() {
    return get(__privateGet(this, _isUnavailable));
  }
  set isUnavailable(_) {
    throw new Error("Cannot update a derived property ('isUnavailable')");
  }
  get isDateToday() {
    return get(__privateGet(this, _isDateToday));
  }
  set isDateToday(_) {
    throw new Error("Cannot update a derived property ('isDateToday')");
  }
  get isOutsideMonth() {
    return get(__privateGet(this, _isOutsideMonth));
  }
  set isOutsideMonth(_) {
    throw new Error("Cannot update a derived property ('isOutsideMonth')");
  }
  get isOutsideVisibleMonths() {
    return get(__privateGet(this, _isOutsideVisibleMonths));
  }
  set isOutsideVisibleMonths(_) {
    throw new Error("Cannot update a derived property ('isOutsideVisibleMonths')");
  }
  get isFocusedDate() {
    return get(__privateGet(this, _isFocusedDate));
  }
  set isFocusedDate(_) {
    throw new Error("Cannot update a derived property ('isFocusedDate')");
  }
  get isSelectedDate() {
    return get(__privateGet(this, _isSelectedDate));
  }
  set isSelectedDate(_) {
    throw new Error("Cannot update a derived property ('isSelectedDate')");
  }
  get labelText() {
    return get(__privateGet(this, _labelText));
  }
  set labelText(_) {
    throw new Error("Cannot update a derived property ('labelText')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps5));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get ariaDisabled() {
    return get(__privateGet(this, _ariaDisabled));
  }
  set ariaDisabled(_) {
    throw new Error("Cannot update a derived property ('ariaDisabled')");
  }
  get sharedDataAttrs() {
    return get(__privateGet(this, _sharedDataAttrs));
  }
  set sharedDataAttrs(_) {
    throw new Error("Cannot update a derived property ('sharedDataAttrs')");
  }
  get props() {
    return get(__privateGet(this, _props20));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _cellDate)), owner, false);
    add_owner(get(__privateGet(this, _isDisabled3)), owner, false);
    add_owner(get(__privateGet(this, _isUnavailable)), owner, false);
    add_owner(get(__privateGet(this, _isDateToday)), owner, false);
    add_owner(get(__privateGet(this, _isOutsideMonth)), owner, false);
    add_owner(get(__privateGet(this, _isOutsideVisibleMonths)), owner, false);
    add_owner(get(__privateGet(this, _isFocusedDate)), owner, false);
    add_owner(get(__privateGet(this, _isSelectedDate)), owner, false);
    add_owner(get(__privateGet(this, _labelText)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps5)), owner, false);
    add_owner(get(__privateGet(this, _ariaDisabled)), owner, false);
    add_owner(get(__privateGet(this, _sharedDataAttrs)), owner, false);
    add_owner(get(__privateGet(this, _props20)), owner, false);
  }
};
_cellDate = new WeakMap();
_isDisabled3 = new WeakMap();
_isUnavailable = new WeakMap();
_isDateToday = new WeakMap();
_isOutsideMonth = new WeakMap();
_isOutsideVisibleMonths = new WeakMap();
_isFocusedDate = new WeakMap();
_isSelectedDate = new WeakMap();
_labelText = new WeakMap();
_snippetProps5 = new WeakMap();
_ariaDisabled = new WeakMap();
_sharedDataAttrs = new WeakMap();
_props20 = new WeakMap();
var _tabindex, _onclick4, _snippetProps6, _props21;
var CalendarDayState = class {
  constructor(props, cell) {
    __publicField(this, "cell");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _tabindex, derived(() => this.cell.isFocusedDate ? 0 : this.cell.isOutsideMonth && this.cell.root.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : -1));
    __privateAdd(this, _onclick4, (e) => {
      if (this.cell.isDisabled) return;
      this.cell.root.handleCellClick(e, this.cell.date.current);
    });
    __privateAdd(this, _snippetProps6, derived(() => ({
      disabled: this.cell.isDisabled,
      unavailable: this.cell.isUnavailable,
      selected: this.cell.isSelectedDate,
      day: `${this.cell.date.current.day}`
    })));
    __privateAdd(this, _props21, derived(() => ({
      id: this.id.current,
      role: "button",
      "aria-label": this.cell.labelText,
      "aria-disabled": getAriaDisabled(this.cell.ariaDisabled),
      ...this.cell.sharedDataAttrs,
      tabindex: get(__privateGet(this, _tabindex)),
      [this.cell.root.getBitsAttr("day")]: "",
      // Shared logic for range calendar and calendar
      "data-bits-day": "",
      //
      onclick: __privateGet(this, _onclick4)
    })));
    this.cell = cell;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps6));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props21));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps6)), owner, false);
    add_owner(get(__privateGet(this, _props21)), owner, false);
  }
};
_tabindex = new WeakMap();
_onclick4 = new WeakMap();
_snippetProps6 = new WeakMap();
_props21 = new WeakMap();
var _isDisabled4, _onclick5, _props22;
var CalendarNextButtonState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _isDisabled4, derived(() => this.root.isNextButtonDisabled));
    __privateAdd(this, _onclick5, () => {
      if (this.isDisabled) return;
      this.root.nextPage();
    });
    __privateAdd(this, _props22, derived(() => ({
      id: this.id.current,
      role: "button",
      type: "button",
      "aria-label": "Next",
      "aria-disabled": getAriaDisabled(this.isDisabled),
      "data-disabled": getDataDisabled(this.isDisabled),
      disabled: this.isDisabled,
      [this.root.getBitsAttr("next-button")]: "",
      //
      onclick: __privateGet(this, _onclick5)
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled4));
  }
  set isDisabled(_) {
    throw new Error("Cannot update a derived property ('isDisabled')");
  }
  get props() {
    return get(__privateGet(this, _props22));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isDisabled4)), owner, false);
    add_owner(get(__privateGet(this, _props22)), owner, false);
  }
};
_isDisabled4 = new WeakMap();
_onclick5 = new WeakMap();
_props22 = new WeakMap();
var _isDisabled5, _onclick6, _props23;
var CalendarPrevButtonState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _isDisabled5, derived(() => this.root.isPrevButtonDisabled));
    __privateAdd(this, _onclick6, () => {
      if (this.isDisabled) return;
      this.root.prevPage();
    });
    __privateAdd(this, _props23, derived(() => ({
      id: this.id.current,
      role: "button",
      type: "button",
      "aria-label": "Previous",
      "aria-disabled": getAriaDisabled(this.isDisabled),
      "data-disabled": getDataDisabled(this.isDisabled),
      disabled: this.isDisabled,
      [this.root.getBitsAttr("prev-button")]: "",
      //
      onclick: __privateGet(this, _onclick6)
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled5));
  }
  set isDisabled(_) {
    throw new Error("Cannot update a derived property ('isDisabled')");
  }
  get props() {
    return get(__privateGet(this, _props23));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isDisabled5)), owner, false);
    add_owner(get(__privateGet(this, _props23)), owner, false);
  }
};
_isDisabled5 = new WeakMap();
_onclick6 = new WeakMap();
_props23 = new WeakMap();
var _props24;
var CalendarGridState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _props24, derived(() => ({
      id: this.id.current,
      tabindex: -1,
      role: "grid",
      "aria-readonly": getAriaReadonly(this.root.readonly.current),
      "aria-disabled": getAriaDisabled(this.root.disabled.current),
      "data-readonly": getDataReadonly(this.root.readonly.current),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      [this.root.getBitsAttr("grid")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props24));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props24)), owner, false);
  }
};
_props24 = new WeakMap();
var _props25;
var CalendarGridBodyState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _props25, derived(() => ({
      id: this.id.current,
      "data-disabled": getDataDisabled(this.root.disabled.current),
      "data-readonly": getDataReadonly(this.root.readonly.current),
      [this.root.getBitsAttr("grid-body")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props25));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props25)), owner, false);
  }
};
_props25 = new WeakMap();
var _props26;
var CalendarGridHeadState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _props26, derived(() => ({
      id: this.id.current,
      "data-disabled": getDataDisabled(this.root.disabled.current),
      "data-readonly": getDataReadonly(this.root.readonly.current),
      [this.root.getBitsAttr("grid-head")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props26));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props26)), owner, false);
  }
};
_props26 = new WeakMap();
var _props27;
var CalendarGridRowState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _props27, derived(() => ({
      id: this.id.current,
      "data-disabled": getDataDisabled(this.root.disabled.current),
      "data-readonly": getDataReadonly(this.root.readonly.current),
      [this.root.getBitsAttr("grid-row")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props27));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props27)), owner, false);
  }
};
_props27 = new WeakMap();
var _props28;
var CalendarHeadCellState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _props28, derived(() => ({
      id: this.id.current,
      "data-disabled": getDataDisabled(this.root.disabled.current),
      "data-readonly": getDataReadonly(this.root.readonly.current),
      [this.root.getBitsAttr("head-cell")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props28));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props28)), owner, false);
  }
};
_props28 = new WeakMap();
var _props29;
var CalendarHeaderState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _props29, derived(() => ({
      id: this.id.current,
      "data-disabled": getDataDisabled(this.root.disabled.current),
      "data-readonly": getDataReadonly(this.root.readonly.current),
      [this.root.getBitsAttr("header")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props29));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props29)), owner, false);
  }
};
_props29 = new WeakMap();
var [
  setCalendarRootContext,
  getCalendarRootContext
] = createContext(["Calendar.Root", "RangeCalendar.Root"], "Calendar.Root", false);
var [
  setCalendarCellContext,
  getCalendarCellContext
] = createContext("Calendar.Cell");
function useCalendarRoot(props) {
  return setCalendarRootContext(new CalendarRootState(props));
}
function useCalendarGrid(props) {
  const root17 = getCalendarRootContext();
  return new CalendarGridState(props, root17);
}
function useCalendarCell(props) {
  const root17 = getCalendarRootContext();
  return setCalendarCellContext(new CalendarCellState(props, root17));
}
function useCalendarNextButton(props) {
  const root17 = getCalendarRootContext();
  return new CalendarNextButtonState(props, root17);
}
function useCalendarPrevButton(props) {
  const root17 = getCalendarRootContext();
  return new CalendarPrevButtonState(props, root17);
}
function useCalendarDay(props) {
  const cell = getCalendarCellContext();
  return new CalendarDayState(props, cell);
}
function useCalendarGridBody(props) {
  const root17 = getCalendarRootContext();
  return new CalendarGridBodyState(props, root17);
}
function useCalendarGridHead(props) {
  const root17 = getCalendarRootContext();
  return new CalendarGridHeadState(props, root17);
}
function useCalendarGridRow(props) {
  const root17 = getCalendarRootContext();
  return new CalendarGridRowState(props, root17);
}
function useCalendarHeadCell(props) {
  const root17 = getCalendarRootContext();
  return new CalendarHeadCellState(props, root17);
}
function useCalendarHeader(props) {
  const root17 = getCalendarRootContext();
  return new CalendarHeaderState(props, root17);
}
function useCalendarHeading(props) {
  const root17 = getCalendarRootContext();
  return new CalendarHeadingState(props, root17);
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte
mark_module_start();
Calendar[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte";
var root_214 = add_locations(template(`<div><!></div>`), Calendar[FILENAME], [[118, 1]]);
function Calendar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar);
  validate_prop_bindings($$props, ["ref", "value", "placeholder"], [], Calendar);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop2), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), weekStartsOn = prop($$props, "weekStartsOn", 3, 0), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), locale = prop($$props, "locale", 3, "en"), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), controlledPlaceholder = prop($$props, "controlledPlaceholder", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "weekdayFormat",
      "weekStartsOn",
      "pagedNavigation",
      "isDateDisabled",
      "isDateUnavailable",
      "fixedWeeks",
      "numberOfMonths",
      "locale",
      "calendarLabel",
      "disabled",
      "readonly",
      "minValue",
      "maxValue",
      "preventDeselect",
      "type",
      "disableDaysOutsideMonth",
      "initialFocus",
      "controlledValue",
      "controlledPlaceholder"
    ],
    "restProps"
  );
  if (strict_equals(placeholder(), void 0)) {
    const defaultPlaceholder = getDefaultDate({
      defaultPlaceholder: void 0,
      defaultValue: value()
    });
    if (controlledPlaceholder()) {
      onPlaceholderChange()(defaultPlaceholder);
    } else {
      placeholder(defaultPlaceholder);
    }
  }
  if (strict_equals(value(), void 0)) {
    const defaultValue = strict_equals($$props.type, "single") ? "" : [];
    if (controlledValue()) {
      onValueChange()(defaultValue);
    } else {
      value(defaultValue);
    }
  }
  strict_equals(value(), void 0) && value(strict_equals($$props.type, "single") ? void 0 : []);
  const rootState = useCalendarRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    weekdayFormat: box.with(() => weekdayFormat()),
    weekStartsOn: box.with(() => weekStartsOn()),
    pagedNavigation: box.with(() => pagedNavigation()),
    isDateDisabled: box.with(() => isDateDisabled()),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    locale: box.with(() => locale()),
    calendarLabel: box.with(() => calendarLabel()),
    readonly: box.with(() => readonly()),
    disabled: box.with(() => disabled()),
    minValue: box.with(() => minValue()),
    maxValue: box.with(() => maxValue()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    initialFocus: box.with(() => initialFocus()),
    placeholder: box.with(() => placeholder(), (v) => {
      if (controlledPlaceholder()) {
        onPlaceholderChange()(v);
      } else {
        placeholder(v);
        onPlaceholderChange()(v);
      }
    }),
    preventDeselect: box.with(() => preventDeselect()),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    type: box.with(() => $$props.type)
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_214();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar = hmr(Calendar, () => Calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar[HMR].source;
    set(Calendar[HMR].source, module.default[HMR].original);
  });
}
var calendar_default = Calendar;
mark_module_end(Calendar);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte
mark_module_start();
Calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte";
var root_215 = add_locations(template(`<div><!></div>`), Calendar_day[FILENAME], [[32, 1]]);
function Calendar_day($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_day);
  validate_prop_bindings($$props, ["ref"], [], Calendar_day);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const dayState = useCalendarDay({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, dayState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...dayState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_215();
      let attributes;
      var node_2 = child(div);
      if_block(
        node_2,
        () => $$props.children,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps);
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.date.current.day));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_day = hmr(Calendar_day, () => Calendar_day[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_day[HMR].source;
    set(Calendar_day[HMR].source, module.default[HMR].original);
  });
}
var calendar_day_default = Calendar_day;
mark_module_end(Calendar_day);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte
mark_module_start();
Calendar_grid[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte";
var root_216 = add_locations(template(`<table><!></table>`), Calendar_grid[FILENAME], [[29, 1]]);
function Calendar_grid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_grid);
  validate_prop_bindings($$props, ["ref"], [], Calendar_grid);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridState = useCalendarGrid({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, gridState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var table = root_216();
      let attributes;
      var node_2 = child(table);
      snippet(node_2, () => $$props.children ?? noop);
      reset(table);
      template_effect(() => attributes = set_attributes(table, attributes, { ...get(mergedProps) }));
      append($$anchor2, table);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid = hmr(Calendar_grid, () => Calendar_grid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid[HMR].source;
    set(Calendar_grid[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_default = Calendar_grid;
mark_module_end(Calendar_grid);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte
mark_module_start();
Calendar_grid_body[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte";
var root_217 = add_locations(template(`<tbody><!></tbody>`), Calendar_grid_body[FILENAME], [[29, 1]]);
function Calendar_grid_body($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_grid_body);
  validate_prop_bindings($$props, ["ref"], [], Calendar_grid_body);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridBodyState = useCalendarGridBody({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, gridBodyState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tbody = root_217();
      let attributes;
      var node_2 = child(tbody);
      snippet(node_2, () => $$props.children ?? noop);
      reset(tbody);
      template_effect(() => attributes = set_attributes(tbody, attributes, { ...get(mergedProps) }));
      append($$anchor2, tbody);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_body = hmr(Calendar_grid_body, () => Calendar_grid_body[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_body[HMR].source;
    set(Calendar_grid_body[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_body_default = Calendar_grid_body;
mark_module_end(Calendar_grid_body);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte
mark_module_start();
Calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte";
var root_218 = add_locations(template(`<td><!></td>`), Calendar_cell[FILENAME], [[36, 1]]);
function Calendar_cell($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_cell);
  validate_prop_bindings($$props, ["ref"], [], Calendar_cell);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "date",
      "month"
    ],
    "restProps"
  );
  const cellState = useCalendarCell({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    date: box.with(() => $$props.date),
    month: box.with(() => $$props.month)
  });
  const mergedProps = derived(() => mergeProps(restProps, cellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...cellState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var td = root_218();
      let attributes;
      var node_2 = child(td);
      snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps);
      reset(td);
      template_effect(() => attributes = set_attributes(td, attributes, { ...get(mergedProps) }));
      append($$anchor2, td);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_cell = hmr(Calendar_cell, () => Calendar_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_cell[HMR].source;
    set(Calendar_cell[HMR].source, module.default[HMR].original);
  });
}
var calendar_cell_default = Calendar_cell;
mark_module_end(Calendar_cell);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte
mark_module_start();
Calendar_grid_head[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte";
var root_219 = add_locations(template(`<thead><!></thead>`), Calendar_grid_head[FILENAME], [[29, 1]]);
function Calendar_grid_head($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_grid_head);
  validate_prop_bindings($$props, ["ref"], [], Calendar_grid_head);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridHeadState = useCalendarGridHead({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, gridHeadState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var thead = root_219();
      let attributes;
      var node_2 = child(thead);
      snippet(node_2, () => $$props.children ?? noop);
      reset(thead);
      template_effect(() => attributes = set_attributes(thead, attributes, { ...get(mergedProps) }));
      append($$anchor2, thead);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_head = hmr(Calendar_grid_head, () => Calendar_grid_head[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_head[HMR].source;
    set(Calendar_grid_head[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_head_default = Calendar_grid_head;
mark_module_end(Calendar_grid_head);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte
mark_module_start();
Calendar_head_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte";
var root_220 = add_locations(template(`<th><!></th>`), Calendar_head_cell[FILENAME], [[29, 1]]);
function Calendar_head_cell($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_head_cell);
  validate_prop_bindings($$props, ["ref"], [], Calendar_head_cell);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headCellState = useCalendarHeadCell({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, headCellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var th = root_220();
      let attributes;
      var node_2 = child(th);
      snippet(node_2, () => $$props.children ?? noop);
      reset(th);
      template_effect(() => attributes = set_attributes(th, attributes, { ...get(mergedProps) }));
      append($$anchor2, th);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_head_cell = hmr(Calendar_head_cell, () => Calendar_head_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_head_cell[HMR].source;
    set(Calendar_head_cell[HMR].source, module.default[HMR].original);
  });
}
var calendar_head_cell_default = Calendar_head_cell;
mark_module_end(Calendar_head_cell);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte
mark_module_start();
Calendar_grid_row[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte";
var root_221 = add_locations(template(`<tr><!></tr>`), Calendar_grid_row[FILENAME], [[29, 1]]);
function Calendar_grid_row($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_grid_row);
  validate_prop_bindings($$props, ["ref"], [], Calendar_grid_row);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridRowState = useCalendarGridRow({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, gridRowState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var tr = root_221();
      let attributes;
      var node_2 = child(tr);
      snippet(node_2, () => $$props.children ?? noop);
      reset(tr);
      template_effect(() => attributes = set_attributes(tr, attributes, { ...get(mergedProps) }));
      append($$anchor2, tr);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_row = hmr(Calendar_grid_row, () => Calendar_grid_row[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_row[HMR].source;
    set(Calendar_grid_row[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_row_default = Calendar_grid_row;
mark_module_end(Calendar_grid_row);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte
mark_module_start();
Calendar_header[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte";
var root_222 = add_locations(template(`<header><!></header>`), Calendar_header[FILENAME], [[29, 1]]);
function Calendar_header($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_header);
  validate_prop_bindings($$props, ["ref"], [], Calendar_header);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headerState = useCalendarHeader({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, headerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var header = root_222();
      let attributes;
      var node_2 = child(header);
      snippet(node_2, () => $$props.children ?? noop);
      reset(header);
      template_effect(() => attributes = set_attributes(header, attributes, { ...get(mergedProps) }));
      append($$anchor2, header);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_header = hmr(Calendar_header, () => Calendar_header[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_header[HMR].source;
    set(Calendar_header[HMR].source, module.default[HMR].original);
  });
}
var calendar_header_default = Calendar_header;
mark_module_end(Calendar_header);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte
mark_module_start();
Calendar_heading[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte";
var root_223 = add_locations(template(`<div><!></div>`), Calendar_heading[FILENAME], [[29, 1]]);
function Calendar_heading($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_heading);
  validate_prop_bindings($$props, ["ref"], [], Calendar_heading);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headingState = useCalendarHeading({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, headingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        headingValue: headingState.headingValue
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_223();
      let attributes;
      var node_2 = child(div);
      if_block(
        node_2,
        () => $$props.children,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => ({ headingValue: headingState.headingValue }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, headingState.headingValue));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_heading = hmr(Calendar_heading, () => Calendar_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_heading[HMR].source;
    set(Calendar_heading[HMR].source, module.default[HMR].original);
  });
}
var calendar_heading_default = Calendar_heading;
mark_module_end(Calendar_heading);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte
mark_module_start();
Calendar_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte";
var root_224 = add_locations(template(`<button><!></button>`), Calendar_next_button[FILENAME], [[29, 1]]);
function Calendar_next_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_next_button);
  validate_prop_bindings($$props, ["ref"], [], Calendar_next_button);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const nextButtonState = useCalendarNextButton({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, nextButtonState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_224();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_next_button = hmr(Calendar_next_button, () => Calendar_next_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_next_button[HMR].source;
    set(Calendar_next_button[HMR].source, module.default[HMR].original);
  });
}
var calendar_next_button_default = Calendar_next_button;
mark_module_end(Calendar_next_button);

// node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte
mark_module_start();
Calendar_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte";
var root_225 = add_locations(template(`<button><!></button>`), Calendar_prev_button[FILENAME], [[29, 1]]);
function Calendar_prev_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar_prev_button);
  validate_prop_bindings($$props, ["ref"], [], Calendar_prev_button);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const prevButtonState = useCalendarPrevButton({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, prevButtonState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_225();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_prev_button = hmr(Calendar_prev_button, () => Calendar_prev_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_prev_button[HMR].source;
    set(Calendar_prev_button[HMR].source, module.default[HMR].original);
  });
}
var calendar_prev_button_default = Calendar_prev_button;
mark_module_end(Calendar_prev_button);

// node_modules/bits-ui/dist/bits/checkbox/exports.js
var exports_exports7 = {};
__export(exports_exports7, {
  Root: () => checkbox_default
});

// node_modules/bits-ui/dist/bits/checkbox/checkbox.svelte.js
var CHECKBOX_ROOT_ATTR = "data-checkbox-root";
var _id19, _ref19, _type, _onkeydown7, _toggle, _onclick7, _props30;
var CheckboxRootState = class {
  constructor(props) {
    __privateAdd(this, _id19);
    __privateAdd(this, _ref19);
    __privateAdd(this, _type);
    __publicField(this, "checked");
    __publicField(this, "disabled");
    __publicField(this, "required");
    __publicField(this, "name");
    __publicField(this, "value");
    __publicField(this, "indeterminate");
    __privateAdd(this, _onkeydown7, (e) => {
      if (this.disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.ENTER)) e.preventDefault();
      if (strict_equals(e.key, kbd_constants_exports.SPACE)) {
        e.preventDefault();
        __privateGet(this, _toggle).call(this);
      }
    });
    __privateAdd(this, _toggle, () => {
      if (this.indeterminate.current) {
        this.indeterminate.current = false;
        this.checked.current = true;
      } else {
        this.checked.current = !this.checked.current;
      }
    });
    __privateAdd(this, _onclick7, () => {
      if (this.disabled.current) return;
      __privateGet(this, _toggle).call(this);
    });
    __privateAdd(this, _props30, derived(() => ({
      id: __privateGet(this, _id19).current,
      role: "checkbox",
      type: __privateGet(this, _type).current,
      disabled: this.disabled.current,
      "aria-checked": getAriaChecked(this.checked.current, this.indeterminate.current),
      "aria-required": getAriaRequired(this.required.current),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-state": getCheckboxDataState(this.checked.current, this.indeterminate.current),
      [CHECKBOX_ROOT_ATTR]: "",
      //
      onclick: __privateGet(this, _onclick7),
      onkeydown: __privateGet(this, _onkeydown7)
    })));
    this.checked = props.checked;
    this.disabled = props.disabled;
    this.required = props.required;
    this.name = props.name;
    this.value = props.value;
    __privateSet(this, _ref19, props.ref);
    __privateSet(this, _id19, props.id);
    this.indeterminate = props.indeterminate;
    __privateSet(this, _type, props.type);
    useRefById({ id: __privateGet(this, _id19), ref: __privateGet(this, _ref19) });
  }
  get props() {
    return get(__privateGet(this, _props30));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props30)), owner, false);
  }
};
_id19 = new WeakMap();
_ref19 = new WeakMap();
_type = new WeakMap();
_onkeydown7 = new WeakMap();
_toggle = new WeakMap();
_onclick7 = new WeakMap();
_props30 = new WeakMap();
var _shouldRender, _props31;
var CheckboxInputState = class {
  constructor(root17) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender, derived(() => Boolean(this.root.name.current)));
    __privateAdd(this, _props31, derived(() => ({
      type: "checkbox",
      checked: strict_equals(this.root.checked.current, true),
      disabled: this.root.disabled.current,
      required: this.root.required.current,
      name: this.root.name.current,
      value: this.root.value.current,
      "aria-hidden": "true",
      style: styleToString(srOnlyStyles)
    })));
    this.root = root17;
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get props() {
    return get(__privateGet(this, _props31));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _shouldRender)), owner, false);
    add_owner(get(__privateGet(this, _props31)), owner, false);
  }
};
_shouldRender = new WeakMap();
_props31 = new WeakMap();
function getCheckboxDataState(checked, indeterminate) {
  if (indeterminate) {
    return "indeterminate";
  }
  return checked ? "checked" : "unchecked";
}
var [
  setCheckboxRootContext,
  getCheckboxRootContext
] = createContext("Checkbox.Root");
function useCheckboxRoot(props) {
  return setCheckboxRootContext(new CheckboxRootState(props));
}
function useCheckboxInput() {
  const root17 = getCheckboxRootContext();
  return new CheckboxInputState(root17);
}

// node_modules/bits-ui/dist/bits/utilities/visually-hidden/visually-hidden.svelte
mark_module_start();
Visually_hidden[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/visually-hidden/visually-hidden.svelte";
var root_226 = add_locations(template(`<span><!></span>`), Visually_hidden[FILENAME], [[28, 1]]);
function Visually_hidden($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Visually_hidden);
  validate_prop_bindings($$props, [], [], Visually_hidden);
  let restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child"
    ],
    "restProps"
  );
  const style = {
    position: "absolute",
    border: 0,
    width: "1px",
    display: "inline-block",
    height: "1px",
    padding: 0,
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  const mergedProps = derived(() => mergeProps(restProps, { style }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_226();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Visually_hidden = hmr(Visually_hidden, () => Visually_hidden[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Visually_hidden[HMR].source;
    set(Visually_hidden[HMR].source, module.default[HMR].original);
  });
}
var visually_hidden_default = Visually_hidden;
mark_module_end(Visually_hidden);

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte
mark_module_start();
Checkbox_input[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte";
var root_227 = add_locations(template(`<input>`), Checkbox_input[FILENAME], [[10, 2]]);
function Checkbox_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Checkbox_input);
  const inputState = useCheckboxInput();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => inputState.shouldRender, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    visually_hidden_default(node_1, {
      "aria-hidden": "true",
      children: wrap_snippet(Checkbox_input, ($$anchor3, $$slotProps) => {
        var input = root_227();
        remove_input_defaults(input);
        let attributes;
        template_effect(() => attributes = set_attributes(input, attributes, {
          ...inputState.props,
          type: "checkbox",
          style: "display: none !important;"
        }));
        append($$anchor3, input);
      }),
      $$slots: { default: true }
    });
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox_input = hmr(Checkbox_input, () => Checkbox_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox_input[HMR].source;
    set(Checkbox_input[HMR].source, module.default[HMR].original);
  });
}
var checkbox_input_default = Checkbox_input;
mark_module_end(Checkbox_input);

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte
mark_module_start();
Checkbox[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte";
var root_228 = add_locations(template(`<button><!></button>`), Checkbox[FILENAME], [[72, 1]]);
var root2 = add_locations(template(`<!> <!>`, 1), Checkbox[FILENAME], []);
function Checkbox($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Checkbox);
  validate_prop_bindings($$props, ["checked", "ref", "indeterminate"], [], Checkbox);
  let checked = prop($$props, "checked", 15, false), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), name = prop($$props, "name", 3, void 0), value = prop($$props, "value", 3, "on"), id = prop($$props, "id", 19, useId), controlledChecked = prop($$props, "controlledChecked", 3, false), indeterminate = prop($$props, "indeterminate", 15, false), controlledIndeterminate = prop($$props, "controlledIndeterminate", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "checked",
      "ref",
      "onCheckedChange",
      "children",
      "disabled",
      "required",
      "name",
      "value",
      "id",
      "controlledChecked",
      "indeterminate",
      "controlledIndeterminate",
      "onIndeterminateChange",
      "child",
      "type"
    ],
    "restProps"
  );
  const rootState = useCheckboxRoot({
    checked: box.with(() => checked(), (v) => {
      var _a, _b;
      if (controlledChecked()) {
        (_a = $$props.onCheckedChange) == null ? void 0 : _a.call($$props, v);
      } else {
        checked(v);
        (_b = $$props.onCheckedChange) == null ? void 0 : _b.call($$props, v);
      }
    }),
    disabled: box.with(() => disabled() ?? false),
    required: box.with(() => required()),
    name: box.with(() => name()),
    value: box.with(() => value()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    indeterminate: box.with(() => indeterminate(), (v) => {
      var _a, _b;
      if (controlledIndeterminate()) {
        (_a = $$props.onIndeterminateChange) == null ? void 0 : _a.call($$props, v);
      } else {
        indeterminate(v);
        (_b = $$props.onIndeterminateChange) == null ? void 0 : _b.call($$props, v);
      }
    }),
    type: box.with(() => type())
  });
  const mergedProps = derived(() => mergeProps({ ...restProps }, rootState.props));
  var fragment = root2();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        checked: rootState.checked.current,
        indeterminate: rootState.indeterminate.current
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_228();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => ({
        checked: rootState.checked.current,
        indeterminate: rootState.indeterminate.current
      }));
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  var node_3 = sibling(node, 2);
  checkbox_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox = hmr(Checkbox, () => Checkbox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox[HMR].source;
    set(Checkbox[HMR].source, module.default[HMR].original);
  });
}
var checkbox_default = Checkbox;
mark_module_end(Checkbox);

// node_modules/bits-ui/dist/bits/collapsible/exports.js
var exports_exports8 = {};
__export(exports_exports8, {
  Content: () => collapsible_content_default,
  Root: () => collapsible_default,
  Trigger: () => collapsible_trigger_default
});

// node_modules/bits-ui/dist/bits/collapsible/collapsible.svelte.js
var COLLAPSIBLE_ROOT_ATTR = "data-collapsible-root";
var COLLAPSIBLE_CONTENT_ATTR = "data-collapsible-content";
var COLLAPSIBLE_TRIGGER_ATTR = "data-collapsible-trigger";
var _id20, _ref20, _contentNode2, _contentId2, _props32;
var CollapsibleRootState = class {
  constructor(props) {
    __privateAdd(this, _id20);
    __privateAdd(this, _ref20);
    __publicField(this, "open");
    __publicField(this, "disabled");
    __privateAdd(this, _contentNode2, state(null));
    __privateAdd(this, _contentId2, state(void 0));
    __privateAdd(this, _props32, derived(() => ({
      id: __privateGet(this, _id20).current,
      "data-state": getDataOpenClosed(this.open.current),
      "data-disabled": getDataDisabled(this.disabled.current),
      [COLLAPSIBLE_ROOT_ATTR]: ""
    })));
    this.open = props.open;
    this.disabled = props.disabled;
    __privateSet(this, _id20, props.id);
    __privateSet(this, _ref20, props.ref);
    useRefById({ id: __privateGet(this, _id20), ref: __privateGet(this, _ref20) });
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode2));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode2), proxy(value, null, __privateGet(this, _contentNode2)));
  }
  get contentId() {
    return get(__privateGet(this, _contentId2));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId2), proxy(value, null, __privateGet(this, _contentId2)));
  }
  toggleOpen() {
    this.open.current = !this.open.current;
  }
  get props() {
    return get(__privateGet(this, _props32));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _contentNode2)), owner, false);
    add_owner(get(__privateGet(this, _contentId2)), owner, false);
    add_owner(get(__privateGet(this, _props32)), owner, false);
  }
};
_id20 = new WeakMap();
_ref20 = new WeakMap();
_contentNode2 = new WeakMap();
_contentId2 = new WeakMap();
_props32 = new WeakMap();
var _id21, _ref21, _originalStyles2, _isMountAnimationPrevented2, _width2, _height2, _forceMount2, _present2, _snippetProps7, _props33;
var CollapsibleContentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id21);
    __privateAdd(this, _ref21);
    __publicField(this, "root");
    __privateAdd(this, _originalStyles2);
    __privateAdd(this, _isMountAnimationPrevented2, state(false));
    __privateAdd(this, _width2, state(0));
    __privateAdd(this, _height2, state(0));
    __privateAdd(this, _forceMount2);
    __privateAdd(this, _present2, derived(() => __privateGet(this, _forceMount2).current || this.root.open.current));
    __privateAdd(this, _snippetProps7, derived(() => ({ open: this.root.open.current })));
    __privateAdd(this, _props33, derived(() => ({
      id: __privateGet(this, _id21).current,
      style: {
        "--bits-collapsible-content-height": get(__privateGet(this, _height2)) ? `${get(__privateGet(this, _height2))}px` : void 0,
        "--bits-collapsible-content-width": get(__privateGet(this, _width2)) ? `${get(__privateGet(this, _width2))}px` : void 0
      },
      "data-state": getDataOpenClosed(this.root.open.current),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      [COLLAPSIBLE_CONTENT_ATTR]: ""
    })));
    this.root = root17;
    __privateGet(this, _isMountAnimationPrevented2).v = proxy(root17.open.current, null, __privateGet(this, _isMountAnimationPrevented2));
    __privateSet(this, _forceMount2, props.forceMount);
    __privateSet(this, _id21, props.id);
    __privateSet(this, _ref21, props.ref);
    useRefById({
      id: __privateGet(this, _id21),
      ref: __privateGet(this, _ref21),
      deps: () => this.present,
      onRefChange: (node) => {
        this.root.contentNode = node;
        this.root.contentId = node == null ? void 0 : node.id;
      }
    });
    user_pre_effect(() => {
      const rAF = requestAnimationFrame(() => {
        set(__privateGet(this, _isMountAnimationPrevented2), false);
      });
      return () => {
        cancelAnimationFrame(rAF);
      };
    });
    user_effect(() => {
      this.present;
      const node = __privateGet(this, _ref21).current;
      if (!node) return;
      afterTick(() => {
        if (!__privateGet(this, _ref21).current) return;
        __privateSet(this, _originalStyles2, __privateGet(this, _originalStyles2) || {
          transitionDuration: node.style.transitionDuration,
          animationName: node.style.animationName
        });
        node.style.transitionDuration = "0s";
        node.style.animationName = "none";
        const rect = node.getBoundingClientRect();
        set(__privateGet(this, _height2), proxy(rect.height, null, __privateGet(this, _height2)));
        set(__privateGet(this, _width2), proxy(rect.width, null, __privateGet(this, _width2)));
        if (!get(__privateGet(this, _isMountAnimationPrevented2))) {
          const { animationName, transitionDuration } = __privateGet(this, _originalStyles2);
          node.style.transitionDuration = transitionDuration;
          node.style.animationName = animationName;
        }
      });
    });
  }
  get present() {
    return get(__privateGet(this, _present2));
  }
  set present(_) {
    throw new Error("Cannot update a derived property ('present')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps7));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props33));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _present2)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps7)), owner, false);
    add_owner(get(__privateGet(this, _props33)), owner, false);
  }
};
_id21 = new WeakMap();
_ref21 = new WeakMap();
_originalStyles2 = new WeakMap();
_isMountAnimationPrevented2 = new WeakMap();
_width2 = new WeakMap();
_height2 = new WeakMap();
_forceMount2 = new WeakMap();
_present2 = new WeakMap();
_snippetProps7 = new WeakMap();
_props33 = new WeakMap();
var _root10, _ref22, _id22, _disabled5, _isDisabled6, _onpointerdown5, _onpointerup2, _onkeydown8, _props34;
var CollapsibleTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _root10);
    __privateAdd(this, _ref22);
    __privateAdd(this, _id22);
    __privateAdd(this, _disabled5);
    __privateAdd(this, _isDisabled6, derived(() => __privateGet(this, _disabled5).current || __privateGet(this, _root10).disabled.current));
    __privateAdd(this, _onpointerdown5, (e) => {
      if (get(__privateGet(this, _isDisabled6))) return;
      if (strict_equals(e.pointerType, "touch") || strict_equals(e.button, 0, false)) return e.preventDefault();
      __privateGet(this, _root10).toggleOpen();
    });
    __privateAdd(this, _onpointerup2, (e) => {
      if (get(__privateGet(this, _isDisabled6))) return;
      if (strict_equals(e.pointerType, "touch")) {
        e.preventDefault();
        __privateGet(this, _root10).toggleOpen();
      }
    });
    __privateAdd(this, _onkeydown8, (e) => {
      if (get(__privateGet(this, _isDisabled6))) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        __privateGet(this, _root10).toggleOpen();
      }
    });
    __privateAdd(this, _props34, derived(() => ({
      id: __privateGet(this, _id22).current,
      type: "button",
      disabled: get(__privateGet(this, _isDisabled6)),
      "aria-controls": __privateGet(this, _root10).contentId,
      "aria-expanded": getAriaExpanded(__privateGet(this, _root10).open.current),
      "data-state": getDataOpenClosed(__privateGet(this, _root10).open.current),
      "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled6))),
      [COLLAPSIBLE_TRIGGER_ATTR]: "",
      //
      onpointerdown: __privateGet(this, _onpointerdown5),
      onpointerup: __privateGet(this, _onpointerup2),
      onkeydown: __privateGet(this, _onkeydown8)
    })));
    __privateSet(this, _root10, root17);
    __privateSet(this, _id22, props.id);
    __privateSet(this, _ref22, props.ref);
    __privateSet(this, _disabled5, props.disabled);
    useRefById({ id: __privateGet(this, _id22), ref: __privateGet(this, _ref22) });
  }
  get props() {
    return get(__privateGet(this, _props34));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props34)), owner, false);
  }
};
_root10 = new WeakMap();
_ref22 = new WeakMap();
_id22 = new WeakMap();
_disabled5 = new WeakMap();
_isDisabled6 = new WeakMap();
_onpointerdown5 = new WeakMap();
_onpointerup2 = new WeakMap();
_onkeydown8 = new WeakMap();
_props34 = new WeakMap();
var [
  setCollapsibleRootContext,
  getCollapsibleRootContext
] = createContext("Collapsible.Root");
function useCollapsibleRoot(props) {
  return setCollapsibleRootContext(new CollapsibleRootState(props));
}
function useCollapsibleTrigger(props) {
  const root17 = getCollapsibleRootContext();
  return new CollapsibleTriggerState(props, root17);
}
function useCollapsibleContent(props) {
  const root17 = getCollapsibleRootContext();
  return new CollapsibleContentState(props, root17);
}

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte
mark_module_start();
Collapsible[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte";
var root_229 = add_locations(template(`<div><!></div>`), Collapsible[FILENAME], [[46, 1]]);
function Collapsible($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Collapsible);
  validate_prop_bindings($$props, ["ref", "open"], [], Collapsible);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), open = prop($$props, "open", 15, false), disabled = prop($$props, "disabled", 3, false), controlledOpen = prop($$props, "controlledOpen", 3, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "open",
      "disabled",
      "controlledOpen",
      "onOpenChange"
    ],
    "restProps"
  );
  const rootState = useCollapsibleRoot({
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    }),
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_229();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible = hmr(Collapsible, () => Collapsible[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible[HMR].source;
    set(Collapsible[HMR].source, module.default[HMR].original);
  });
}
var collapsible_default = Collapsible;
mark_module_end(Collapsible);

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte
mark_module_start();
Collapsible_content[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte";
var root_33 = add_locations(template(`<div><!></div>`), Collapsible_content[FILENAME], [[38, 3]]);
function Collapsible_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Collapsible_content);
  validate_prop_bindings($$props, ["ref"], [], Collapsible_content);
  let ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "ref",
      "forceMount",
      "children",
      "id"
    ],
    "restProps"
  );
  const contentState = useCollapsibleContent({
    id: box.with(() => id()),
    forceMount: box.with(() => forceMount()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Collapsible_content, ($$anchor2, $$arg0) => {
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      const mergedProps = derived(() => mergeProps(restProps, contentState.props, {
        hidden: forceMount() ? void 0 : !present().current
      }));
      get(mergedProps);
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({
            ...contentState.snippetProps,
            props: get(mergedProps)
          }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var div = root_33();
          let attributes;
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
          append($$anchor3, div);
        }
      );
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      forceMount: true,
      get present() {
        return contentState.present;
      },
      get id() {
        return id();
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible_content = hmr(Collapsible_content, () => Collapsible_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible_content[HMR].source;
    set(Collapsible_content[HMR].source, module.default[HMR].original);
  });
}
var collapsible_content_default = Collapsible_content;
mark_module_end(Collapsible_content);

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte
mark_module_start();
Collapsible_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte";
var root_230 = add_locations(template(`<button><!></button>`), Collapsible_trigger[FILENAME], [[31, 1]]);
function Collapsible_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Collapsible_trigger);
  validate_prop_bindings($$props, ["ref"], [], Collapsible_trigger);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = useCollapsibleTrigger({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled())
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_230();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible_trigger = hmr(Collapsible_trigger, () => Collapsible_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible_trigger[HMR].source;
    set(Collapsible_trigger[HMR].source, module.default[HMR].original);
  });
}
var collapsible_trigger_default = Collapsible_trigger;
mark_module_end(Collapsible_trigger);

// node_modules/bits-ui/dist/bits/combobox/exports.js
var exports_exports9 = {};
__export(exports_exports9, {
  Arrow: () => arrow_default,
  Content: () => select_content_default,
  ContentStatic: () => select_content_static_default,
  Group: () => select_group_default,
  GroupHeading: () => select_group_heading_default,
  Input: () => combobox_input_default,
  Item: () => select_item_default,
  Portal: () => portal_default,
  Root: () => combobox_default,
  ScrollDownButton: () => select_scroll_down_button_default,
  ScrollUpButton: () => select_scroll_up_button_default,
  Separator: () => separator_default,
  Trigger: () => combobox_trigger_default,
  Viewport: () => select_viewport_default
});

// node_modules/bits-ui/dist/internal/floating-svelte/floating-utils.svelte.js
function get4(valueOrGetValue) {
  return strict_equals(typeof valueOrGetValue, "function") ? valueOrGetValue() : valueOrGetValue;
}
function getDPR(element2) {
  if (strict_equals(typeof window, "undefined")) return 1;
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function getFloatingContentCSSVars(name) {
  return {
    [`--bits-${name}-content-transform-origin`]: `var(--bits-floating-transform-origin)`,
    [`--bits-${name}-content-available-width`]: `var(--bits-floating-available-width)`,
    [`--bits-${name}-content-available-height`]: `var(--bits-floating-available-height)`,
    [`--bits-${name}-anchor-width`]: `var(--bits-floating-anchor-width)`,
    [`--bits-${name}-anchor-height`]: `var(--bits-floating-anchor-height)`
  };
}

// node_modules/bits-ui/dist/internal/floating-svelte/use-floating.svelte.js
function useFloating(options) {
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = derived(() => get4(options.open) ?? true);
  const middlewareOption = derived(() => get4(options.middleware));
  const transformOption = derived(() => get4(options.transform) ?? true);
  const placementOption = derived(() => get4(options.placement) ?? "bottom");
  const strategyOption = derived(() => get4(options.strategy) ?? "absolute");
  const reference = options.reference;
  let x = state(0);
  let y = state(0);
  const floating = box(null);
  let strategy = state(proxy(get(strategyOption)));
  let placement = state(proxy(get(placementOption)));
  let middlewareData = state(proxy({}));
  let isPositioned = state(false);
  const floatingStyles = derived(() => {
    const initialStyles = {
      position: get(strategy),
      left: "0",
      top: "0"
    };
    if (!floating.current) {
      return initialStyles;
    }
    const xVal = roundByDPR(floating.current, get(x));
    const yVal = roundByDPR(floating.current, get(y));
    if (get(transformOption)) {
      return {
        ...initialStyles,
        transform: `translate(${xVal}px, ${yVal}px)`,
        ...getDPR(floating.current) >= 1.5 && { willChange: "transform" }
      };
    }
    return {
      position: get(strategy),
      left: `${xVal}px`,
      top: `${yVal}px`
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
    computePosition(reference.current, floating.current, {
      middleware: get(middlewareOption),
      placement: get(placementOption),
      strategy: get(strategyOption)
    }).then((position) => {
      set(x, proxy(position.x, null, x));
      set(y, proxy(position.y, null, y));
      set(strategy, proxy(position.strategy, null, strategy));
      set(placement, proxy(position.placement, null, placement));
      set(middlewareData, proxy(position.middlewareData, null, middlewareData));
      set(isPositioned, true);
    });
  }
  function cleanup() {
    if (strict_equals(typeof whileElementsMountedCleanup, "function")) {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (strict_equals(whileElementsMountedOption, void 0)) {
      update();
      return;
    }
    if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
    whileElementsMountedCleanup = whileElementsMountedOption(reference.current, floating.current, update);
  }
  function reset2() {
    if (!get(openOption)) {
      set(isPositioned, false);
    }
  }
  user_effect(update);
  user_effect(attach);
  user_effect(reset2);
  user_effect(() => cleanup);
  return {
    floating,
    reference,
    get strategy() {
      return get(strategy);
    },
    get placement() {
      return get(placement);
    },
    get middlewareData() {
      return get(middlewareData);
    },
    get isPositioned() {
      return get(isPositioned);
    },
    get floatingStyles() {
      return get(floatingStyles);
    },
    get update() {
      return update;
    }
  };
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/useFloatingLayer.svelte.js
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var FloatingRootState = class {
  constructor() {
    __publicField(this, "anchorNode", box(null));
    __publicField(this, "customAnchorNode", box(null));
    __publicField(this, "triggerNode", box(null));
    user_effect(() => {
      if (this.customAnchorNode.current) {
        if (strict_equals(typeof this.customAnchorNode.current, "string")) {
          this.anchorNode.current = document.querySelector(this.customAnchorNode.current);
        } else {
          this.anchorNode.current = this.customAnchorNode.current;
        }
      } else {
        this.anchorNode.current = this.triggerNode.current;
      }
    });
  }
};
var _transformedStyle, _dir, _side, _sideOffset, _align, _alignOffset, _arrowPadding, _avoidCollisions, _collisionBoundary, _collisionPadding, _sticky, _hideWhenDetached, _strategy, _updatePositionStrategy, _arrowSize, _arrowWidth, _arrowHeight, _desiredPlacement, _boundary, _hasExplicitBoundaries, _detectOverflowOptions, _availableWidth, _availableHeight, _anchorWidth, _anchorHeight, _middleware, _placedSide, _placedAlign, _arrowX, _arrowY, _cannotCenterArrow, _contentZIndex, _arrowBaseSide, _wrapperProps2, _props35, _arrowStyle;
var FloatingContentState = class {
  constructor(props, root17) {
    // state
    __publicField(this, "root");
    // nodes
    __publicField(this, "contentRef", box(null));
    __publicField(this, "wrapperRef", box(null));
    __publicField(this, "arrowRef", box(null));
    // ids
    __publicField(this, "arrowId", box(useId()));
    __publicField(this, "id");
    __publicField(this, "wrapperId");
    __publicField(this, "style");
    __privateAdd(this, _transformedStyle, derived(() => {
      if (strict_equals(typeof this.style, "string")) return cssToStyleObj(this.style);
      if (!this.style) return {};
    }));
    __privateAdd(this, _dir);
    __privateAdd(this, _side);
    __privateAdd(this, _sideOffset);
    __privateAdd(this, _align);
    __privateAdd(this, _alignOffset);
    __privateAdd(this, _arrowPadding);
    __privateAdd(this, _avoidCollisions);
    __privateAdd(this, _collisionBoundary);
    __privateAdd(this, _collisionPadding);
    __privateAdd(this, _sticky);
    __privateAdd(this, _hideWhenDetached);
    __privateAdd(this, _strategy);
    __privateAdd(this, _updatePositionStrategy);
    __publicField(this, "onPlaced");
    __publicField(this, "enabled");
    __privateAdd(this, _arrowSize, new ElementSize(() => this.arrowRef.current ?? void 0));
    __privateAdd(this, _arrowWidth, derived(() => {
      var _a;
      return ((_a = __privateGet(this, _arrowSize)) == null ? void 0 : _a.width) ?? 0;
    }));
    __privateAdd(this, _arrowHeight, derived(() => {
      var _a;
      return ((_a = __privateGet(this, _arrowSize)) == null ? void 0 : _a.height) ?? 0;
    }));
    __privateAdd(this, _desiredPlacement, derived(() => {
      var _a;
      return ((_a = __privateGet(this, _side)) == null ? void 0 : _a.current) + (strict_equals(__privateGet(this, _align).current, "center", false) ? `-${__privateGet(this, _align).current}` : "");
    }));
    __privateAdd(this, _boundary, derived(() => Array.isArray(__privateGet(this, _collisionBoundary).current) ? __privateGet(this, _collisionBoundary).current : [__privateGet(this, _collisionBoundary).current]));
    __privateAdd(this, _hasExplicitBoundaries, derived(() => get(__privateGet(this, _boundary)).length > 0));
    __privateAdd(this, _detectOverflowOptions, derived(() => ({
      padding: __privateGet(this, _collisionPadding).current,
      boundary: get(__privateGet(this, _boundary)).filter(isNotNull),
      altBoundary: this.hasExplicitBoundaries
    })));
    __privateAdd(this, _availableWidth, state(void 0));
    __privateAdd(this, _availableHeight, state(void 0));
    __privateAdd(this, _anchorWidth, state(void 0));
    __privateAdd(this, _anchorHeight, state(void 0));
    __privateAdd(this, _middleware, derived(() => [
      offset({
        mainAxis: __privateGet(this, _sideOffset).current + get(__privateGet(this, _arrowHeight)),
        alignmentAxis: __privateGet(this, _alignOffset).current
      }),
      __privateGet(this, _avoidCollisions) && shift({
        mainAxis: true,
        crossAxis: false,
        limiter: strict_equals(__privateGet(this, _sticky).current, "partial") ? limitShift() : void 0,
        ...this.detectOverflowOptions
      }),
      __privateGet(this, _avoidCollisions) && flip({ ...this.detectOverflowOptions }),
      size({
        ...this.detectOverflowOptions,
        apply: ({ rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          set(__privateGet(this, _availableWidth), proxy(availableWidth, null, __privateGet(this, _availableWidth)));
          set(__privateGet(this, _availableHeight), proxy(availableHeight, null, __privateGet(this, _availableHeight)));
          set(__privateGet(this, _anchorWidth), proxy(anchorWidth, null, __privateGet(this, _anchorWidth)));
          set(__privateGet(this, _anchorHeight), proxy(anchorHeight, null, __privateGet(this, _anchorHeight)));
        }
      }),
      this.arrowRef.current && arrow({
        element: this.arrowRef.current,
        padding: __privateGet(this, _arrowPadding).current
      }),
      transformOrigin({
        arrowWidth: get(__privateGet(this, _arrowWidth)),
        arrowHeight: get(__privateGet(this, _arrowHeight))
      }),
      __privateGet(this, _hideWhenDetached).current && hide({
        strategy: "referenceHidden",
        ...this.detectOverflowOptions
      })
    ].filter(Boolean)));
    __publicField(this, "floating");
    __privateAdd(this, _placedSide, derived(() => getSideFromPlacement(this.floating.placement)));
    __privateAdd(this, _placedAlign, derived(() => getAlignFromPlacement(this.floating.placement)));
    __privateAdd(this, _arrowX, derived(() => {
      var _a;
      return ((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.x) ?? 0;
    }));
    __privateAdd(this, _arrowY, derived(() => {
      var _a;
      return ((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.y) ?? 0;
    }));
    __privateAdd(this, _cannotCenterArrow, derived(() => {
      var _a;
      return strict_equals((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.centerOffset, 0, false);
    }));
    __privateAdd(this, _contentZIndex, state());
    __privateAdd(this, _arrowBaseSide, derived(() => OPPOSITE_SIDE[this.placedSide]));
    __privateAdd(this, _wrapperProps2, derived(() => {
      var _a, _b, _c;
      return {
        id: this.wrapperId.current,
        "data-bits-floating-content-wrapper": "",
        style: {
          ...this.floating.floatingStyles,
          // keep off page when measuring
          transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: this.contentZIndex,
          "--bits-floating-transform-origin": `${(_a = this.floating.middlewareData.transformOrigin) == null ? void 0 : _a.x} ${(_b = this.floating.middlewareData.transformOrigin) == null ? void 0 : _b.y}`,
          "--bits-floating-available-width": `${get(__privateGet(this, _availableWidth))}px`,
          "--bits-floating-available-height": `${get(__privateGet(this, _availableHeight))}px`,
          "--bits-floating-anchor-width": `${get(__privateGet(this, _anchorWidth))}px`,
          "--bits-floating-anchor-height": `${get(__privateGet(this, _anchorHeight))}px`,
          // hide the content if using the hide middleware and should be hidden
          ...((_c = this.floating.middlewareData.hide) == null ? void 0 : _c.referenceHidden) && {
            visibility: "hidden",
            "pointer-events": "none"
          },
          ...get(__privateGet(this, _transformedStyle))
        },
        // Floating UI calculates logical alignment based the `dir` attribute
        dir: __privateGet(this, _dir).current
      };
    }));
    __privateAdd(this, _props35, derived(() => ({
      "data-side": this.placedSide,
      "data-align": this.placedAlign,
      style: styleToString({
        ...get(__privateGet(this, _transformedStyle))
        // if the FloatingContent hasn't been placed yet (not all measurements done)
      })
    })));
    __privateAdd(this, _arrowStyle, derived(() => ({
      position: "absolute",
      left: this.arrowX ? `${this.arrowX}px` : void 0,
      top: this.arrowY ? `${this.arrowY}px` : void 0,
      [this.arrowBaseSide]: 0,
      "transform-origin": {
        top: "",
        right: "0 0",
        bottom: "center 0",
        left: "100% 0"
      }[this.placedSide],
      transform: {
        top: "translateY(100%)",
        right: "translateY(50%) rotate(90deg) translateX(-50%)",
        bottom: "rotate(180deg)",
        left: "translateY(50%) rotate(-90deg) translateX(50%)"
      }[this.placedSide],
      visibility: this.cannotCenterArrow ? "hidden" : void 0
    })));
    this.id = props.id;
    __privateSet(this, _side, props.side);
    __privateSet(this, _sideOffset, props.sideOffset);
    __privateSet(this, _align, props.align);
    __privateSet(this, _alignOffset, props.alignOffset);
    __privateSet(this, _arrowPadding, props.arrowPadding);
    __privateSet(this, _avoidCollisions, props.avoidCollisions);
    __privateSet(this, _collisionBoundary, props.collisionBoundary);
    __privateSet(this, _collisionPadding, props.collisionPadding);
    __privateSet(this, _sticky, props.sticky);
    __privateSet(this, _hideWhenDetached, props.hideWhenDetached);
    __privateSet(this, _updatePositionStrategy, props.updatePositionStrategy);
    this.onPlaced = props.onPlaced;
    __privateSet(this, _strategy, props.strategy);
    __privateSet(this, _dir, props.dir);
    this.style = props.style;
    this.root = root17;
    this.enabled = props.enabled;
    this.wrapperId = props.wrapperId;
    if (props.customAnchor) {
      this.root.customAnchorNode.current = props.customAnchor.current;
    }
    user_effect(() => {
      props.customAnchor.current;
      untrack(() => {
        this.root.customAnchorNode.current = props.customAnchor.current;
      });
    });
    useRefById({
      id: this.wrapperId,
      ref: this.wrapperRef,
      deps: () => this.enabled.current
    });
    useRefById({
      id: this.id,
      ref: this.contentRef,
      deps: () => this.enabled.current
    });
    this.floating = useFloating({
      strategy: () => __privateGet(this, _strategy).current,
      placement: () => get(__privateGet(this, _desiredPlacement)),
      middleware: () => this.middleware,
      reference: this.root.anchorNode,
      whileElementsMounted: (...args) => {
        var _a;
        const cleanup = autoUpdate(...args, {
          animationFrame: strict_equals((_a = __privateGet(this, _updatePositionStrategy)) == null ? void 0 : _a.current, "always")
        });
        return cleanup;
      },
      open: () => this.enabled.current
    });
    user_effect(() => {
      var _a;
      if (!this.floating.isPositioned) return;
      (_a = this.onPlaced) == null ? void 0 : _a.current();
    });
    user_effect(() => {
      const contentNode = this.contentRef.current;
      if (!contentNode) return;
      untrack(() => {
        this.contentZIndex = window.getComputedStyle(contentNode).zIndex;
      });
    });
    user_effect(() => {
      this.floating.floating.current = this.wrapperRef.current;
    });
  }
  get hasExplicitBoundaries() {
    return get(__privateGet(this, _hasExplicitBoundaries));
  }
  set hasExplicitBoundaries(_) {
    throw new Error("Cannot update a derived property ('hasExplicitBoundaries')");
  }
  get detectOverflowOptions() {
    return get(__privateGet(this, _detectOverflowOptions));
  }
  set detectOverflowOptions(_) {
    throw new Error("Cannot update a derived property ('detectOverflowOptions')");
  }
  get middleware() {
    return get(__privateGet(this, _middleware));
  }
  set middleware(_) {
    throw new Error("Cannot update a derived property ('middleware')");
  }
  get placedSide() {
    return get(__privateGet(this, _placedSide));
  }
  set placedSide(_) {
    throw new Error("Cannot update a derived property ('placedSide')");
  }
  get placedAlign() {
    return get(__privateGet(this, _placedAlign));
  }
  set placedAlign(_) {
    throw new Error("Cannot update a derived property ('placedAlign')");
  }
  get arrowX() {
    return get(__privateGet(this, _arrowX));
  }
  set arrowX(_) {
    throw new Error("Cannot update a derived property ('arrowX')");
  }
  get arrowY() {
    return get(__privateGet(this, _arrowY));
  }
  set arrowY(_) {
    throw new Error("Cannot update a derived property ('arrowY')");
  }
  get cannotCenterArrow() {
    return get(__privateGet(this, _cannotCenterArrow));
  }
  set cannotCenterArrow(_) {
    throw new Error("Cannot update a derived property ('cannotCenterArrow')");
  }
  get contentZIndex() {
    return get(__privateGet(this, _contentZIndex));
  }
  set contentZIndex(value) {
    set(__privateGet(this, _contentZIndex), proxy(value, null, __privateGet(this, _contentZIndex)));
  }
  get arrowBaseSide() {
    return get(__privateGet(this, _arrowBaseSide));
  }
  set arrowBaseSide(_) {
    throw new Error("Cannot update a derived property ('arrowBaseSide')");
  }
  get wrapperProps() {
    return get(__privateGet(this, _wrapperProps2));
  }
  set wrapperProps(_) {
    throw new Error("Cannot update a derived property ('wrapperProps')");
  }
  get props() {
    return get(__privateGet(this, _props35));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  get arrowStyle() {
    return get(__privateGet(this, _arrowStyle));
  }
  set arrowStyle(_) {
    throw new Error("Cannot update a derived property ('arrowStyle')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _hasExplicitBoundaries)), owner, false);
    add_owner(get(__privateGet(this, _detectOverflowOptions)), owner, false);
    add_owner(get(__privateGet(this, _middleware)), owner, false);
    add_owner(get(__privateGet(this, _placedSide)), owner, false);
    add_owner(get(__privateGet(this, _placedAlign)), owner, false);
    add_owner(get(__privateGet(this, _arrowX)), owner, false);
    add_owner(get(__privateGet(this, _arrowY)), owner, false);
    add_owner(get(__privateGet(this, _cannotCenterArrow)), owner, false);
    add_owner(get(__privateGet(this, _contentZIndex)), owner, false);
    add_owner(get(__privateGet(this, _arrowBaseSide)), owner, false);
    add_owner(get(__privateGet(this, _wrapperProps2)), owner, false);
    add_owner(get(__privateGet(this, _props35)), owner, false);
    add_owner(get(__privateGet(this, _arrowStyle)), owner, false);
  }
};
_transformedStyle = new WeakMap();
_dir = new WeakMap();
_side = new WeakMap();
_sideOffset = new WeakMap();
_align = new WeakMap();
_alignOffset = new WeakMap();
_arrowPadding = new WeakMap();
_avoidCollisions = new WeakMap();
_collisionBoundary = new WeakMap();
_collisionPadding = new WeakMap();
_sticky = new WeakMap();
_hideWhenDetached = new WeakMap();
_strategy = new WeakMap();
_updatePositionStrategy = new WeakMap();
_arrowSize = new WeakMap();
_arrowWidth = new WeakMap();
_arrowHeight = new WeakMap();
_desiredPlacement = new WeakMap();
_boundary = new WeakMap();
_hasExplicitBoundaries = new WeakMap();
_detectOverflowOptions = new WeakMap();
_availableWidth = new WeakMap();
_availableHeight = new WeakMap();
_anchorWidth = new WeakMap();
_anchorHeight = new WeakMap();
_middleware = new WeakMap();
_placedSide = new WeakMap();
_placedAlign = new WeakMap();
_arrowX = new WeakMap();
_arrowY = new WeakMap();
_cannotCenterArrow = new WeakMap();
_contentZIndex = new WeakMap();
_arrowBaseSide = new WeakMap();
_wrapperProps2 = new WeakMap();
_props35 = new WeakMap();
_arrowStyle = new WeakMap();
var _id23, _ref23, _content, _props36;
var FloatingArrowState = class {
  constructor(props, content) {
    __privateAdd(this, _id23);
    __privateAdd(this, _ref23);
    __privateAdd(this, _content);
    __privateAdd(this, _props36, derived(() => ({
      id: __privateGet(this, _id23).current,
      style: __privateGet(this, _content).arrowStyle,
      "data-side": __privateGet(this, _content).placedSide
    })));
    __privateSet(this, _content, content);
    __privateSet(this, _id23, props.id);
    __privateSet(this, _ref23, props.ref);
    useRefById({
      id: __privateGet(this, _id23),
      ref: __privateGet(this, _ref23),
      onRefChange: (node) => {
        __privateGet(this, _content).arrowRef.current = node;
      },
      deps: () => __privateGet(this, _content).enabled.current
    });
  }
  get props() {
    return get(__privateGet(this, _props36));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props36)), owner, false);
  }
};
_id23 = new WeakMap();
_ref23 = new WeakMap();
_content = new WeakMap();
_props36 = new WeakMap();
var FloatingAnchorState = class {
  constructor(props, root17) {
    __publicField(this, "ref", box(null));
    if (props.virtualEl && props.virtualEl.current) {
      root17.triggerNode = box.from(props.virtualEl.current);
    } else {
      useRefById({
        id: props.id,
        ref: this.ref,
        onRefChange: (node) => {
          root17.triggerNode.current = node;
        }
      });
    }
  }
};
var [
  setFloatingRootContext,
  getFloatingRootContext
] = createContext("Floating.Root");
var [
  setFloatingContentContext,
  getFloatingContentContext
] = createContext("Floating.Content");
function useFloatingRootState() {
  return setFloatingRootContext(new FloatingRootState());
}
function useFloatingContentState(props) {
  return setFloatingContentContext(new FloatingContentState(props, getFloatingRootContext()));
}
function useFloatingArrowState(props) {
  return new FloatingArrowState(props, getFloatingContentContext());
}
function useFloatingAnchorState(props) {
  return new FloatingAnchorState(props, getFloatingRootContext());
}
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      var _a, _b, _c;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = strict_equals((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset, 0, false);
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
      const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (strict_equals(placedSide, "bottom")) {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (strict_equals(placedSide, "top")) {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (strict_equals(placedSide, "right")) {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (strict_equals(placedSide, "left")) {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function getSideFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[0];
}
function getAlignFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[1];
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte
mark_module_start();
Floating_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte";
function Floating_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer);
  validate_prop_bindings($$props, [], [], Floating_layer);
  useFloatingRootState();
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer = hmr(Floating_layer, () => Floating_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer[HMR].source;
    set(Floating_layer[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_default = Floating_layer;
mark_module_end(Floating_layer);

// node_modules/bits-ui/dist/internal/box-auto-reset.svelte.js
function boxAutoReset(defaultValue, afterMs = 1e4) {
  let timeout = null;
  let value = state(proxy(defaultValue));
  function resetAfter() {
    return setTimeout(
      () => {
        set(value, proxy(defaultValue, null, value));
      },
      afterMs
    );
  }
  user_effect(() => {
    return () => {
      if (timeout) clearTimeout(timeout);
    };
  });
  return box.with(() => get(value), (v) => {
    set(value, proxy(v, null, value));
    if (timeout) clearTimeout(timeout);
    timeout = resetAfter();
  });
}

// node_modules/bits-ui/dist/internal/use-dom-typeahead.svelte.js
function useDOMTypeahead(opts) {
  const search = boxAutoReset("", 1e3);
  const onMatch = (opts == null ? void 0 : opts.onMatch) ?? ((node) => node.focus());
  const getCurrentItem = (opts == null ? void 0 : opts.getCurrentItem) ?? (() => document.activeElement);
  function handleTypeaheadSearch(key, candidates) {
    var _a, _b;
    if (!candidates.length) return;
    search.current = search.current + key;
    const currentItem = getCurrentItem();
    const currentMatch = ((_b = (_a = candidates.find((item) => strict_equals(item, currentItem))) == null ? void 0 : _a.textContent) == null ? void 0 : _b.trim()) ?? "";
    const values = candidates.map((item) => {
      var _a2;
      return ((_a2 = item.textContent) == null ? void 0 : _a2.trim()) ?? "";
    });
    const nextMatch = getNextMatch(values, search.current, currentMatch);
    const newItem = candidates.find((item) => {
      var _a2;
      return strict_equals((_a2 = item.textContent) == null ? void 0 : _a2.trim(), nextMatch);
    });
    if (newItem) {
      onMatch(newItem);
    }
    return newItem;
  }
  function resetTypeahead() {
    search.current = "";
  }
  return {
    search,
    handleTypeaheadSearch,
    resetTypeahead
  };
}

// node_modules/bits-ui/dist/internal/use-data-typeahead.svelte.js
function useDataTypeahead(opts) {
  const search = boxAutoReset("", 1e3);
  function handleTypeaheadSearch(key, candidateValues) {
    if (!opts.enabled) return;
    if (!candidateValues.length) return;
    search.current = search.current + key;
    const currentItem = opts.getCurrentItem();
    const currentMatch = candidateValues.find((item) => strict_equals(item, currentItem)) ?? "";
    const values = candidateValues.map((item) => item ?? "");
    const nextMatch = getNextMatch(values, search.current, currentMatch);
    const newItem = candidateValues.find((item) => strict_equals(item, nextMatch));
    if (newItem) {
      opts.onMatch(newItem);
    }
    return newItem;
  }
  function resetTypeahead() {
    search.current = "";
  }
  return {
    search,
    handleTypeaheadSearch,
    resetTypeahead
  };
}

// node_modules/bits-ui/dist/bits/select/select.svelte.js
var INTERACTION_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ESCAPE,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.SHIFT,
  kbd_constants_exports.CAPS_LOCK,
  kbd_constants_exports.CONTROL,
  kbd_constants_exports.ALT,
  kbd_constants_exports.META,
  kbd_constants_exports.ENTER,
  kbd_constants_exports.F1,
  kbd_constants_exports.F2,
  kbd_constants_exports.F3,
  kbd_constants_exports.F4,
  kbd_constants_exports.F5,
  kbd_constants_exports.F6,
  kbd_constants_exports.F7,
  kbd_constants_exports.F8,
  kbd_constants_exports.F9,
  kbd_constants_exports.F10,
  kbd_constants_exports.F11,
  kbd_constants_exports.F12
];
var FIRST_KEYS2 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS2 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS2 = [...FIRST_KEYS2, ...LAST_KEYS2];
var SELECTION_KEYS2 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var _touchedInput, _inputValue, _inputNode, _contentNode3, _triggerNode2, _valueId, _highlightedNode, _highlightedValue, _highlightedId, _highlightedLabel, _isUsingKeyboard, _isCombobox, _triggerPointerDownPos;
var SelectBaseRootState = class {
  constructor(props) {
    __publicField(this, "disabled");
    __publicField(this, "required");
    __publicField(this, "name");
    __publicField(this, "loop");
    __publicField(this, "open");
    __publicField(this, "scrollAlignment");
    __publicField(this, "items");
    __publicField(this, "allowDeselect");
    __privateAdd(this, _touchedInput, state(false));
    __privateAdd(this, _inputValue, state(""));
    __privateAdd(this, _inputNode, state(null));
    __privateAdd(this, _contentNode3, state(null));
    __privateAdd(this, _triggerNode2, state(null));
    __privateAdd(this, _valueId, state(""));
    __privateAdd(this, _highlightedNode, state(null));
    __privateAdd(this, _highlightedValue, derived(() => {
      if (!this.highlightedNode) return null;
      return this.highlightedNode.getAttribute("data-value");
    }));
    __privateAdd(this, _highlightedId, derived(() => {
      if (!this.highlightedNode) return void 0;
      return this.highlightedNode.id;
    }));
    __privateAdd(this, _highlightedLabel, derived(() => {
      if (!this.highlightedNode) return null;
      return this.highlightedNode.getAttribute("data-label");
    }));
    __privateAdd(this, _isUsingKeyboard, state(false));
    __privateAdd(this, _isCombobox, state(false));
    __publicField(this, "bitsAttrs");
    __privateAdd(this, _triggerPointerDownPos, state({ x: 0, y: 0 }));
    __publicField(this, "setHighlightedNode", (node) => {
      this.highlightedNode = node;
      if (node) {
        if (this.isUsingKeyboard) {
          node.scrollIntoView({ block: "nearest" });
        }
      }
    });
    __publicField(this, "getCandidateNodes", () => {
      const node = this.contentNode;
      if (!node) return [];
      const nodes = Array.from(node.querySelectorAll(`[${this.bitsAttrs.item}]:not([data-disabled])`));
      return nodes;
    });
    __publicField(this, "setHighlightedToFirstCandidate", () => {
      this.setHighlightedNode(null);
      const candidateNodes = this.getCandidateNodes();
      if (!candidateNodes.length) return;
      this.setHighlightedNode(candidateNodes[0]);
    });
    __publicField(this, "getNodeByValue", (value) => {
      const candidateNodes = this.getCandidateNodes();
      return candidateNodes.find((node) => strict_equals(node.dataset.value, value)) ?? null;
    });
    __publicField(this, "setOpen", (open) => {
      this.open.current = open;
    });
    __publicField(this, "toggleOpen", () => {
      this.open.current = !this.open.current;
    });
    __publicField(this, "handleOpen", () => {
      this.setOpen(true);
    });
    __publicField(this, "handleClose", () => {
      this.setHighlightedNode(null);
      this.setOpen(false);
    });
    __publicField(this, "toggleMenu", () => {
      this.toggleOpen();
    });
    this.disabled = props.disabled;
    this.required = props.required;
    this.name = props.name;
    this.loop = props.loop;
    this.open = props.open;
    this.scrollAlignment = props.scrollAlignment;
    this.isCombobox = props.isCombobox;
    this.items = props.items;
    this.allowDeselect = props.allowDeselect;
    this.bitsAttrs = getSelectBitsAttrs(this);
    user_pre_effect(() => {
      if (!this.open.current) {
        this.setHighlightedNode(null);
      }
    });
  }
  get touchedInput() {
    return get(__privateGet(this, _touchedInput));
  }
  set touchedInput(value) {
    set(__privateGet(this, _touchedInput), proxy(value, null, __privateGet(this, _touchedInput)));
  }
  get inputValue() {
    return get(__privateGet(this, _inputValue));
  }
  set inputValue(value) {
    set(__privateGet(this, _inputValue), proxy(value, null, __privateGet(this, _inputValue)));
  }
  get inputNode() {
    return get(__privateGet(this, _inputNode));
  }
  set inputNode(value) {
    set(__privateGet(this, _inputNode), proxy(value, null, __privateGet(this, _inputNode)));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode3));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode3), proxy(value, null, __privateGet(this, _contentNode3)));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode2));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode2), proxy(value, null, __privateGet(this, _triggerNode2)));
  }
  get valueId() {
    return get(__privateGet(this, _valueId));
  }
  set valueId(value) {
    set(__privateGet(this, _valueId), proxy(value, null, __privateGet(this, _valueId)));
  }
  get highlightedNode() {
    return get(__privateGet(this, _highlightedNode));
  }
  set highlightedNode(value) {
    set(__privateGet(this, _highlightedNode), proxy(value, null, __privateGet(this, _highlightedNode)));
  }
  get highlightedValue() {
    return get(__privateGet(this, _highlightedValue));
  }
  set highlightedValue(_) {
    throw new Error("Cannot update a derived property ('highlightedValue')");
  }
  get highlightedId() {
    return get(__privateGet(this, _highlightedId));
  }
  set highlightedId(_) {
    throw new Error("Cannot update a derived property ('highlightedId')");
  }
  get highlightedLabel() {
    return get(__privateGet(this, _highlightedLabel));
  }
  set highlightedLabel(_) {
    throw new Error("Cannot update a derived property ('highlightedLabel')");
  }
  get isUsingKeyboard() {
    return get(__privateGet(this, _isUsingKeyboard));
  }
  set isUsingKeyboard(value) {
    set(__privateGet(this, _isUsingKeyboard), proxy(value, null, __privateGet(this, _isUsingKeyboard)));
  }
  get isCombobox() {
    return get(__privateGet(this, _isCombobox));
  }
  set isCombobox(value) {
    set(__privateGet(this, _isCombobox), proxy(value, null, __privateGet(this, _isCombobox)));
  }
  get triggerPointerDownPos() {
    return get(__privateGet(this, _triggerPointerDownPos));
  }
  set triggerPointerDownPos(value) {
    set(__privateGet(this, _triggerPointerDownPos), value);
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _touchedInput)), owner, false);
    add_owner(get(__privateGet(this, _inputValue)), owner, false);
    add_owner(get(__privateGet(this, _inputNode)), owner, false);
    add_owner(get(__privateGet(this, _contentNode3)), owner, false);
    add_owner(get(__privateGet(this, _triggerNode2)), owner, false);
    add_owner(get(__privateGet(this, _valueId)), owner, false);
    add_owner(get(__privateGet(this, _highlightedNode)), owner, false);
    add_owner(get(__privateGet(this, _highlightedValue)), owner, false);
    add_owner(get(__privateGet(this, _highlightedId)), owner, false);
    add_owner(get(__privateGet(this, _highlightedLabel)), owner, false);
    add_owner(get(__privateGet(this, _isUsingKeyboard)), owner, false);
    add_owner(get(__privateGet(this, _isCombobox)), owner, false);
    add_owner(get(__privateGet(this, _triggerPointerDownPos)), owner, false);
  }
};
_touchedInput = new WeakMap();
_inputValue = new WeakMap();
_inputNode = new WeakMap();
_contentNode3 = new WeakMap();
_triggerNode2 = new WeakMap();
_valueId = new WeakMap();
_highlightedNode = new WeakMap();
_highlightedValue = new WeakMap();
_highlightedId = new WeakMap();
_highlightedLabel = new WeakMap();
_isUsingKeyboard = new WeakMap();
_isCombobox = new WeakMap();
_triggerPointerDownPos = new WeakMap();
var _hasValue, _currentLabel, _candidateLabels, _dataTypeaheadEnabled;
var SelectSingleRootState = class extends SelectBaseRootState {
  constructor(props) {
    super(props);
    __publicField(this, "value");
    __publicField(this, "isMulti", false);
    __privateAdd(this, _hasValue, derived(() => strict_equals(this.value.current, "", false)));
    __privateAdd(this, _currentLabel, derived(() => {
      var _a;
      if (!this.items.current.length) return "";
      const match = (_a = this.items.current.find((item) => strict_equals(item.value, this.value.current))) == null ? void 0 : _a.label;
      return match ?? "";
    }));
    __privateAdd(this, _candidateLabels, derived(() => {
      if (!this.items.current.length) return [];
      const filteredItems = this.items.current.filter((item) => !item.disabled);
      return filteredItems.map((item) => item.label);
    }));
    __privateAdd(this, _dataTypeaheadEnabled, derived(() => {
      if (this.isMulti) return false;
      if (strict_equals(this.items.current.length, 0)) return false;
      return true;
    }));
    __publicField(this, "includesItem", (itemValue) => {
      return strict_equals(this.value.current, itemValue);
    });
    __publicField(this, "toggleItem", (itemValue, itemLabel = itemValue) => {
      this.value.current = this.includesItem(itemValue) ? "" : itemValue;
      this.inputValue = itemLabel;
    });
    __publicField(this, "setInitialHighlightedNode", () => {
      if (this.highlightedNode && document.contains(this.highlightedNode)) return;
      if (strict_equals(this.value.current, "", false)) {
        const node = this.getNodeByValue(this.value.current);
        if (node) {
          this.setHighlightedNode(node);
          return;
        }
      }
      const firstCandidate = this.getCandidateNodes()[0];
      if (!firstCandidate) return;
      this.setHighlightedNode(firstCandidate);
    });
    this.value = props.value;
    user_effect(() => {
      if (!this.open.current && this.highlightedNode) {
        this.setHighlightedNode(null);
      }
    });
    user_effect(() => {
      if (!this.open.current) return;
      afterTick(() => {
        this.setInitialHighlightedNode();
      });
    });
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue));
  }
  set hasValue(_) {
    throw new Error("Cannot update a derived property ('hasValue')");
  }
  get currentLabel() {
    return get(__privateGet(this, _currentLabel));
  }
  set currentLabel(_) {
    throw new Error("Cannot update a derived property ('currentLabel')");
  }
  get candidateLabels() {
    return get(__privateGet(this, _candidateLabels));
  }
  set candidateLabels(_) {
    throw new Error("Cannot update a derived property ('candidateLabels')");
  }
  get dataTypeaheadEnabled() {
    return get(__privateGet(this, _dataTypeaheadEnabled));
  }
  set dataTypeaheadEnabled(_) {
    throw new Error("Cannot update a derived property ('dataTypeaheadEnabled')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _hasValue)), owner, false);
    add_owner(get(__privateGet(this, _currentLabel)), owner, false);
    add_owner(get(__privateGet(this, _candidateLabels)), owner, false);
    add_owner(get(__privateGet(this, _dataTypeaheadEnabled)), owner, false);
  }
};
_hasValue = new WeakMap();
_currentLabel = new WeakMap();
_candidateLabels = new WeakMap();
_dataTypeaheadEnabled = new WeakMap();
var _hasValue2;
var SelectMultipleRootState = class extends SelectBaseRootState {
  constructor(props) {
    super(props);
    __publicField(this, "value");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _hasValue2, derived(() => this.value.current.length > 0));
    __publicField(this, "includesItem", (itemValue) => {
      return this.value.current.includes(itemValue);
    });
    __publicField(this, "toggleItem", (itemValue, itemLabel = itemValue) => {
      if (this.includesItem(itemValue)) {
        this.value.current = this.value.current.filter((v) => strict_equals(v, itemValue, false));
      } else {
        this.value.current = [...this.value.current, itemValue];
      }
      this.inputValue = itemLabel;
    });
    __publicField(this, "setInitialHighlightedNode", () => {
      if (this.highlightedNode) return;
      if (this.value.current.length && strict_equals(this.value.current[0], "", false)) {
        const node = this.getNodeByValue(this.value.current[0]);
        if (node) {
          this.setHighlightedNode(node);
          return;
        }
      }
      const firstCandidate = this.getCandidateNodes()[0];
      if (!firstCandidate) return;
      this.setHighlightedNode(firstCandidate);
    });
    this.value = props.value;
    user_effect(() => {
      if (!this.open.current) return;
      afterTick(() => {
        if (!this.highlightedNode) {
          this.setInitialHighlightedNode();
        }
      });
    });
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue2));
  }
  set hasValue(_) {
    throw new Error("Cannot update a derived property ('hasValue')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _hasValue2)), owner, false);
  }
};
_hasValue2 = new WeakMap();
var _id24, _ref24, _onkeydown9, _oninput, _props37;
var SelectInputState = class {
  constructor(props, root17) {
    __privateAdd(this, _id24);
    __privateAdd(this, _ref24);
    __publicField(this, "root");
    __privateAdd(this, _onkeydown9, async (e) => {
      this.root.isUsingKeyboard = true;
      if (strict_equals(e.key, kbd_constants_exports.ESCAPE)) return;
      const open = this.root.open.current;
      const inputValue = this.root.inputValue;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) e.preventDefault();
      if (!open) {
        if (INTERACTION_KEYS.includes(e.key)) return;
        if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
        if (strict_equals(e.key, kbd_constants_exports.BACKSPACE) && strict_equals(inputValue, "")) return;
        this.root.handleOpen();
        afterTick(() => {
          if (this.root.hasValue) return;
          const candidateNodes = this.root.getCandidateNodes();
          if (!candidateNodes.length) return;
          if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
            const firstCandidate = candidateNodes[0];
            this.root.setHighlightedNode(firstCandidate);
          } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
            const lastCandidate = candidateNodes[candidateNodes.length - 1];
            this.root.setHighlightedNode(lastCandidate);
          }
        });
        return;
      }
      if (strict_equals(e.key, kbd_constants_exports.TAB)) {
        this.root.handleClose();
        return;
      }
      if (strict_equals(e.key, kbd_constants_exports.ENTER) && !e.isComposing) {
        e.preventDefault();
        const highlightedValue = this.root.highlightedValue;
        const isCurrentSelectedValue = strict_equals(highlightedValue, this.root.value.current);
        if (!this.root.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
          this.root.handleClose();
          return;
        }
        if (highlightedValue) {
          this.root.toggleItem(highlightedValue, this.root.highlightedLabel ?? void 0);
        }
        if (!this.root.isMulti && !isCurrentSelectedValue) {
          this.root.handleClose();
        }
      }
      if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) && e.altKey) {
        this.root.handleClose();
      }
      if (FIRST_LAST_KEYS2.includes(e.key)) {
        e.preventDefault();
        const candidateNodes = this.root.getCandidateNodes();
        const currHighlightedNode = this.root.highlightedNode;
        const currIndex = currHighlightedNode ? candidateNodes.indexOf(currHighlightedNode) : -1;
        const loop = this.root.loop.current;
        let nextItem;
        if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
          nextItem = next2(candidateNodes, currIndex, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
          nextItem = prev(candidateNodes, currIndex, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.PAGE_DOWN)) {
          nextItem = forward(candidateNodes, currIndex, 10, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.PAGE_UP)) {
          nextItem = backward(candidateNodes, currIndex, 10, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.HOME)) {
          nextItem = candidateNodes[0];
        } else if (strict_equals(e.key, kbd_constants_exports.END)) {
          nextItem = candidateNodes[candidateNodes.length - 1];
        }
        if (!nextItem) return;
        this.root.setHighlightedNode(nextItem);
        return;
      }
      if (INTERACTION_KEYS.includes(e.key)) return;
      if (!this.root.highlightedNode) {
        this.root.setHighlightedToFirstCandidate();
      }
    });
    __privateAdd(this, _oninput, (e) => {
      this.root.inputValue = e.currentTarget.value;
      afterTick(() => {
        this.root.setHighlightedToFirstCandidate();
      });
    });
    __privateAdd(this, _props37, derived(() => ({
      id: __privateGet(this, _id24).current,
      role: "combobox",
      disabled: this.root.disabled.current ? true : void 0,
      "aria-activedescendant": this.root.highlightedId,
      "aria-autocomplete": "list",
      "aria-expanded": getAriaExpanded(this.root.open.current),
      "data-state": getDataOpenClosed(this.root.open.current),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      onkeydown: __privateGet(this, _onkeydown9),
      oninput: __privateGet(this, _oninput),
      [this.root.bitsAttrs.input]: ""
    })));
    this.root = root17;
    __privateSet(this, _id24, props.id);
    __privateSet(this, _ref24, props.ref);
    useRefById({
      id: __privateGet(this, _id24),
      ref: __privateGet(this, _ref24),
      onRefChange: (node) => {
        this.root.inputNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props37));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props37)), owner, false);
  }
};
_id24 = new WeakMap();
_ref24 = new WeakMap();
_onkeydown9 = new WeakMap();
_oninput = new WeakMap();
_props37 = new WeakMap();
var _id25, _ref25, _onkeydown10, _onpointerdown6, _props38;
var SelectComboTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _id25);
    __privateAdd(this, _ref25);
    __publicField(this, "root");
    __privateAdd(this, _onkeydown10, (e) => {
      var _a;
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
        e.preventDefault();
        if (strict_equals(document.activeElement, this.root.inputNode, false)) {
          (_a = this.root.inputNode) == null ? void 0 : _a.focus();
        }
        this.root.toggleMenu();
      }
    });
    /**
     * `pointerdown` fires before the `focus` event, so we can prevent the default
     * behavior of focusing the button and keep focus on the input.
     */
    __privateAdd(this, _onpointerdown6, (e) => {
      var _a;
      if (this.root.disabled.current) return;
      e.preventDefault();
      if (strict_equals(document.activeElement, this.root.inputNode, false)) {
        (_a = this.root.inputNode) == null ? void 0 : _a.focus();
      }
      this.root.toggleMenu();
    });
    __privateAdd(this, _props38, derived(() => ({
      id: __privateGet(this, _id25).current,
      disabled: this.root.disabled.current ? true : void 0,
      "aria-haspopup": "listbox",
      "data-state": getDataOpenClosed(this.root.open.current),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      [this.root.bitsAttrs.trigger]: "",
      onpointerdown: __privateGet(this, _onpointerdown6),
      onkeydown: __privateGet(this, _onkeydown10)
    })));
    this.root = root17;
    __privateSet(this, _id25, props.id);
    __privateSet(this, _ref25, props.ref);
    useRefById({ id: __privateGet(this, _id25), ref: __privateGet(this, _ref25) });
  }
  get props() {
    return get(__privateGet(this, _props38));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props38)), owner, false);
  }
};
_id25 = new WeakMap();
_ref25 = new WeakMap();
_onkeydown10 = new WeakMap();
_onpointerdown6 = new WeakMap();
_props38 = new WeakMap();
var _id26, _ref26, _domTypeahead, _dataTypeahead, _onkeydown11, _handleOpen, _handlePointerOpen, _onclick8, _onpointerdown7, _onpointerup3, _props39;
var SelectTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _id26);
    __privateAdd(this, _ref26);
    __publicField(this, "root");
    __privateAdd(this, _domTypeahead);
    __privateAdd(this, _dataTypeahead);
    __privateAdd(this, _onkeydown11, (e) => {
      this.root.isUsingKeyboard = true;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) e.preventDefault();
      if (!this.root.open.current) {
        if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN) || strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
          e.preventDefault();
          this.root.handleOpen();
        } else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) {
          __privateGet(this, _dataTypeahead).handleTypeaheadSearch(e.key, this.root.candidateLabels);
          return;
        }
        afterTick(() => {
          if (this.root.hasValue) return;
          const candidateNodes2 = this.root.getCandidateNodes();
          if (!candidateNodes2.length) return;
          if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
            const firstCandidate = candidateNodes2[0];
            this.root.setHighlightedNode(firstCandidate);
          } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
            const lastCandidate = candidateNodes2[candidateNodes2.length - 1];
            this.root.setHighlightedNode(lastCandidate);
          }
        });
        return;
      }
      if (strict_equals(e.key, kbd_constants_exports.TAB)) {
        this.root.handleClose();
        return;
      }
      if ((strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) && !e.isComposing) {
        e.preventDefault();
        const highlightedValue = this.root.highlightedValue;
        const isCurrentSelectedValue = strict_equals(highlightedValue, this.root.value.current);
        if (!this.root.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
          this.root.handleClose();
          return;
        }
        if (highlightedValue) {
          this.root.toggleItem(highlightedValue, this.root.highlightedLabel ?? void 0);
        }
        if (!this.root.isMulti && !isCurrentSelectedValue) {
          this.root.handleClose();
        }
      }
      if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) && e.altKey) {
        this.root.handleClose();
      }
      if (FIRST_LAST_KEYS2.includes(e.key)) {
        e.preventDefault();
        const candidateNodes2 = this.root.getCandidateNodes();
        const currHighlightedNode = this.root.highlightedNode;
        const currIndex = currHighlightedNode ? candidateNodes2.indexOf(currHighlightedNode) : -1;
        const loop = this.root.loop.current;
        let nextItem;
        if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
          nextItem = next2(candidateNodes2, currIndex, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
          nextItem = prev(candidateNodes2, currIndex, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.PAGE_DOWN)) {
          nextItem = forward(candidateNodes2, currIndex, 10, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.PAGE_UP)) {
          nextItem = backward(candidateNodes2, currIndex, 10, loop);
        } else if (strict_equals(e.key, kbd_constants_exports.HOME)) {
          nextItem = candidateNodes2[0];
        } else if (strict_equals(e.key, kbd_constants_exports.END)) {
          nextItem = candidateNodes2[candidateNodes2.length - 1];
        }
        if (!nextItem) return;
        this.root.setHighlightedNode(nextItem);
        return;
      }
      const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
      const isCharacterKey = strict_equals(e.key.length, 1);
      if (strict_equals(e.code, "Space")) return;
      const candidateNodes = this.root.getCandidateNodes();
      if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
      if (!isModifierKey && isCharacterKey) {
        __privateGet(this, _domTypeahead).handleTypeaheadSearch(e.key, candidateNodes);
        return;
      }
      if (!this.root.highlightedNode) {
        this.root.setHighlightedToFirstCandidate();
      }
    });
    __privateAdd(this, _handleOpen, () => {
      this.root.open.current = true;
      __privateGet(this, _dataTypeahead).resetTypeahead();
      __privateGet(this, _domTypeahead).resetTypeahead();
    });
    __privateAdd(this, _handlePointerOpen, (e) => {
      __privateGet(this, _handleOpen).call(this);
      this.root.triggerPointerDownPos = {
        x: Math.round(e.pageX),
        y: Math.round(e.pageY)
      };
    });
    __privateAdd(this, _onclick8, (e) => {
      const currTarget = e.currentTarget;
      currTarget.focus();
    });
    /**
     * `pointerdown` fires before the `focus` event, so we can prevent the default
     * behavior of focusing the button and keep focus on the input.
     */
    __privateAdd(this, _onpointerdown7, (e) => {
      if (this.root.disabled.current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      const target = e.target;
      if (target == null ? void 0 : target.hasPointerCapture(e.pointerId)) {
        target == null ? void 0 : target.releasePointerCapture(e.pointerId);
      }
      if (strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
        if (strict_equals(this.root.open.current, false)) {
          __privateGet(this, _handlePointerOpen).call(this, e);
          e.preventDefault();
        } else {
          this.root.handleClose();
        }
      }
    });
    __privateAdd(this, _onpointerup3, (e) => {
      e.preventDefault();
      if (strict_equals(e.pointerType, "touch")) {
        __privateGet(this, _handlePointerOpen).call(this, e);
      }
    });
    __privateAdd(this, _props39, derived(() => ({
      id: __privateGet(this, _id26).current,
      disabled: this.root.disabled.current ? true : void 0,
      "aria-haspopup": "listbox",
      "data-state": getDataOpenClosed(this.root.open.current),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      "data-placeholder": this.root.hasValue ? void 0 : "",
      [this.root.bitsAttrs.trigger]: "",
      onpointerdown: __privateGet(this, _onpointerdown7),
      onkeydown: __privateGet(this, _onkeydown11),
      onclick: __privateGet(this, _onclick8),
      onpointerup: __privateGet(this, _onpointerup3)
      // onclick: this.#onclick,
    })));
    this.root = root17;
    __privateSet(this, _id26, props.id);
    __privateSet(this, _ref26, props.ref);
    useRefById({
      id: __privateGet(this, _id26),
      ref: __privateGet(this, _ref26),
      onRefChange: (node) => {
        this.root.triggerNode = node;
      }
    });
    __privateSet(this, _domTypeahead, useDOMTypeahead({
      getCurrentItem: () => this.root.highlightedNode,
      onMatch: (node) => {
        this.root.setHighlightedNode(node);
      }
    }));
    __privateSet(this, _dataTypeahead, useDataTypeahead({
      getCurrentItem: () => {
        if (this.root.isMulti) return "";
        return this.root.currentLabel;
      },
      onMatch: (label) => {
        if (this.root.isMulti) return;
        if (!this.root.items.current) return;
        const matchedItem = this.root.items.current.find((item) => strict_equals(item.label, label));
        if (!matchedItem) return;
        this.root.value.current = matchedItem.value;
      },
      enabled: !this.root.isMulti && this.root.dataTypeaheadEnabled
    }));
  }
  get props() {
    return get(__privateGet(this, _props39));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props39)), owner, false);
  }
};
_id26 = new WeakMap();
_ref26 = new WeakMap();
_domTypeahead = new WeakMap();
_dataTypeahead = new WeakMap();
_onkeydown11 = new WeakMap();
_handleOpen = new WeakMap();
_handlePointerOpen = new WeakMap();
_onclick8 = new WeakMap();
_onpointerdown7 = new WeakMap();
_onpointerup3 = new WeakMap();
_props39 = new WeakMap();
var _viewportNode, _isPositioned, _onpointermove, _styles, _snippetProps8, _props40;
var SelectContentState = class {
  constructor(props, root17) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _viewportNode, state(null));
    __publicField(this, "root");
    __privateAdd(this, _isPositioned, state(false));
    __privateAdd(this, _onpointermove, () => {
      this.root.isUsingKeyboard = false;
    });
    __privateAdd(this, _styles, derived(() => {
      if (this.root.isCombobox) {
        return {
          "--bits-combobox-content-transform-origin": "var(--bits-floating-transform-origin)",
          "--bits-combobox-content-available-width": "var(--bits-floating-available-width)",
          "--bits-combobox-content-available-height": "var(--bits-floating-available-height)",
          "--bits-combobox-anchor-width": "var(--bits-floating-anchor-width)",
          "--bits-combobox-anchor-height": "var(--bits-floating-anchor-height)"
        };
      } else {
        return {
          "--bits-select-content-transform-origin": "var(--bits-floating-transform-origin)",
          "--bits-select-content-available-width": "var(--bits-floating-available-width)",
          "--bits-select-content-available-height": "var(--bits-floating-available-height)",
          "--bits-select-anchor-width": "var(--bits-floating-anchor-width)",
          "--bits-select-anchor-height": "var(--bits-floating-anchor-height)"
        };
      }
    }));
    __publicField(this, "handleInteractOutside", (e) => {
      if (strict_equals(e.target, this.root.triggerNode) || strict_equals(e.target, this.root.inputNode)) {
        e.preventDefault();
      }
    });
    __privateAdd(this, _snippetProps8, derived(() => ({ open: this.root.open.current })));
    __privateAdd(this, _props40, derived(() => ({
      id: this.id.current,
      role: "listbox",
      "data-state": getDataOpenClosed(this.root.open.current),
      [this.root.bitsAttrs.content]: "",
      style: {
        display: "flex",
        flexDirection: "column",
        outline: "none",
        boxSizing: "border-box",
        pointerEvents: "auto",
        ...get(__privateGet(this, _styles))
      },
      onpointermove: __privateGet(this, _onpointermove)
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({
      id: this.id,
      ref: this.ref,
      onRefChange: (node) => {
        this.root.contentNode = node;
      },
      deps: () => this.root.open.current
    });
    user_effect(() => {
      return () => {
        this.root.contentNode = null;
      };
    });
    user_effect(() => {
      if (strict_equals(this.root.open.current, false)) {
        this.isPositioned = false;
      }
    });
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode), proxy(value, null, __privateGet(this, _viewportNode)));
  }
  get isPositioned() {
    return get(__privateGet(this, _isPositioned));
  }
  set isPositioned(value) {
    set(__privateGet(this, _isPositioned), proxy(value, null, __privateGet(this, _isPositioned)));
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps8));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props40));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _viewportNode)), owner, false);
    add_owner(get(__privateGet(this, _isPositioned)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps8)), owner, false);
    add_owner(get(__privateGet(this, _props40)), owner, false);
  }
};
_viewportNode = new WeakMap();
_isPositioned = new WeakMap();
_onpointermove = new WeakMap();
_styles = new WeakMap();
_snippetProps8 = new WeakMap();
_props40 = new WeakMap();
var _id27, _ref27, _isSelected, _isHighlighted, _textId, _mounted, _snippetProps9, _onpointerdown8, _onpointerup4, _onpointermove2, _props41;
var SelectItemState = class {
  constructor(props, root17) {
    __privateAdd(this, _id27);
    __privateAdd(this, _ref27);
    __publicField(this, "root");
    __publicField(this, "value");
    __publicField(this, "label");
    __publicField(this, "onHighlight");
    __publicField(this, "onUnhighlight");
    __publicField(this, "disabled");
    __privateAdd(this, _isSelected, derived(() => this.root.includesItem(this.value.current)));
    __privateAdd(this, _isHighlighted, derived(() => strict_equals(this.root.highlightedValue, this.value.current)));
    __publicField(this, "prevHighlighted", new Previous(() => this.isHighlighted));
    __privateAdd(this, _textId, state(""));
    __privateAdd(this, _mounted, state(false));
    __privateAdd(this, _snippetProps9, derived(() => ({
      selected: this.isSelected,
      highlighted: this.isHighlighted
    })));
    __privateAdd(this, _onpointerdown8, (e) => {
      e.preventDefault();
    });
    /**
     * Using `pointerup` instead of `click` allows power users to pointerdown
     * the trigger, then release pointerup on an item to select it vs having to do
     * multiple clicks.
     */
    __privateAdd(this, _onpointerup4, (e) => {
      if (e.defaultPrevented) return;
      e.preventDefault();
      if (this.disabled.current) return;
      const isCurrentSelectedValue = strict_equals(this.value.current, this.root.value.current);
      if (!this.root.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
        this.root.handleClose();
        return;
      }
      this.root.toggleItem(this.value.current, this.label.current);
      if (!this.root.isMulti && !isCurrentSelectedValue) {
        this.root.handleClose();
      }
    });
    __privateAdd(this, _onpointermove2, (_) => {
      if (strict_equals(this.root.highlightedNode, __privateGet(this, _ref27).current, false)) {
        this.root.setHighlightedNode(__privateGet(this, _ref27).current);
      }
    });
    __publicField(this, "setTextId", (id) => {
      this.textId = id;
    });
    __privateAdd(this, _props41, derived(() => ({
      id: __privateGet(this, _id27).current,
      role: "option",
      "aria-selected": this.root.includesItem(this.value.current) ? "true" : void 0,
      "data-value": this.value.current,
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-highlighted": strict_equals(this.root.highlightedValue, this.value.current) ? "" : void 0,
      "data-selected": this.root.includesItem(this.value.current) ? "" : void 0,
      "data-label": this.label.current,
      [this.root.bitsAttrs.item]: "",
      onpointermove: __privateGet(this, _onpointermove2),
      onpointerdown: __privateGet(this, _onpointerdown8),
      onpointerup: __privateGet(this, _onpointerup4)
    })));
    this.root = root17;
    this.value = props.value;
    this.disabled = props.disabled;
    this.label = props.label;
    this.onHighlight = props.onHighlight;
    this.onUnhighlight = props.onUnhighlight;
    __privateSet(this, _id27, props.id);
    __privateSet(this, _ref27, props.ref);
    user_effect(() => {
      if (this.isHighlighted) {
        this.onHighlight.current();
      } else if (this.prevHighlighted.current) {
        this.onUnhighlight.current();
      }
    });
    useRefById({ id: __privateGet(this, _id27), ref: __privateGet(this, _ref27) });
    user_effect(() => {
      if (!this.mounted) return;
      untrack(() => this.root.setInitialHighlightedNode());
    });
  }
  get isSelected() {
    return get(__privateGet(this, _isSelected));
  }
  set isSelected(_) {
    throw new Error("Cannot update a derived property ('isSelected')");
  }
  get isHighlighted() {
    return get(__privateGet(this, _isHighlighted));
  }
  set isHighlighted(_) {
    throw new Error("Cannot update a derived property ('isHighlighted')");
  }
  get textId() {
    return get(__privateGet(this, _textId));
  }
  set textId(value) {
    set(__privateGet(this, _textId), proxy(value, null, __privateGet(this, _textId)));
  }
  get mounted() {
    return get(__privateGet(this, _mounted));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted), proxy(value, null, __privateGet(this, _mounted)));
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps9));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props41));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isSelected)), owner, false);
    add_owner(get(__privateGet(this, _isHighlighted)), owner, false);
    add_owner(get(__privateGet(this, _textId)), owner, false);
    add_owner(get(__privateGet(this, _mounted)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps9)), owner, false);
    add_owner(get(__privateGet(this, _props41)), owner, false);
  }
};
_id27 = new WeakMap();
_ref27 = new WeakMap();
_isSelected = new WeakMap();
_isHighlighted = new WeakMap();
_textId = new WeakMap();
_mounted = new WeakMap();
_snippetProps9 = new WeakMap();
_onpointerdown8 = new WeakMap();
_onpointerup4 = new WeakMap();
_onpointermove2 = new WeakMap();
_props41 = new WeakMap();
var _id28, _ref28, _labelNode, _props42;
var SelectGroupState = class {
  constructor(props, root17) {
    __privateAdd(this, _id28);
    __privateAdd(this, _ref28);
    __publicField(this, "root");
    __privateAdd(this, _labelNode, state(null));
    __privateAdd(this, _props42, derived(() => {
      var _a;
      return {
        id: __privateGet(this, _id28).current,
        role: "group",
        [this.root.bitsAttrs.group]: "",
        "aria-labelledby": ((_a = this.labelNode) == null ? void 0 : _a.id) ?? void 0
      };
    }));
    __privateSet(this, _id28, props.id);
    __privateSet(this, _ref28, props.ref);
    this.root = root17;
    useRefById({ id: __privateGet(this, _id28), ref: __privateGet(this, _ref28) });
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode), proxy(value, null, __privateGet(this, _labelNode)));
  }
  get props() {
    return get(__privateGet(this, _props42));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _labelNode)), owner, false);
    add_owner(get(__privateGet(this, _props42)), owner, false);
  }
};
_id28 = new WeakMap();
_ref28 = new WeakMap();
_labelNode = new WeakMap();
_props42 = new WeakMap();
var _id29, _ref29, _props43;
var SelectGroupHeadingState = class {
  constructor(props, group) {
    __privateAdd(this, _id29);
    __privateAdd(this, _ref29);
    __publicField(this, "group");
    __privateAdd(this, _props43, derived(() => ({
      id: __privateGet(this, _id29).current,
      [this.group.root.bitsAttrs["group-label"]]: ""
    })));
    __privateSet(this, _id29, props.id);
    __privateSet(this, _ref29, props.ref);
    this.group = group;
    useRefById({
      id: __privateGet(this, _id29),
      ref: __privateGet(this, _ref29),
      onRefChange: (node) => {
        group.labelNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props43));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props43)), owner, false);
  }
};
_id29 = new WeakMap();
_ref29 = new WeakMap();
_props43 = new WeakMap();
var _value3, _shouldRender2, _onfocus, _props44;
var SelectHiddenInputState = class {
  constructor(props, root17) {
    __privateAdd(this, _value3);
    __publicField(this, "root");
    __privateAdd(this, _shouldRender2, derived(() => strict_equals(this.root.name.current, "", false)));
    __privateAdd(this, _onfocus, (e) => {
      var _a, _b;
      e.preventDefault();
      if (!this.root.isCombobox) {
        (_a = this.root.triggerNode) == null ? void 0 : _a.focus();
      } else {
        (_b = this.root.inputNode) == null ? void 0 : _b.focus();
      }
    });
    __privateAdd(this, _props44, derived(() => ({
      disabled: getDisabled(this.root.disabled.current),
      required: getRequired(this.root.required.current),
      name: this.root.name.current,
      value: __privateGet(this, _value3).current,
      style: styleToString(srOnlyStyles),
      tabindex: -1,
      onfocus: __privateGet(this, _onfocus)
    })));
    this.root = root17;
    __privateSet(this, _value3, props.value);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender2));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get props() {
    return get(__privateGet(this, _props44));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _shouldRender2)), owner, false);
    add_owner(get(__privateGet(this, _props44)), owner, false);
  }
};
_value3 = new WeakMap();
_shouldRender2 = new WeakMap();
_onfocus = new WeakMap();
_props44 = new WeakMap();
var _id30, _ref30, _prevScrollTop, _props45;
var SelectViewportState = class {
  constructor(props, content) {
    __privateAdd(this, _id30);
    __privateAdd(this, _ref30);
    __publicField(this, "root");
    __publicField(this, "content");
    __privateAdd(this, _prevScrollTop, state(0));
    __privateAdd(this, _props45, derived(() => ({
      id: __privateGet(this, _id30).current,
      role: "presentation",
      [this.root.bitsAttrs.viewport]: "",
      style: {
        // we use position: 'relative' here on the `viewport` so that when we call
        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
        // (independent of the scrollUpButton).
        position: "relative",
        flex: 1,
        overflow: "auto"
      }
    })));
    __privateSet(this, _id30, props.id);
    __privateSet(this, _ref30, props.ref);
    this.content = content;
    this.root = content.root;
    useRefById({
      id: __privateGet(this, _id30),
      ref: __privateGet(this, _ref30),
      onRefChange: (node) => {
        this.content.viewportNode = node;
      },
      deps: () => this.root.open.current
    });
  }
  get prevScrollTop() {
    return get(__privateGet(this, _prevScrollTop));
  }
  set prevScrollTop(value) {
    set(__privateGet(this, _prevScrollTop), proxy(value, null, __privateGet(this, _prevScrollTop)));
  }
  get props() {
    return get(__privateGet(this, _props45));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _prevScrollTop)), owner, false);
    add_owner(get(__privateGet(this, _props45)), owner, false);
  }
};
_id30 = new WeakMap();
_ref30 = new WeakMap();
_prevScrollTop = new WeakMap();
_props45 = new WeakMap();
var _autoScrollTimer, _onpointerdown9, _onpointermove3, _onpointerleave, _props46;
var SelectScrollButtonImplState = class {
  constructor(props, content) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "content");
    __publicField(this, "root");
    __privateAdd(this, _autoScrollTimer, state(null));
    __publicField(this, "onAutoScroll", noop2);
    __publicField(this, "mounted");
    __publicField(this, "clearAutoScrollTimer", () => {
      if (strict_equals(this.autoScrollTimer, null)) return;
      window.clearInterval(this.autoScrollTimer);
      this.autoScrollTimer = null;
    });
    __privateAdd(this, _onpointerdown9, () => {
      if (strict_equals(this.autoScrollTimer, null, false)) return;
      this.autoScrollTimer = window.setInterval(
        () => {
          this.onAutoScroll();
        },
        50
      );
    });
    __privateAdd(this, _onpointermove3, () => {
      if (strict_equals(this.autoScrollTimer, null, false)) return;
      this.autoScrollTimer = window.setInterval(
        () => {
          this.onAutoScroll();
        },
        50
      );
    });
    __privateAdd(this, _onpointerleave, () => {
      this.clearAutoScrollTimer();
    });
    __privateAdd(this, _props46, derived(() => ({
      id: this.id.current,
      "aria-hidden": getAriaHidden(true),
      style: { flexShrink: 0 },
      onpointerdown: __privateGet(this, _onpointerdown9),
      onpointermove: __privateGet(this, _onpointermove3),
      onpointerleave: __privateGet(this, _onpointerleave)
    })));
    this.ref = props.ref;
    this.id = props.id;
    this.mounted = props.mounted;
    this.content = content;
    this.root = content.root;
    useRefById({
      id: this.id,
      ref: this.ref,
      deps: () => this.mounted.current
    });
    user_effect(() => {
      if (!this.mounted.current) return;
      const activeItem = untrack(() => this.root.highlightedNode);
      activeItem == null ? void 0 : activeItem.scrollIntoView({ block: "nearest" });
    });
  }
  get autoScrollTimer() {
    return get(__privateGet(this, _autoScrollTimer));
  }
  set autoScrollTimer(value) {
    set(__privateGet(this, _autoScrollTimer), proxy(value, null, __privateGet(this, _autoScrollTimer)));
  }
  get props() {
    return get(__privateGet(this, _props46));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _autoScrollTimer)), owner, false);
    add_owner(get(__privateGet(this, _props46)), owner, false);
  }
};
_autoScrollTimer = new WeakMap();
_onpointerdown9 = new WeakMap();
_onpointermove3 = new WeakMap();
_onpointerleave = new WeakMap();
_props46 = new WeakMap();
var _canScrollDown, _props47;
var SelectScrollDownButtonState = class {
  constructor(state2) {
    __publicField(this, "state");
    __publicField(this, "content");
    __publicField(this, "root");
    __privateAdd(this, _canScrollDown, state(false));
    __publicField(this, "handleAutoScroll", () => {
      afterTick(() => {
        const viewport = this.content.viewportNode;
        const selectedItem = this.root.highlightedNode;
        if (!viewport || !selectedItem) return;
        viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
      });
    });
    __privateAdd(this, _props47, derived(() => ({
      ...this.state.props,
      [this.root.bitsAttrs["scroll-down-button"]]: ""
    })));
    this.state = state2;
    this.content = state2.content;
    this.root = state2.root;
    this.state.onAutoScroll = this.handleAutoScroll;
    user_effect(() => {
      const viewport = this.content.viewportNode;
      const isPositioned = this.content.isPositioned;
      if (!viewport || !isPositioned) return;
      let cleanup = noop2;
      untrack(() => {
        const handleScroll = () => {
          afterTick(() => {
            const maxScroll = viewport.scrollHeight - viewport.clientHeight;
            const paddingTop = Number.parseInt(getComputedStyle(viewport).paddingTop, 10);
            this.canScrollDown = Math.ceil(viewport.scrollTop) < maxScroll - paddingTop;
          });
        };
        handleScroll();
        cleanup = addEventListener2(viewport, "scroll", handleScroll);
      });
      return cleanup;
    });
    user_effect(() => {
      if (this.state.mounted.current) return;
      this.state.clearAutoScrollTimer();
    });
  }
  get canScrollDown() {
    return get(__privateGet(this, _canScrollDown));
  }
  set canScrollDown(value) {
    set(__privateGet(this, _canScrollDown), proxy(value, null, __privateGet(this, _canScrollDown)));
  }
  get props() {
    return get(__privateGet(this, _props47));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _canScrollDown)), owner, false);
    add_owner(get(__privateGet(this, _props47)), owner, false);
  }
};
_canScrollDown = new WeakMap();
_props47 = new WeakMap();
var _canScrollUp, _props48;
var SelectScrollUpButtonState = class {
  constructor(state2) {
    __publicField(this, "state");
    __publicField(this, "content");
    __publicField(this, "root");
    __privateAdd(this, _canScrollUp, state(false));
    __publicField(this, "handleAutoScroll", () => {
      afterTick(() => {
        const viewport = this.content.viewportNode;
        const selectedItem = this.root.highlightedNode;
        if (!viewport || !selectedItem) return;
        viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
      });
    });
    __privateAdd(this, _props48, derived(() => ({
      ...this.state.props,
      [this.root.bitsAttrs["scroll-up-button"]]: ""
    })));
    this.state = state2;
    this.content = state2.content;
    this.root = state2.root;
    this.state.onAutoScroll = this.handleAutoScroll;
    user_effect(() => {
      const viewport = this.content.viewportNode;
      const isPositioned = this.content.isPositioned;
      if (!viewport || !isPositioned) return;
      let cleanup = noop2;
      untrack(() => {
        const handleScroll = () => {
          const paddingTop = Number.parseInt(getComputedStyle(viewport).paddingTop, 10);
          this.canScrollUp = viewport.scrollTop - paddingTop > 0;
        };
        handleScroll();
        cleanup = addEventListener2(viewport, "scroll", handleScroll);
      });
      return cleanup;
    });
    user_effect(() => {
      if (this.state.mounted.current) return;
      this.state.clearAutoScrollTimer();
    });
  }
  get canScrollUp() {
    return get(__privateGet(this, _canScrollUp));
  }
  set canScrollUp(value) {
    set(__privateGet(this, _canScrollUp), proxy(value, null, __privateGet(this, _canScrollUp)));
  }
  get props() {
    return get(__privateGet(this, _props48));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _canScrollUp)), owner, false);
    add_owner(get(__privateGet(this, _props48)), owner, false);
  }
};
_canScrollUp = new WeakMap();
_props48 = new WeakMap();
var [setSelectRootContext, getSelectRootContext] = createContext(["Select.Root", "Combobox.Root"]);
var [setSelectGroupContext, getSelectGroupContext] = createContext(["Select.Group", "Combobox.Group"]);
var [
  setSelectContentContext,
  getSelectContentContext
] = createContext(["Select.Content", "Combobox.Content"]);
function useSelectRoot(props) {
  const { type, ...rest } = props;
  const rootState = strict_equals(type, "single") ? new SelectSingleRootState(rest) : new SelectMultipleRootState(rest);
  return setSelectRootContext(rootState);
}
function useSelectInput(props) {
  return new SelectInputState(props, getSelectRootContext());
}
function useSelectContent(props) {
  return setSelectContentContext(new SelectContentState(props, getSelectRootContext()));
}
function useSelectTrigger(props) {
  return new SelectTriggerState(props, getSelectRootContext());
}
function useSelectComboTrigger(props) {
  return new SelectComboTriggerState(props, getSelectRootContext());
}
function useSelectItem(props) {
  return new SelectItemState(props, getSelectRootContext());
}
function useSelectViewport(props) {
  return new SelectViewportState(props, getSelectContentContext());
}
function useSelectScrollUpButton(props) {
  return new SelectScrollUpButtonState(new SelectScrollButtonImplState(props, getSelectContentContext()));
}
function useSelectScrollDownButton(props) {
  return new SelectScrollDownButtonState(new SelectScrollButtonImplState(props, getSelectContentContext()));
}
function useSelectGroup(props) {
  return setSelectGroupContext(new SelectGroupState(props, getSelectRootContext()));
}
function useSelectGroupHeading(props) {
  return new SelectGroupHeadingState(props, getSelectGroupContext());
}
function useSelectHiddenInput(props) {
  return new SelectHiddenInputState(props, getSelectRootContext());
}
var selectParts = [
  "trigger",
  "content",
  "item",
  "viewport",
  "scroll-up-button",
  "scroll-down-button",
  "group",
  "group-label",
  "separator",
  "arrow",
  "input",
  "content-wrapper",
  "item-text",
  "value"
];
function getSelectBitsAttrs(root17) {
  const isCombobox = root17.isCombobox;
  const attrObj = {};
  for (const part of selectParts) {
    attrObj[part] = isCombobox ? `data-combobox-${part}` : `data-select-${part}`;
  }
  return attrObj;
}

// node_modules/bits-ui/dist/bits/select/components/select-hidden-input.svelte
mark_module_start();
Select_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-hidden-input.svelte";
var root_231 = add_locations(template(`<input>`), Select_hidden_input[FILENAME], [[19, 2]]);
function Select_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_hidden_input);
  validate_prop_bindings($$props, ["value"], [], Select_hidden_input);
  let value = prop($$props, "value", 15, "");
  const hiddenInputState = useSelectHiddenInput({ value: box.with(() => value()) });
  var fragment = comment();
  var node = first_child(fragment);
  visually_hidden_default(node, {
    children: wrap_snippet(Select_hidden_input, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(node_1, () => hiddenInputState.shouldRender, ($$anchor3) => {
        var input = root_231();
        remove_input_defaults(input);
        let attributes;
        template_effect(() => attributes = set_attributes(input, attributes, { ...hiddenInputState.props }));
        bind_value(input, value);
        append($$anchor3, input);
      });
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_hidden_input = hmr(Select_hidden_input, () => Select_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_hidden_input[HMR].source;
    set(Select_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var select_hidden_input_default = Select_hidden_input;
mark_module_end(Select_hidden_input);

// node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte
mark_module_start();
Combobox[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte";
var root3 = add_locations(template(`<!> <!>`, 1), Combobox[FILENAME], []);
function Combobox($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox);
  validate_prop_bindings($$props, ["value", "open"], [], Combobox);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), controlledOpen = prop($$props, "controlledOpen", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, true);
  if (strict_equals(value(), void 0)) {
    const defaultValue = strict_equals($$props.type, "single") ? "" : [];
    if (controlledValue()) {
      onValueChange()(defaultValue);
    } else {
      value(defaultValue);
    }
  }
  const rootState = useSelectRoot({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    disabled: box.with(() => disabled()),
    required: box.with(() => required()),
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    }),
    loop: box.with(() => loop()),
    scrollAlignment: box.with(() => scrollAlignment()),
    name: box.with(() => name()),
    isCombobox: true,
    items: box.with(() => items()),
    allowDeselect: box.with(() => allowDeselect())
  });
  var fragment = root3();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Combobox, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  if_block(
    node_2,
    () => Array.isArray(rootState.value.current),
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      if_block(node_3, () => rootState.value.current.length, ($$anchor3) => {
        var fragment_3 = comment();
        var node_4 = first_child(fragment_3);
        each(node_4, 17, () => rootState.value.current, index, ($$anchor4, item) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          select_hidden_input_default(node_5, {
            get value() {
              return get(item);
            }
          });
          append($$anchor4, fragment_4);
        });
        append($$anchor3, fragment_3);
      });
      append($$anchor2, fragment_2);
    },
    ($$anchor2) => {
      var fragment_5 = comment();
      var node_6 = first_child(fragment_5);
      validate_binding("bind:value={rootState.value.current as string}", () => rootState.value, () => "current", 82, 21);
      {
        add_owner_effect(() => rootState.value.current, select_hidden_input_default);
        select_hidden_input_default(node_6, {
          get value() {
            return rootState.value.current;
          },
          set value($$value) {
            rootState.value.current = $$value;
          }
        });
      }
      append($$anchor2, fragment_5);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox = hmr(Combobox, () => Combobox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox[HMR].source;
    set(Combobox[HMR].source, module.default[HMR].original);
  });
}
var combobox_default = Combobox;
mark_module_end(Combobox);

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/index.js
var components_exports = {};
__export(components_exports, {
  Anchor: () => floating_layer_anchor_default,
  Arrow: () => floating_layer_arrow_default,
  Content: () => floating_layer_content_default,
  ContentStatic: () => floating_layer_content_static_default,
  Root: () => floating_layer_default
});

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte
mark_module_start();
Floating_layer_anchor[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte";
function Floating_layer_anchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_anchor);
  validate_prop_bindings($$props, [], [], Floating_layer_anchor);
  useFloatingAnchorState({
    id: box.with(() => $$props.id),
    virtualEl: box.with(() => $$props.virtualEl)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_anchor = hmr(Floating_layer_anchor, () => Floating_layer_anchor[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_anchor[HMR].source;
    set(Floating_layer_anchor[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_anchor_default = Floating_layer_anchor;
mark_module_end(Floating_layer_anchor);

// node_modules/bits-ui/dist/bits/utilities/arrow/arrow.svelte
mark_module_start();
Arrow[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/arrow/arrow.svelte";
var root_4 = add_locations(template(`<svg viewBox="0 0 30 10" preserveAspectRatio="none" data-arrow=""><polygon points="0,0 30,0 15,10" fill="currentColor"></polygon></svg>`), Arrow[FILENAME], [[25, 3, [[26, 4]]]]);
var root_232 = add_locations(template(`<span><!></span>`), Arrow[FILENAME], [[21, 1]]);
function Arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow);
  validate_prop_bindings($$props, [], [], Arrow);
  let id = prop($$props, "id", 19, useId), width = prop($$props, "width", 3, 10), height = prop($$props, "height", 3, 5), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "width",
      "height"
    ],
    "restProps"
  );
  const mergedProps = derived(() => mergeProps(restProps, { id: id() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_232();
      let attributes;
      var node_2 = child(span);
      if_block(
        node_2,
        () => $$props.children,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var svg = root_4();
          template_effect(() => {
            set_attribute(svg, "width", width());
            set_attribute(svg, "height", height());
          });
          append($$anchor3, svg);
        }
      );
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Arrow = hmr(Arrow, () => Arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Arrow[HMR].source;
    set(Arrow[HMR].source, module.default[HMR].original);
  });
}
var arrow_default = Arrow;
mark_module_end(Arrow);

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-arrow.svelte
mark_module_start();
Floating_layer_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-arrow.svelte";
function Floating_layer_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_arrow);
  validate_prop_bindings($$props, ["ref"], [], Floating_layer_arrow);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref"
    ],
    "restProps"
  );
  const arrowState = useFloatingArrowState({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, arrowState.props));
  var fragment = comment();
  var node = first_child(fragment);
  arrow_default(node, spread_props(() => get(mergedProps)));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_arrow = hmr(Floating_layer_arrow, () => Floating_layer_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_arrow[HMR].source;
    set(Floating_layer_arrow[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_arrow_default = Floating_layer_arrow;
mark_module_end(Floating_layer_arrow);

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte
mark_module_start();
Floating_layer_content[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte";
var root4 = add_locations(template(`<div><!></div>`), Floating_layer_content[FILENAME], [[60, 0]]);
function Floating_layer_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_content);
  validate_prop_bindings($$props, [], [], Floating_layer_content);
  let side = prop($$props, "side", 3, "bottom"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), alignOffset = prop($$props, "alignOffset", 3, 0), arrowPadding = prop($$props, "arrowPadding", 3, 0), avoidCollisions = prop($$props, "avoidCollisions", 3, true), collisionBoundary = prop($$props, "collisionBoundary", 19, () => []), collisionPadding = prop($$props, "collisionPadding", 3, 0), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), onPlaced = prop($$props, "onPlaced", 3, () => {
  }), sticky = prop($$props, "sticky", 3, "partial"), updatePositionStrategy = prop($$props, "updatePositionStrategy", 3, "optimized"), strategy = prop($$props, "strategy", 3, "fixed"), dir = prop($$props, "dir", 3, "ltr"), style = prop($$props, "style", 19, () => ({})), wrapperId = prop($$props, "wrapperId", 19, useId), customAnchor = prop($$props, "customAnchor", 3, null);
  const contentState = useFloatingContentState({
    side: box.with(() => side()),
    sideOffset: box.with(() => sideOffset()),
    align: box.with(() => align()),
    alignOffset: box.with(() => alignOffset()),
    id: box.with(() => $$props.id),
    arrowPadding: box.with(() => arrowPadding()),
    avoidCollisions: box.with(() => avoidCollisions()),
    collisionBoundary: box.with(() => collisionBoundary()),
    collisionPadding: box.with(() => collisionPadding()),
    hideWhenDetached: box.with(() => hideWhenDetached()),
    onPlaced: box.with(() => onPlaced()),
    sticky: box.with(() => sticky()),
    updatePositionStrategy: box.with(() => updatePositionStrategy()),
    strategy: box.with(() => strategy()),
    dir: box.with(() => dir()),
    style: box.with(() => style()),
    enabled: box.with(() => false),
    wrapperId: box.with(() => wrapperId()),
    customAnchor: box.with(() => customAnchor())
  });
  const mergedProps = derived(() => mergeProps(contentState.wrapperProps, { style: { pointerEvents: "auto" } }));
  var div = root4();
  let attributes;
  var node = child(div);
  snippet(node, () => $$props.content ?? noop, () => ({ props: contentState.props }));
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_content = hmr(Floating_layer_content, () => Floating_layer_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_content[HMR].source;
    set(Floating_layer_content[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_content_default = Floating_layer_content;
mark_module_end(Floating_layer_content);

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte
mark_module_start();
Floating_layer_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte";
function Floating_layer_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_content_static);
  validate_prop_bindings($$props, [], [], Floating_layer_content_static);
  onMount(() => {
    var _a;
    (_a = $$props.onPlaced) == null ? void 0 : _a.call($$props);
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.content ?? noop, () => ({ props: {} }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_content_static = hmr(Floating_layer_content_static, () => Floating_layer_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_content_static[HMR].source;
    set(Floating_layer_content_static[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_content_static_default = Floating_layer_content_static;
mark_module_end(Floating_layer_content_static);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte
mark_module_start();
Combobox_input[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte";
var root_34 = add_locations(template(`<input>`), Combobox_input[FILENAME], [[37, 2]]);
function Combobox_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox_input);
  validate_prop_bindings($$props, ["ref"], [], Combobox_input);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "defaultValue"
    ],
    "restProps"
  );
  const inputState = useSelectInput({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  if ($$props.defaultValue) {
    inputState.root.inputValue = $$props.defaultValue;
  }
  const mergedProps = derived(() => mergeProps(restProps, inputState.props, { value: inputState.root.inputValue }));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      children: wrap_snippet(Combobox_input, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        if_block(
          node_1,
          () => $$props.child,
          ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          },
          ($$anchor4) => {
            var input = root_34();
            remove_input_defaults(input);
            let attributes;
            template_effect(() => attributes = set_attributes(input, attributes, { ...get(mergedProps) }));
            append($$anchor4, input);
          }
        );
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox_input = hmr(Combobox_input, () => Combobox_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox_input[HMR].source;
    set(Combobox_input[HMR].source, module.default[HMR].original);
  });
}
var combobox_input_default = Combobox_input;
mark_module_end(Combobox_input);

// node_modules/bits-ui/dist/bits/separator/separator.svelte.js
var ROOT_ATTR = "data-separator-root";
var _id31, _ref31, _orientation, _decorative, _props49;
var SeparatorRootState = class {
  constructor(props) {
    __privateAdd(this, _id31);
    __privateAdd(this, _ref31);
    __privateAdd(this, _orientation);
    __privateAdd(this, _decorative);
    __privateAdd(this, _props49, derived(() => ({
      id: __privateGet(this, _id31).current,
      role: __privateGet(this, _decorative).current ? "none" : "separator",
      "aria-orientation": getAriaOrientation(__privateGet(this, _orientation).current),
      "aria-hidden": getAriaHidden(__privateGet(this, _decorative).current),
      "data-orientation": getDataOrientation(__privateGet(this, _orientation).current),
      [ROOT_ATTR]: ""
    })));
    __privateSet(this, _orientation, props.orientation);
    __privateSet(this, _decorative, props.decorative);
    __privateSet(this, _id31, props.id);
    __privateSet(this, _ref31, props.ref);
    useRefById({ id: __privateGet(this, _id31), ref: __privateGet(this, _ref31) });
  }
  get props() {
    return get(__privateGet(this, _props49));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props49)), owner, false);
  }
};
_id31 = new WeakMap();
_ref31 = new WeakMap();
_orientation = new WeakMap();
_decorative = new WeakMap();
_props49 = new WeakMap();
function useSeparatorRoot(props) {
  return new SeparatorRootState(props);
}

// node_modules/bits-ui/dist/bits/separator/components/separator.svelte
mark_module_start();
Separator[FILENAME] = "node_modules/bits-ui/dist/bits/separator/components/separator.svelte";
var root_233 = add_locations(template(`<div><!></div>`), Separator[FILENAME], [[33, 1]]);
function Separator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Separator);
  validate_prop_bindings($$props, ["ref"], [], Separator);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), decorative = prop($$props, "decorative", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "decorative",
      "orientation"
    ],
    "restProps"
  );
  const rootState = useSeparatorRoot({
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id()),
    decorative: box.with(() => decorative()),
    orientation: box.with(() => orientation())
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_233();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Separator = hmr(Separator, () => Separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Separator[HMR].source;
    set(Separator[HMR].source, module.default[HMR].original);
  });
}
var separator_default = Separator;
mark_module_end(Separator);

// node_modules/bits-ui/dist/bits/combobox/components/combobox-trigger.svelte
mark_module_start();
Combobox_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-trigger.svelte";
var root_234 = add_locations(template(`<button><!></button>`), Combobox_trigger[FILENAME], [[30, 1]]);
function Combobox_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox_trigger);
  validate_prop_bindings($$props, ["ref"], [], Combobox_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const triggerState = useSelectComboTrigger({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_234();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox_trigger = hmr(Combobox_trigger, () => Combobox_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox_trigger[HMR].source;
    set(Combobox_trigger[HMR].source, module.default[HMR].original);
  });
}
var combobox_trigger_default = Combobox_trigger;
mark_module_end(Combobox_trigger);

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte
mark_module_start();
Popper_content[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte";
function Popper_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_content);
  validate_prop_bindings($$props, [], [], Popper_content);
  let isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "content",
      "isStatic",
      "onPlaced"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    isStatic,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      floating_layer_content_static_default(node_1, {
        get content() {
          return $$props.content;
        },
        get onPlaced() {
          return $$props.onPlaced;
        }
      });
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      floating_layer_content_default(node_2, spread_props(
        {
          get content() {
            return $$props.content;
          },
          get onPlaced() {
            return $$props.onPlaced;
          }
        },
        () => restProps
      ));
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_content = hmr(Popper_content, () => Popper_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_content[HMR].source;
    set(Popper_content[HMR].source, module.default[HMR].original);
  });
}
var popper_content_default = Popper_content;
mark_module_end(Popper_content);

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte
mark_module_start();
Popper_layer_inner[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte";
var root_1 = add_locations(template(`<!> <!>`, 1), Popper_layer_inner[FILENAME], []);
function Popper_layer_inner($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer_inner);
  validate_prop_bindings($$props, [], [], Popper_layer_inner);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "enabled"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    const content = wrap_snippet(Popper_layer_inner, ($$anchor2, $$arg0) => {
      let floatingProps = () => $$arg0 == null ? void 0 : $$arg0().props;
      floatingProps();
      var fragment_1 = root_1();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.forceMount && $$props.enabled,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          scroll_lock_default(node_2, {
            get preventScroll() {
              return $$props.preventScroll;
            }
          });
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          if_block(
            node_3,
            () => !$$props.forceMount,
            ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              scroll_lock_default(node_4, {
                get preventScroll() {
                  return $$props.preventScroll;
                }
              });
              append($$anchor4, fragment_4);
            },
            null,
            true
          );
          append($$anchor3, fragment_3);
        }
      );
      var node_5 = sibling(node_1, 2);
      var trapFocus_1 = derived(() => $$props.enabled && trapFocus());
      {
        const focusScope = wrap_snippet(Popper_layer_inner, ($$anchor3, $$arg02) => {
          let focusScopeProps = () => $$arg02 == null ? void 0 : $$arg02().props;
          focusScopeProps();
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          escape_layer_default(node_6, {
            get onEscapeKeydown() {
              return $$props.onEscapeKeydown;
            },
            get escapeKeydownBehavior() {
              return $$props.escapeKeydownBehavior;
            },
            get enabled() {
              return $$props.enabled;
            },
            children: wrap_snippet(Popper_layer_inner, ($$anchor4, $$slotProps) => {
              var fragment_6 = comment();
              var node_7 = first_child(fragment_6);
              {
                const children = wrap_snippet(Popper_layer_inner, ($$anchor5, $$arg03) => {
                  let dismissibleProps = () => $$arg03 == null ? void 0 : $$arg03().props;
                  dismissibleProps();
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  text_selection_layer_default(node_8, {
                    get id() {
                      return $$props.id;
                    },
                    get preventOverflowTextSelection() {
                      return $$props.preventOverflowTextSelection;
                    },
                    get onPointerDown() {
                      return $$props.onPointerDown;
                    },
                    get onPointerUp() {
                      return $$props.onPointerUp;
                    },
                    get enabled() {
                      return $$props.enabled;
                    },
                    children: wrap_snippet(Popper_layer_inner, ($$anchor6, $$slotProps2) => {
                      var fragment_8 = comment();
                      var node_9 = first_child(fragment_8);
                      var render_arg = derived_safe_equal(() => ({
                        props: mergeProps(restProps, floatingProps(), dismissibleProps(), focusScopeProps(), { style: { pointerEvents: "auto" } })
                      }));
                      snippet(node_9, () => $$props.popper ?? noop, () => get(render_arg));
                      append($$anchor6, fragment_8);
                    }),
                    $$slots: { default: true }
                  });
                  append($$anchor5, fragment_7);
                });
                dismissible_layer_default(node_7, {
                  get id() {
                    return $$props.id;
                  },
                  get onInteractOutside() {
                    return $$props.onInteractOutside;
                  },
                  get onFocusOutside() {
                    return $$props.onFocusOutside;
                  },
                  get interactOutsideBehavior() {
                    return interactOutsideBehavior();
                  },
                  get isValidEvent() {
                    return isValidEvent2();
                  },
                  get enabled() {
                    return $$props.enabled;
                  },
                  children,
                  $$slots: { default: true }
                });
              }
              append($$anchor4, fragment_6);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_5);
        });
        focus_scope_default(node_5, {
          get id() {
            return $$props.id;
          },
          get onOpenAutoFocus() {
            return $$props.onOpenAutoFocus;
          },
          get onCloseAutoFocus() {
            return $$props.onCloseAutoFocus;
          },
          get loop() {
            return $$props.loop;
          },
          get trapFocus() {
            return get(trapFocus_1);
          },
          get forceMount() {
            return $$props.forceMount;
          },
          focusScope,
          $$slots: { focusScope: true }
        });
      }
      append($$anchor2, fragment_1);
    });
    popper_content_default(node, {
      get isStatic() {
        return isStatic();
      },
      get id() {
        return $$props.id;
      },
      get side() {
        return $$props.side;
      },
      get sideOffset() {
        return $$props.sideOffset;
      },
      get align() {
        return $$props.align;
      },
      get alignOffset() {
        return $$props.alignOffset;
      },
      get arrowPadding() {
        return $$props.arrowPadding;
      },
      get avoidCollisions() {
        return $$props.avoidCollisions;
      },
      get collisionBoundary() {
        return $$props.collisionBoundary;
      },
      get collisionPadding() {
        return $$props.collisionPadding;
      },
      get sticky() {
        return $$props.sticky;
      },
      get hideWhenDetached() {
        return $$props.hideWhenDetached;
      },
      get updatePositionStrategy() {
        return $$props.updatePositionStrategy;
      },
      get strategy() {
        return $$props.strategy;
      },
      get dir() {
        return $$props.dir;
      },
      get wrapperId() {
        return $$props.wrapperId;
      },
      get style() {
        return $$props.style;
      },
      get onPlaced() {
        return $$props.onPlaced;
      },
      get customAnchor() {
        return customAnchor();
      },
      content,
      $$slots: { content: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer_inner = hmr(Popper_layer_inner, () => Popper_layer_inner[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer_inner[HMR].source;
    set(Popper_layer_inner[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_inner_default = Popper_layer_inner;
mark_module_end(Popper_layer_inner);

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte
mark_module_start();
Popper_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte";
function Popper_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer);
  validate_prop_bindings($$props, [], [], Popper_layer);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "present",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Popper_layer, ($$anchor2, $$arg0) => {
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      popper_layer_inner_default(node_1, spread_props(
        {
          get popper() {
            return $$props.popper;
          },
          get onEscapeKeydown() {
            return $$props.onEscapeKeydown;
          },
          get escapeKeydownBehavior() {
            return $$props.escapeKeydownBehavior;
          },
          get preventOverflowTextSelection() {
            return $$props.preventOverflowTextSelection;
          },
          get id() {
            return $$props.id;
          },
          get onPointerDown() {
            return $$props.onPointerDown;
          },
          get onPointerUp() {
            return $$props.onPointerUp;
          },
          get side() {
            return $$props.side;
          },
          get sideOffset() {
            return $$props.sideOffset;
          },
          get align() {
            return $$props.align;
          },
          get alignOffset() {
            return $$props.alignOffset;
          },
          get arrowPadding() {
            return $$props.arrowPadding;
          },
          get avoidCollisions() {
            return $$props.avoidCollisions;
          },
          get collisionBoundary() {
            return $$props.collisionBoundary;
          },
          get collisionPadding() {
            return $$props.collisionPadding;
          },
          get sticky() {
            return $$props.sticky;
          },
          get hideWhenDetached() {
            return $$props.hideWhenDetached;
          },
          get updatePositionStrategy() {
            return $$props.updatePositionStrategy;
          },
          get strategy() {
            return $$props.strategy;
          },
          get dir() {
            return $$props.dir;
          },
          get preventScroll() {
            return $$props.preventScroll;
          },
          get wrapperId() {
            return $$props.wrapperId;
          },
          get style() {
            return $$props.style;
          },
          get onPlaced() {
            return $$props.onPlaced;
          },
          get customAnchor() {
            return customAnchor();
          },
          get isStatic() {
            return isStatic();
          },
          get enabled() {
            return present().current;
          },
          get onInteractOutside() {
            return $$props.onInteractOutside;
          },
          get onCloseAutoFocus() {
            return $$props.onCloseAutoFocus;
          },
          get onOpenAutoFocus() {
            return $$props.onOpenAutoFocus;
          },
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get loop() {
            return $$props.loop;
          },
          get trapFocus() {
            return trapFocus();
          },
          get isValidEvent() {
            return isValidEvent2();
          },
          get onFocusOutside() {
            return $$props.onFocusOutside;
          },
          forceMount: false
        },
        () => restProps
      ));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(
      {
        get id() {
          return $$props.id;
        },
        get present() {
          return $$props.present;
        }
      },
      () => restProps,
      { presence, $$slots: { presence: true } }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer = hmr(Popper_layer, () => Popper_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer[HMR].source;
    set(Popper_layer[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_default = Popper_layer;
mark_module_end(Popper_layer);

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte
mark_module_start();
Popper_layer_force_mount[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte";
function Popper_layer_force_mount($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer_force_mount);
  validate_prop_bindings($$props, [], [], Popper_layer_force_mount);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "enabled"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  popper_layer_inner_default(node, spread_props(
    {
      get popper() {
        return $$props.popper;
      },
      get onEscapeKeydown() {
        return $$props.onEscapeKeydown;
      },
      get escapeKeydownBehavior() {
        return $$props.escapeKeydownBehavior;
      },
      get preventOverflowTextSelection() {
        return $$props.preventOverflowTextSelection;
      },
      get id() {
        return $$props.id;
      },
      get onPointerDown() {
        return $$props.onPointerDown;
      },
      get onPointerUp() {
        return $$props.onPointerUp;
      },
      get side() {
        return $$props.side;
      },
      get sideOffset() {
        return $$props.sideOffset;
      },
      get align() {
        return $$props.align;
      },
      get alignOffset() {
        return $$props.alignOffset;
      },
      get arrowPadding() {
        return $$props.arrowPadding;
      },
      get avoidCollisions() {
        return $$props.avoidCollisions;
      },
      get collisionBoundary() {
        return $$props.collisionBoundary;
      },
      get collisionPadding() {
        return $$props.collisionPadding;
      },
      get sticky() {
        return $$props.sticky;
      },
      get hideWhenDetached() {
        return $$props.hideWhenDetached;
      },
      get updatePositionStrategy() {
        return $$props.updatePositionStrategy;
      },
      get strategy() {
        return $$props.strategy;
      },
      get dir() {
        return $$props.dir;
      },
      get preventScroll() {
        return $$props.preventScroll;
      },
      get wrapperId() {
        return $$props.wrapperId;
      },
      get style() {
        return $$props.style;
      },
      get onPlaced() {
        return $$props.onPlaced;
      },
      get customAnchor() {
        return customAnchor();
      },
      get isStatic() {
        return isStatic();
      },
      get enabled() {
        return $$props.enabled;
      },
      get onInteractOutside() {
        return $$props.onInteractOutside;
      },
      get onCloseAutoFocus() {
        return $$props.onCloseAutoFocus;
      },
      get onOpenAutoFocus() {
        return $$props.onOpenAutoFocus;
      },
      get interactOutsideBehavior() {
        return interactOutsideBehavior();
      },
      get loop() {
        return $$props.loop;
      },
      get trapFocus() {
        return trapFocus();
      },
      get isValidEvent() {
        return isValidEvent2();
      },
      get onFocusOutside() {
        return $$props.onFocusOutside;
      }
    },
    () => restProps,
    { forceMount: true }
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer_force_mount = hmr(Popper_layer_force_mount, () => Popper_layer_force_mount[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer_force_mount[HMR].source;
    set(Popper_layer_force_mount[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_force_mount_default = Popper_layer_force_mount;
mark_module_end(Popper_layer_force_mount);

// node_modules/bits-ui/dist/bits/select/components/select-content.svelte
mark_module_start();
Select_content[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-content.svelte";
var root_42 = add_locations(template(`<div><!></div>`), Select_content[FILENAME], [[69, 4]]);
var root_9 = add_locations(template(`<div><!></div>`), Select_content[FILENAME], [[96, 4]]);
function Select_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_content);
  validate_prop_bindings($$props, ["ref"], [], Select_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), side = prop($$props, "side", 3, "bottom"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "side",
      "onInteractOutside",
      "onEscapeKeydown",
      "children",
      "child",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = useSelectContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Select_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = derived(() => mergeProps(props(), { style: contentState.props.style }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_42();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get side() {
            return side();
          },
          get enabled() {
            return contentState.root.open.current;
          },
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onOpenAutoFocus: (e) => e.preventDefault(),
          onCloseAutoFocus: (e) => e.preventDefault(),
          trapFocus: false,
          loop: false,
          get preventScroll() {
            return preventScroll();
          },
          onPlaced: () => contentState.isPositioned = true,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Select_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = comment();
              const finalProps = derived(() => mergeProps(props(), { style: contentState.props.style }));
              get(finalProps);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_9();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              get side() {
                return side();
              },
              get present() {
                return contentState.root.open.current;
              },
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onOpenAutoFocus: (e) => e.preventDefault(),
              onCloseAutoFocus: (e) => e.preventDefault(),
              trapFocus: false,
              loop: false,
              get preventScroll() {
                return preventScroll();
              },
              onPlaced: () => contentState.isPositioned = true,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_content = hmr(Select_content, () => Select_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_content[HMR].source;
    set(Select_content[HMR].source, module.default[HMR].original);
  });
}
var select_content_default = Select_content;
mark_module_end(Select_content);

// node_modules/bits-ui/dist/bits/select/components/select-content-static.svelte
mark_module_start();
Select_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-content-static.svelte";
var root_43 = add_locations(template(`<div><!></div>`), Select_content_static[FILENAME], [[69, 4]]);
var root_92 = add_locations(template(`<div><!></div>`), Select_content_static[FILENAME], [[97, 4]]);
function Select_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_content_static);
  validate_prop_bindings($$props, ["ref"], [], Select_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), side = prop($$props, "side", 3, "bottom"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "side",
      "onInteractOutside",
      "onEscapeKeydown",
      "children",
      "child"
    ],
    "restProps"
  );
  const contentState = useSelectContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Select_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = derived(() => mergeProps(props(), { style: contentState.props.style }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_43();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          isStatic: true,
          get side() {
            return side();
          },
          get enabled() {
            return contentState.root.open.current;
          },
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onOpenAutoFocus: (e) => e.preventDefault(),
          onCloseAutoFocus: (e) => e.preventDefault(),
          trapFocus: false,
          loop: false,
          preventScroll: false,
          onPlaced: () => contentState.isPositioned = true,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Select_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = comment();
              const finalProps = derived(() => mergeProps(props(), { style: contentState.props.style }));
              get(finalProps);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_92();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              isStatic: true,
              get side() {
                return side();
              },
              get present() {
                return contentState.root.open.current;
              },
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onOpenAutoFocus: (e) => e.preventDefault(),
              onCloseAutoFocus: (e) => e.preventDefault(),
              trapFocus: false,
              loop: false,
              preventScroll: false,
              onPlaced: () => contentState.isPositioned = true,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_content_static = hmr(Select_content_static, () => Select_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_content_static[HMR].source;
    set(Select_content_static[HMR].source, module.default[HMR].original);
  });
}
var select_content_static_default = Select_content_static;
mark_module_end(Select_content_static);

// node_modules/bits-ui/dist/bits/utilities/mounted.svelte
mark_module_start();
Mounted[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/mounted.svelte";
function Mounted($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mounted);
  validate_prop_bindings($$props, ["isMounted"], [], Mounted);
  let isMounted = prop($$props, "isMounted", 15, false), onMountedChange = prop($$props, "onMountedChange", 3, noop2);
  user_effect(() => {
    untrack(() => {
      isMounted(true);
      onMountedChange()(true);
    });
    return () => {
      isMounted(false);
      onMountedChange()(false);
    };
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mounted = hmr(Mounted, () => Mounted[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mounted[HMR].source;
    set(Mounted[HMR].source, module.default[HMR].original);
  });
}
var mounted_default = Mounted;
mark_module_end(Mounted);

// node_modules/bits-ui/dist/bits/select/components/select-item.svelte
mark_module_start();
Select_item[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-item.svelte";
var root_235 = add_locations(template(`<div><!></div>`), Select_item[FILENAME], [[41, 1]]);
var root5 = add_locations(template(`<!> <!>`, 1), Select_item[FILENAME], []);
function Select_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_item);
  validate_prop_bindings($$props, ["ref"], [], Select_item);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), label = prop($$props, "label", 19, () => $$props.value), disabled = prop($$props, "disabled", 3, false), onHighlight = prop($$props, "onHighlight", 3, noop2), onUnhighlight = prop($$props, "onUnhighlight", 3, noop2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "label",
      "disabled",
      "children",
      "child",
      "onHighlight",
      "onUnhighlight"
    ],
    "restProps"
  );
  const itemState = useSelectItem({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled()),
    label: box.with(() => label()),
    onHighlight: box.with(() => onHighlight()),
    onUnhighlight: box.with(() => onUnhighlight())
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props));
  var fragment = root5();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_235();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  var node_3 = sibling(node, 2);
  mounted_default(node_3, {
    onMountedChange: (m) => {
      itemState.mounted = m;
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_item = hmr(Select_item, () => Select_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_item[HMR].source;
    set(Select_item[HMR].source, module.default[HMR].original);
  });
}
var select_item_default = Select_item;
mark_module_end(Select_item);

// node_modules/bits-ui/dist/bits/select/components/select-group.svelte
mark_module_start();
Select_group[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-group.svelte";
var root_236 = add_locations(template(`<div><!></div>`), Select_group[FILENAME], [[29, 1]]);
function Select_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_group);
  validate_prop_bindings($$props, ["ref"], [], Select_group);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = useSelectGroup({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_236();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_group = hmr(Select_group, () => Select_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_group[HMR].source;
    set(Select_group[HMR].source, module.default[HMR].original);
  });
}
var select_group_default = Select_group;
mark_module_end(Select_group);

// node_modules/bits-ui/dist/bits/select/components/select-group-heading.svelte
mark_module_start();
Select_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-group-heading.svelte";
var root_237 = add_locations(template(`<div><!></div>`), Select_group_heading[FILENAME], [[29, 1]]);
function Select_group_heading($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_group_heading);
  validate_prop_bindings($$props, ["ref"], [], Select_group_heading);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children"
    ],
    "restProps"
  );
  const groupHeadingState = useSelectGroupHeading({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, groupHeadingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_237();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_group_heading = hmr(Select_group_heading, () => Select_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_group_heading[HMR].source;
    set(Select_group_heading[HMR].source, module.default[HMR].original);
  });
}
var select_group_heading_default = Select_group_heading;
mark_module_end(Select_group_heading);

// node_modules/bits-ui/dist/bits/select/components/select-viewport.svelte
mark_module_start();
Select_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-viewport.svelte";
var root_238 = add_locations(template(`<div><!></div>`), Select_viewport[FILENAME], [[29, 1]]);
var $$css = {
  hash: "s-h2z5b8x4s9UG",
  code: "\r\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */\r\n	[data-select-viewport] {\r\n		scrollbar-width: none !important;\r\n		-ms-overflow-style: none !important;\r\n		-webkit-overflow-scrolling: touch !important;\r\n	}\r\n\r\n	[data-combobox-viewport] {\r\n		scrollbar-width: none !important;\r\n		-ms-overflow-style: none !important;\r\n		-webkit-overflow-scrolling: touch !important;\r\n	}\r\n\r\n	[data-combobox-viewport]::-webkit-scrollbar {\r\n		display: none !important;\r\n	}\r\n	[data-select-viewport]::-webkit-scrollbar {\r\n		display: none !important;\r\n	}\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LXZpZXdwb3J0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpQ00iLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbInNlbGVjdC12aWV3cG9ydC5zdmVsdGUiXX0= */"
};
function Select_viewport($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_viewport);
  append_styles($$anchor, $$css);
  validate_prop_bindings($$props, ["ref"], [], Select_viewport);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const viewportState = useSelectViewport({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, viewportState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_238();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }, "s-h2z5b8x4s9UG"));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_viewport = hmr(Select_viewport, () => Select_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-h2z5b8x4s9UG");
    module.default[HMR].source = Select_viewport[HMR].source;
    set(Select_viewport[HMR].source, module.default[HMR].original);
  });
}
var select_viewport_default = Select_viewport;
mark_module_end(Select_viewport);

// node_modules/bits-ui/dist/bits/select/components/select-scroll-down-button.svelte
mark_module_start();
Select_scroll_down_button[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-scroll-down-button.svelte";
var root_35 = add_locations(template(`<div><!></div>`), Select_scroll_down_button[FILENAME], [[35, 2]]);
var root_12 = add_locations(template(`<!> <!>`, 1), Select_scroll_down_button[FILENAME], []);
function Select_scroll_down_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_scroll_down_button);
  validate_prop_bindings($$props, ["ref"], [], Select_scroll_down_button);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children"
    ],
    "restProps"
  );
  let mounted = state(false);
  const scrollDownButtonState = useSelectScrollDownButton({
    id: box.with(() => id()),
    mounted: box.with(() => get(mounted)),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, scrollDownButtonState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => scrollDownButtonState.canScrollDown, ($$anchor2) => {
    var fragment_1 = root_12();
    var node_1 = first_child(fragment_1);
    mounted_default(node_1, {
      onMountedChange: (m) => set(mounted, proxy(m, null, mounted))
    });
    var node_2 = sibling(node_1, 2);
    if_block(
      node_2,
      () => $$props.child,
      ($$anchor3) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        snippet(node_3, () => $$props.child, () => ({ props: restProps }));
        append($$anchor3, fragment_2);
      },
      ($$anchor3) => {
        var div = root_35();
        let attributes;
        var node_4 = child(div);
        snippet(node_4, () => $$props.children ?? noop);
        reset(div);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
        append($$anchor3, div);
      }
    );
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_scroll_down_button = hmr(Select_scroll_down_button, () => Select_scroll_down_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_scroll_down_button[HMR].source;
    set(Select_scroll_down_button[HMR].source, module.default[HMR].original);
  });
}
var select_scroll_down_button_default = Select_scroll_down_button;
mark_module_end(Select_scroll_down_button);

// node_modules/bits-ui/dist/bits/select/components/select-scroll-up-button.svelte
mark_module_start();
Select_scroll_up_button[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-scroll-up-button.svelte";
var root_36 = add_locations(template(`<div><!></div>`), Select_scroll_up_button[FILENAME], [[35, 2]]);
var root_13 = add_locations(template(`<!> <!>`, 1), Select_scroll_up_button[FILENAME], []);
function Select_scroll_up_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_scroll_up_button);
  validate_prop_bindings($$props, ["ref"], [], Select_scroll_up_button);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children"
    ],
    "restProps"
  );
  let mounted = state(false);
  const scrollDownButtonState = useSelectScrollUpButton({
    id: box.with(() => id()),
    mounted: box.with(() => get(mounted)),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, scrollDownButtonState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => scrollDownButtonState.canScrollUp, ($$anchor2) => {
    var fragment_1 = root_13();
    var node_1 = first_child(fragment_1);
    mounted_default(node_1, {
      onMountedChange: (m) => set(mounted, proxy(m, null, mounted))
    });
    var node_2 = sibling(node_1, 2);
    if_block(
      node_2,
      () => $$props.child,
      ($$anchor3) => {
        var fragment_2 = comment();
        var node_3 = first_child(fragment_2);
        snippet(node_3, () => $$props.child, () => ({ props: restProps }));
        append($$anchor3, fragment_2);
      },
      ($$anchor3) => {
        var div = root_36();
        let attributes;
        var node_4 = child(div);
        snippet(node_4, () => $$props.children ?? noop);
        reset(div);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
        append($$anchor3, div);
      }
    );
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_scroll_up_button = hmr(Select_scroll_up_button, () => Select_scroll_up_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_scroll_up_button[HMR].source;
    set(Select_scroll_up_button[HMR].source, module.default[HMR].original);
  });
}
var select_scroll_up_button_default = Select_scroll_up_button;
mark_module_end(Select_scroll_up_button);

// node_modules/bits-ui/dist/bits/command/exports.js
var exports_exports10 = {};
__export(exports_exports10, {
  Empty: () => command_empty_default,
  Group: () => command_group_default,
  GroupHeading: () => command_group_heading_default,
  GroupItems: () => command_group_items_default,
  Input: () => command_input_default,
  Item: () => command_item_default,
  LinkItem: () => command_link_item_default,
  List: () => command_list_default,
  Loading: () => command_loading_default,
  Root: () => command_default,
  Separator: () => command_separator_default,
  Viewport: () => command_viewport_default
});

// node_modules/bits-ui/dist/bits/command/utils.js
function findNextSibling(el, selector) {
  let sibling2 = el.nextElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.nextElementSibling;
  }
}
function findPreviousSibling(el, selector) {
  let sibling2 = el.previousElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.previousElementSibling;
  }
}

// node_modules/bits-ui/dist/bits/command/command-score.js
var SCORE_CONTINUE_MATCH = 1;
var SCORE_SPACE_WORD_JUMP = 0.9;
var SCORE_NON_SPACE_WORD_JUMP = 0.8;
var SCORE_CHARACTER_JUMP = 0.17;
var SCORE_TRANSPOSITION = 0.1;
var PENALTY_SKIPPED = 0.999;
var PENALTY_CASE_MISMATCH = 0.9999;
var PENALTY_NOT_COMPLETE = 0.99;
var IS_GAP_REGEXP = /[\\/_+.#"@[({&]/;
var COUNT_GAPS_REGEXP = /[\\/_+.#"@[({&]/g;
var IS_SPACE_REGEXP = /[\s-]/;
var COUNT_SPACE_REGEXP = /[\s-]/g;
function commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex, memoizedResults) {
  if (abbreviationIndex === abbreviation.length) {
    if (stringIndex === string.length) {
      return SCORE_CONTINUE_MATCH;
    }
    return PENALTY_NOT_COMPLETE;
  }
  const memoizeKey = `${stringIndex},${abbreviationIndex}`;
  if (memoizedResults[memoizeKey] !== void 0) {
    return memoizedResults[memoizeKey];
  }
  const abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);
  let index2 = lowerString.indexOf(abbreviationChar, stringIndex);
  let highScore = 0;
  let score, transposedScore, wordBreaks, spaceBreaks;
  while (index2 >= 0) {
    score = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index2 + 1, abbreviationIndex + 1, memoizedResults);
    if (score > highScore) {
      if (index2 === stringIndex) {
        score *= SCORE_CONTINUE_MATCH;
      } else if (IS_GAP_REGEXP.test(string.charAt(index2 - 1))) {
        score *= SCORE_NON_SPACE_WORD_JUMP;
        wordBreaks = string.slice(stringIndex, index2 - 1).match(COUNT_GAPS_REGEXP);
        if (wordBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** wordBreaks.length;
        }
      } else if (IS_SPACE_REGEXP.test(string.charAt(index2 - 1))) {
        score *= SCORE_SPACE_WORD_JUMP;
        spaceBreaks = string.slice(stringIndex, index2 - 1).match(COUNT_SPACE_REGEXP);
        if (spaceBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** spaceBreaks.length;
        }
      } else {
        score *= SCORE_CHARACTER_JUMP;
        if (stringIndex > 0) {
          score *= PENALTY_SKIPPED ** (index2 - stringIndex);
        }
      }
      if (string.charAt(index2) !== abbreviation.charAt(abbreviationIndex)) {
        score *= PENALTY_CASE_MISMATCH;
      }
    }
    if (score < SCORE_TRANSPOSITION && lowerString.charAt(index2 - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) || lowerAbbreviation.charAt(abbreviationIndex + 1) === lowerAbbreviation.charAt(abbreviationIndex) && // allow duplicate letters. Ref #7428
    lowerString.charAt(index2 - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {
      transposedScore = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index2 + 1, abbreviationIndex + 2, memoizedResults);
      if (transposedScore * SCORE_TRANSPOSITION > score) {
        score = transposedScore * SCORE_TRANSPOSITION;
      }
    }
    if (score > highScore) {
      highScore = score;
    }
    index2 = lowerString.indexOf(abbreviationChar, index2 + 1);
  }
  memoizedResults[memoizeKey] = highScore;
  return highScore;
}
function formatInput(string) {
  return string.toLowerCase().replace(COUNT_SPACE_REGEXP, " ");
}
function commandScore(string, abbreviation, aliases) {
  string = aliases && aliases.length > 0 ? `${`${string} ${aliases == null ? void 0 : aliases.join(" ")}`}` : string;
  return commandScoreInner(string, abbreviation, formatInput(string), formatInput(abbreviation), 0, 0, {});
}

// node_modules/bits-ui/dist/internal/dom.js
function getFirstNonCommentChild(element2) {
  if (!element2)
    return null;
  for (const child2 of element2.childNodes) {
    if (child2.nodeType !== Node.COMMENT_NODE) {
      return child2;
    }
  }
  return null;
}

// node_modules/bits-ui/dist/bits/command/command.svelte.js
var ROOT_ATTR2 = "data-command-root";
var LIST_ATTR = "data-command-list";
var INPUT_ATTR = "data-command-input";
var SEPARATOR_ATTR = "data-command-separator";
var LOADING_ATTR = "data-command-loading";
var EMPTY_ATTR = "data-command-empty";
var GROUP_ATTR = "data-command-group";
var GROUP_ITEMS_ATTR = "data-command-group-items";
var GROUP_HEADING_ATTR = "data-command-group-heading";
var ITEM_ATTR = "data-command-item";
var VALUE_ATTR = `data-value`;
var VIEWPORT_ATTR = "data-command-viewport";
var INPUT_LABEL_ATTR = "data-command-input-label";
var GROUP_SELECTOR = `[${GROUP_ATTR}]`;
var GROUP_ITEMS_SELECTOR = `[${GROUP_ITEMS_ATTR}]`;
var GROUP_HEADING_SELECTOR = `[${GROUP_HEADING_ATTR}]`;
var ITEM_SELECTOR = `[${ITEM_ATTR}]`;
var VALID_ITEM_SELECTOR = `${ITEM_SELECTOR}:not([aria-disabled="true"])`;
function defaultFilter(value, search, keywords) {
  return commandScore(value, search, keywords);
}
var [setCommandRootContext, getCommandRootContext] = createContext("Command.Root");
var [setCommandListContext, getCommandListContext] = createContext("Command.List");
var [
  setCommandGroupContainerContext,
  getCommandGroupContainerContext
] = createContext("Command.Group");
var _key, _viewportNode2, _inputNode2, _labelNode2, _vimBindings, _commandState, __commandState, _score, _sort, _selectFirstItem, _filterItems, _getValidItems, _getSelectedItem, _scrollSelectedIntoView, _updateSelectedToIndex, _updateSelectedByItem, _updateSelectedByGroup, _last, _next, _prev, _onkeydown12, _props50;
var CommandRootState = class {
  constructor(props) {
    __publicField(this, "allItems", /* @__PURE__ */ new Set());
    // [...itemIds]
    __publicField(this, "allGroups", /* @__PURE__ */ new Map());
    // groupId  [...itemIds]
    __publicField(this, "allIds", /* @__PURE__ */ new Map());
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "filter");
    __publicField(this, "shouldFilter");
    __publicField(this, "loop");
    __privateAdd(this, _key, state(0));
    __privateAdd(this, _viewportNode2, state(null));
    __privateAdd(this, _inputNode2, state(null));
    __privateAdd(this, _labelNode2, state(null));
    __publicField(this, "valueProp");
    __privateAdd(this, _vimBindings);
    __publicField(this, "disablePointerSelection");
    __privateAdd(this, _commandState, state(null));
    __privateAdd(this, __commandState, state(null));
    __publicField(this, "snapshot", () => this._commandState);
    __publicField(this, "setState", (key, value, opts) => {
      if (Object.is(this._commandState[key], value)) return;
      this._commandState[key] = value;
      if (strict_equals(key, "search")) {
        __privateGet(this, _filterItems).call(this);
        __privateGet(this, _sort).call(this);
        __privateGet(this, _selectFirstItem).call(this);
      } else if (strict_equals(key, "value")) {
        if (!opts) {
          __privateGet(this, _scrollSelectedIntoView).call(this);
        }
      }
      this.emit();
    });
    __publicField(this, "emit", () => {
      this.commandState = snapshot(this._commandState);
    });
    __privateAdd(this, _score, (value, keywords) => {
      const filter = this.filter.current ?? defaultFilter;
      const score = value ? filter(value, this._commandState.search, keywords) : 0;
      return score;
    });
    __privateAdd(this, _sort, () => {
      var _a;
      if (!this._commandState.search || strict_equals(this.shouldFilter.current, false)) return;
      const scores = this._commandState.filtered.items;
      const groups = [];
      for (const value of this._commandState.filtered.groups) {
        const items = this.allGroups.get(value);
        let max = 0;
        if (!items) {
          groups.push([value, max]);
          continue;
        }
        for (const item of items) {
          const score = scores.get(item);
          max = Math.max(score ?? 0, max);
        }
        groups.push([value, max]);
      }
      const listInsertionElement = this.viewportNode;
      const sorted = __privateGet(this, _getValidItems).call(this).sort((a2, b) => {
        const valueA = a2.getAttribute("id");
        const valueB = b.getAttribute("id");
        const scoresA = scores.get(valueA) ?? 0;
        const scoresB = scores.get(valueB) ?? 0;
        return scoresB - scoresA;
      });
      for (const item of sorted) {
        const group = item.closest(GROUP_ITEMS_SELECTOR);
        if (group) {
          const itemToAppend = strict_equals(item.parentElement, group) ? item : item.closest(`${GROUP_ITEMS_SELECTOR} > *`);
          if (itemToAppend) {
            group.appendChild(itemToAppend);
          }
        } else {
          const itemToAppend = strict_equals(item.parentElement, listInsertionElement) ? item : item.closest(`${GROUP_ITEMS_SELECTOR} > *`);
          if (itemToAppend) {
            listInsertionElement == null ? void 0 : listInsertionElement.appendChild(itemToAppend);
          }
        }
      }
      const sortedGroups = groups.sort((a2, b) => b[1] - a2[1]);
      for (const group of sortedGroups) {
        const element2 = listInsertionElement == null ? void 0 : listInsertionElement.querySelector(`${GROUP_SELECTOR}[${VALUE_ATTR}="${encodeURIComponent(group[0])}"]`);
        (_a = element2 == null ? void 0 : element2.parentElement) == null ? void 0 : _a.appendChild(element2);
      }
    });
    __publicField(this, "setValue", (value, opts) => {
      if (strict_equals(value, this.valueProp.current, false) && strict_equals(value, "")) {
        afterTick(() => {
          this.key++;
        });
      }
      this.setState("value", value, opts);
      this.valueProp.current = value;
    });
    __privateAdd(this, _selectFirstItem, () => {
      afterTick(() => {
        const item = __privateGet(this, _getValidItems).call(this).find((item2) => strict_equals(item2.getAttribute("aria-disabled"), "true", false));
        const value = item == null ? void 0 : item.getAttribute(VALUE_ATTR);
        this.setValue(value || "");
      });
    });
    __privateAdd(this, _filterItems, () => {
      var _a, _b;
      if (!this._commandState.search || strict_equals(this.shouldFilter.current, false)) {
        this._commandState.filtered.count = this.allItems.size;
        return;
      }
      this._commandState.filtered.groups = /* @__PURE__ */ new Set();
      let itemCount = 0;
      for (const id of this.allItems) {
        const value = ((_a = this.allIds.get(id)) == null ? void 0 : _a.value) ?? "";
        const keywords = ((_b = this.allIds.get(id)) == null ? void 0 : _b.keywords) ?? [];
        const rank = __privateGet(this, _score).call(this, value, keywords);
        this._commandState.filtered.items.set(id, rank);
        if (rank > 0) itemCount += 1;
      }
      for (const [groupId, group] of this.allGroups) {
        for (const itemId of group) {
          const currItem = this._commandState.filtered.items.get(itemId);
          if (currItem && currItem > 0) {
            this._commandState.filtered.groups.add(groupId);
            break;
          }
        }
      }
      this._commandState.filtered.count = itemCount;
    });
    __privateAdd(this, _getValidItems, () => {
      const node = this.ref.current;
      if (!node) return [];
      const validItems = Array.from(node.querySelectorAll(VALID_ITEM_SELECTOR)).filter((el) => !!el);
      return validItems;
    });
    __privateAdd(this, _getSelectedItem, () => {
      const node = this.ref.current;
      if (!node) return;
      const selectedNode = node.querySelector(`${VALID_ITEM_SELECTOR}[aria-selected="true"]`);
      if (!selectedNode) return;
      return selectedNode;
    });
    __privateAdd(this, _scrollSelectedIntoView, () => {
      afterSleep(1, () => {
        var _a, _b, _c, _d, _e;
        const item = __privateGet(this, _getSelectedItem).call(this);
        if (!item) return;
        const grandparent = (_a = item.parentElement) == null ? void 0 : _a.parentElement;
        if (!grandparent) return;
        const firstChildOfParent = getFirstNonCommentChild(grandparent);
        if (firstChildOfParent && strict_equals((_b = firstChildOfParent.dataset) == null ? void 0 : _b.value, (_c = item.dataset) == null ? void 0 : _c.value)) {
          (_e = (_d = item == null ? void 0 : item.closest(GROUP_SELECTOR)) == null ? void 0 : _d.querySelector(GROUP_HEADING_SELECTOR)) == null ? void 0 : _e.scrollIntoView({ block: "nearest" });
          return;
        }
        item.scrollIntoView({ block: "nearest" });
      });
    });
    __privateAdd(this, _updateSelectedToIndex, (index2) => {
      const items = __privateGet(this, _getValidItems).call(this);
      const item = items[index2];
      if (item) {
        this.setValue(item.getAttribute(VALUE_ATTR) ?? "");
      }
    });
    __privateAdd(this, _updateSelectedByItem, (change) => {
      const selected = __privateGet(this, _getSelectedItem).call(this);
      const items = __privateGet(this, _getValidItems).call(this);
      const index2 = items.findIndex((item) => strict_equals(item, selected));
      let newSelected = items[index2 + change];
      if (this.loop.current) {
        newSelected = index2 + change < 0 ? items[items.length - 1] : strict_equals(index2 + change, items.length) ? items[0] : items[index2 + change];
      }
      if (newSelected) {
        this.setValue(newSelected.getAttribute(VALUE_ATTR) ?? "");
      }
    });
    __privateAdd(this, _updateSelectedByGroup, (change) => {
      const selected = __privateGet(this, _getSelectedItem).call(this);
      let group = selected == null ? void 0 : selected.closest(GROUP_SELECTOR);
      let item;
      while (group && !item) {
        group = change > 0 ? findNextSibling(group, GROUP_SELECTOR) : findPreviousSibling(group, GROUP_SELECTOR);
        item = group == null ? void 0 : group.querySelector(VALID_ITEM_SELECTOR);
      }
      if (item) {
        this.setValue(item.getAttribute(VALUE_ATTR) ?? "");
      } else {
        __privateGet(this, _updateSelectedByItem).call(this, change);
      }
    });
    // keep id -> { value, keywords } mapping up to date
    __publicField(this, "registerValue", (id, value, keywords) => {
      var _a;
      if (strict_equals(value, (_a = this.allIds.get(id)) == null ? void 0 : _a.value)) return;
      this.allIds.set(id, { value, keywords });
      this._commandState.filtered.items.set(id, __privateGet(this, _score).call(this, value, keywords));
      __privateGet(this, _sort).call(this);
      this.emit();
      return () => {
        this.allIds.delete(id);
      };
    });
    __publicField(this, "registerItem", (id, groupId) => {
      this.allItems.add(id);
      if (groupId) {
        if (!this.allGroups.has(groupId)) {
          this.allGroups.set(groupId, /* @__PURE__ */ new Set([id]));
        } else {
          this.allGroups.get(groupId).add(id);
        }
      }
      __privateGet(this, _filterItems).call(this);
      __privateGet(this, _sort).call(this);
      if (!this.commandState.value) {
        __privateGet(this, _selectFirstItem).call(this);
      }
      this.emit();
      return () => {
        this.allIds.delete(id);
        this.allItems.delete(id);
        this.commandState.filtered.items.delete(id);
        const selectedItem = __privateGet(this, _getSelectedItem).call(this);
        __privateGet(this, _filterItems).call(this);
        if (strict_equals(selectedItem == null ? void 0 : selectedItem.getAttribute("id"), id)) __privateGet(this, _selectFirstItem).call(this);
        this.emit();
      };
    });
    __publicField(this, "registerGroup", (id) => {
      if (!this.allGroups.has(id)) {
        this.allGroups.set(id, /* @__PURE__ */ new Set());
      }
      return () => {
        this.allIds.delete(id);
        this.allGroups.delete(id);
      };
    });
    __privateAdd(this, _last, () => {
      return __privateGet(this, _updateSelectedToIndex).call(this, __privateGet(this, _getValidItems).call(this).length - 1);
    });
    __privateAdd(this, _next, (e) => {
      e.preventDefault();
      if (e.metaKey) {
        __privateGet(this, _last).call(this);
      } else if (e.altKey) {
        __privateGet(this, _updateSelectedByGroup).call(this, 1);
      } else {
        __privateGet(this, _updateSelectedByItem).call(this, 1);
      }
    });
    __privateAdd(this, _prev, (e) => {
      e.preventDefault();
      if (e.metaKey) {
        __privateGet(this, _updateSelectedToIndex).call(this, 0);
      } else if (e.altKey) {
        __privateGet(this, _updateSelectedByGroup).call(this, -1);
      } else {
        __privateGet(this, _updateSelectedByItem).call(this, -1);
      }
    });
    __privateAdd(this, _onkeydown12, (e) => {
      switch (e.key) {
        case kbd_constants_exports.n:
        case kbd_constants_exports.j: {
          if (__privateGet(this, _vimBindings).current && e.ctrlKey) {
            __privateGet(this, _next).call(this, e);
          }
          break;
        }
        case kbd_constants_exports.ARROW_DOWN:
          __privateGet(this, _next).call(this, e);
          break;
        case kbd_constants_exports.p:
        case kbd_constants_exports.k: {
          if (__privateGet(this, _vimBindings).current && e.ctrlKey) {
            __privateGet(this, _prev).call(this, e);
          }
          break;
        }
        case kbd_constants_exports.ARROW_UP:
          __privateGet(this, _prev).call(this, e);
          break;
        case kbd_constants_exports.HOME:
          e.preventDefault();
          __privateGet(this, _updateSelectedToIndex).call(this, 0);
          break;
        case kbd_constants_exports.END:
          e.preventDefault();
          __privateGet(this, _last).call(this);
          break;
        case kbd_constants_exports.ENTER: {
          if (!e.isComposing && strict_equals(e.keyCode, 229, false)) {
            e.preventDefault();
            const item = __privateGet(this, _getSelectedItem).call(this);
            if (item) {
              item == null ? void 0 : item.click();
            }
          }
        }
      }
    });
    __privateAdd(this, _props50, derived(() => ({
      id: this.id.current,
      role: "application",
      [ROOT_ATTR2]: "",
      tabindex: -1,
      onkeydown: __privateGet(this, _onkeydown12)
    })));
    this.id = props.id;
    this.ref = props.ref;
    this.filter = props.filter;
    this.shouldFilter = props.shouldFilter;
    this.loop = props.loop;
    this.valueProp = props.value;
    __privateSet(this, _vimBindings, props.vimBindings);
    this.disablePointerSelection = props.disablePointerSelection;
    const defaultState = {
      /** Value of the search query */
      search: "",
      /** Currently selected item value */
      value: this.valueProp.current ?? "",
      filtered: {
        /** The count of all visible items. */
        count: 0,
        /** Map from visible item id to its search store. */
        items: /* @__PURE__ */ new Map(),
        /** Set of groups with at least one visible item. */
        groups: /* @__PURE__ */ new Set()
      }
    };
    this._commandState = defaultState;
    this.commandState = defaultState;
    useRefById({ id: this.id, ref: this.ref });
  }
  get key() {
    return get(__privateGet(this, _key));
  }
  set key(value) {
    set(__privateGet(this, _key), proxy(value, null, __privateGet(this, _key)));
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode2));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode2), proxy(value, null, __privateGet(this, _viewportNode2)));
  }
  get inputNode() {
    return get(__privateGet(this, _inputNode2));
  }
  set inputNode(value) {
    set(__privateGet(this, _inputNode2), proxy(value, null, __privateGet(this, _inputNode2)));
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode2));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode2), proxy(value, null, __privateGet(this, _labelNode2)));
  }
  get commandState() {
    return get(__privateGet(this, _commandState));
  }
  set commandState(value) {
    set(__privateGet(this, _commandState), value);
  }
  get _commandState() {
    return get(__privateGet(this, __commandState));
  }
  set _commandState(value) {
    set(__privateGet(this, __commandState), proxy(value, null, __privateGet(this, __commandState)));
  }
  get props() {
    return get(__privateGet(this, _props50));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _key)), owner, false);
    add_owner(get(__privateGet(this, _viewportNode2)), owner, false);
    add_owner(get(__privateGet(this, _inputNode2)), owner, false);
    add_owner(get(__privateGet(this, _labelNode2)), owner, false);
    add_owner(get(__privateGet(this, _commandState)), owner, false);
    add_owner(get(__privateGet(this, __commandState)), owner, false);
    add_owner(get(__privateGet(this, _props50)), owner, false);
  }
};
_key = new WeakMap();
_viewportNode2 = new WeakMap();
_inputNode2 = new WeakMap();
_labelNode2 = new WeakMap();
_vimBindings = new WeakMap();
_commandState = new WeakMap();
__commandState = new WeakMap();
_score = new WeakMap();
_sort = new WeakMap();
_selectFirstItem = new WeakMap();
_filterItems = new WeakMap();
_getValidItems = new WeakMap();
_getSelectedItem = new WeakMap();
_scrollSelectedIntoView = new WeakMap();
_updateSelectedToIndex = new WeakMap();
_updateSelectedByItem = new WeakMap();
_updateSelectedByGroup = new WeakMap();
_last = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_onkeydown12 = new WeakMap();
_props50 = new WeakMap();
var _ref32, _id32, _root11, _forceMount3, _isInitialRender, _shouldRender3, _props51;
var CommandEmptyState = class {
  constructor(props, root17) {
    __privateAdd(this, _ref32);
    __privateAdd(this, _id32);
    __privateAdd(this, _root11);
    __privateAdd(this, _forceMount3);
    __privateAdd(this, _isInitialRender, true);
    __privateAdd(this, _shouldRender3, derived(() => strict_equals(__privateGet(this, _root11)._commandState.filtered.count, 0) && strict_equals(__privateGet(this, _isInitialRender), false) || __privateGet(this, _forceMount3).current));
    __privateAdd(this, _props51, derived(() => ({
      id: __privateGet(this, _id32).current,
      role: "presentation",
      [EMPTY_ATTR]: ""
    })));
    __privateSet(this, _ref32, props.ref);
    __privateSet(this, _id32, props.id);
    __privateSet(this, _root11, root17);
    __privateSet(this, _forceMount3, props.forceMount);
    user_effect(() => {
      __privateSet(this, _isInitialRender, false);
    });
    useRefById({
      id: __privateGet(this, _id32),
      ref: __privateGet(this, _ref32),
      deps: () => this.shouldRender
    });
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender3));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get props() {
    return get(__privateGet(this, _props51));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _shouldRender3)), owner, false);
    add_owner(get(__privateGet(this, _props51)), owner, false);
  }
};
_ref32 = new WeakMap();
_id32 = new WeakMap();
_root11 = new WeakMap();
_forceMount3 = new WeakMap();
_isInitialRender = new WeakMap();
_shouldRender3 = new WeakMap();
_props51 = new WeakMap();
var _ref33, _value4, _root12, _headingNode, _shouldRender4, _trueValue, _props52;
var CommandGroupContainerState = class {
  constructor(props, root17) {
    __privateAdd(this, _ref33);
    __publicField(this, "id");
    __publicField(this, "forceMount");
    __privateAdd(this, _value4);
    __privateAdd(this, _root12);
    __privateAdd(this, _headingNode, state(null));
    __privateAdd(this, _shouldRender4, derived(() => {
      if (this.forceMount.current) return true;
      if (strict_equals(__privateGet(this, _root12).shouldFilter.current, false)) return true;
      if (!__privateGet(this, _root12).commandState.search) return true;
      return __privateGet(this, _root12).commandState.filtered.groups.has(this.id.current);
    }));
    __privateAdd(this, _trueValue, state(""));
    __privateAdd(this, _props52, derived(() => ({
      id: this.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : true,
      "data-value": this.trueValue,
      [GROUP_ATTR]: ""
    })));
    __privateSet(this, _ref33, props.ref);
    this.id = props.id;
    __privateSet(this, _root12, root17);
    this.forceMount = props.forceMount;
    __privateSet(this, _value4, props.value);
    this.trueValue = props.value.current;
    useRefById({
      id: this.id,
      ref: __privateGet(this, _ref33),
      deps: () => this.shouldRender
    });
    user_effect(() => {
      return __privateGet(this, _root12).registerGroup(this.id.current);
    });
    user_effect(() => {
      var _a;
      if (__privateGet(this, _value4).current) {
        this.trueValue = __privateGet(this, _value4).current;
        return __privateGet(this, _root12).registerValue(this.id.current, __privateGet(this, _value4).current);
      } else if (this.headingNode && this.headingNode.textContent) {
        this.trueValue = this.headingNode.textContent.trim().toLowerCase();
        return __privateGet(this, _root12).registerValue(this.id.current, this.trueValue);
      } else if ((_a = __privateGet(this, _ref33).current) == null ? void 0 : _a.textContent) {
        this.trueValue = __privateGet(this, _ref33).current.textContent.trim().toLowerCase();
        return __privateGet(this, _root12).registerValue(this.id.current, this.trueValue);
      }
    });
  }
  get headingNode() {
    return get(__privateGet(this, _headingNode));
  }
  set headingNode(value) {
    set(__privateGet(this, _headingNode), proxy(value, null, __privateGet(this, _headingNode)));
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender4));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get trueValue() {
    return get(__privateGet(this, _trueValue));
  }
  set trueValue(value) {
    set(__privateGet(this, _trueValue), proxy(value, null, __privateGet(this, _trueValue)));
  }
  get props() {
    return get(__privateGet(this, _props52));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  createGroupHeading(props) {
    return new CommandGroupHeadingState(props, this);
  }
  createGroupItems(props) {
    return new CommandGroupItemsState(props, this);
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _headingNode)), owner, false);
    add_owner(get(__privateGet(this, _shouldRender4)), owner, false);
    add_owner(get(__privateGet(this, _trueValue)), owner, false);
    add_owner(get(__privateGet(this, _props52)), owner, false);
  }
};
_ref33 = new WeakMap();
_value4 = new WeakMap();
_root12 = new WeakMap();
_headingNode = new WeakMap();
_shouldRender4 = new WeakMap();
_trueValue = new WeakMap();
_props52 = new WeakMap();
var _ref34, _id33, _group, _props53;
var CommandGroupHeadingState = class {
  constructor(props, group) {
    __privateAdd(this, _ref34);
    __privateAdd(this, _id33);
    __privateAdd(this, _group);
    __privateAdd(this, _props53, derived(() => ({
      id: __privateGet(this, _id33).current,
      [GROUP_HEADING_ATTR]: ""
    })));
    __privateSet(this, _ref34, props.ref);
    __privateSet(this, _id33, props.id);
    __privateSet(this, _group, group);
    useRefById({
      id: __privateGet(this, _id33),
      ref: __privateGet(this, _ref34),
      onRefChange: (node) => {
        __privateGet(this, _group).headingNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props53));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props53)), owner, false);
  }
};
_ref34 = new WeakMap();
_id33 = new WeakMap();
_group = new WeakMap();
_props53 = new WeakMap();
var _ref35, _id34, _group2, _props54;
var CommandGroupItemsState = class {
  constructor(props, group) {
    __privateAdd(this, _ref35);
    __privateAdd(this, _id34);
    __privateAdd(this, _group2);
    __privateAdd(this, _props54, derived(() => {
      var _a;
      return {
        id: __privateGet(this, _id34).current,
        role: "group",
        [GROUP_ITEMS_ATTR]: "",
        "aria-labelledby": ((_a = __privateGet(this, _group2).headingNode) == null ? void 0 : _a.id) ?? void 0
      };
    }));
    __privateSet(this, _ref35, props.ref);
    __privateSet(this, _id34, props.id);
    __privateSet(this, _group2, group);
    useRefById({ id: __privateGet(this, _id34), ref: __privateGet(this, _ref35) });
  }
  get props() {
    return get(__privateGet(this, _props54));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props54)), owner, false);
  }
};
_ref35 = new WeakMap();
_id34 = new WeakMap();
_group2 = new WeakMap();
_props54 = new WeakMap();
var _ref36, _id35, _root13, _value5, _autofocus, _selectedItemId, _props55;
var CommandInputState = class {
  constructor(props, root17) {
    __privateAdd(this, _ref36);
    __privateAdd(this, _id35);
    __privateAdd(this, _root13);
    __privateAdd(this, _value5);
    __privateAdd(this, _autofocus);
    __privateAdd(this, _selectedItemId, derived(() => {
      var _a;
      const item = (_a = __privateGet(this, _root13).viewportNode) == null ? void 0 : _a.querySelector(`${ITEM_SELECTOR}[${VALUE_ATTR}="${encodeURIComponent(__privateGet(this, _value5).current)}"]`);
      if (!item) return;
      return (item == null ? void 0 : item.getAttribute("id")) ?? void 0;
    }));
    __privateAdd(this, _props55, derived(() => {
      var _a, _b;
      return {
        id: __privateGet(this, _id35).current,
        type: "text",
        [INPUT_ATTR]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": getAriaExpanded(true),
        "aria-controls": ((_a = __privateGet(this, _root13).viewportNode) == null ? void 0 : _a.id) ?? void 0,
        "aria-labelledby": ((_b = __privateGet(this, _root13).labelNode) == null ? void 0 : _b.id) ?? void 0,
        "aria-activedescendant": get(__privateGet(this, _selectedItemId))
      };
    }));
    __privateSet(this, _ref36, props.ref);
    __privateSet(this, _id35, props.id);
    __privateSet(this, _root13, root17);
    __privateSet(this, _value5, props.value);
    __privateSet(this, _autofocus, props.autofocus);
    useRefById({
      id: __privateGet(this, _id35),
      ref: __privateGet(this, _ref36),
      onRefChange: (node) => {
        __privateGet(this, _root13).inputNode = node;
      }
    });
    user_effect(() => {
      const node = __privateGet(this, _ref36).current;
      untrack(() => {
        if (node && __privateGet(this, _autofocus).current) {
          afterSleep(10, () => node.focus());
        }
      });
    });
    user_effect(() => {
      __privateGet(this, _value5).current;
      untrack(() => {
        if (strict_equals(__privateGet(this, _root13).commandState.search, __privateGet(this, _value5).current, false)) {
          __privateGet(this, _root13).setState("search", __privateGet(this, _value5).current);
        }
      });
    });
  }
  get props() {
    return get(__privateGet(this, _props55));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props55)), owner, false);
  }
};
_ref36 = new WeakMap();
_id35 = new WeakMap();
_root13 = new WeakMap();
_value5 = new WeakMap();
_autofocus = new WeakMap();
_selectedItemId = new WeakMap();
_props55 = new WeakMap();
var _ref37, _value6, _disabled6, _onSelectProp, _forceMount4, _group3, _trueForceMount, _trueValue2, _shouldRender5, _isSelected2, _onSelect, _select, _onpointermove4, _onclick9, _props56;
var CommandItemState = class {
  constructor(props, root17) {
    __privateAdd(this, _ref37);
    __publicField(this, "id");
    __publicField(this, "root");
    __privateAdd(this, _value6);
    __privateAdd(this, _disabled6);
    __privateAdd(this, _onSelectProp);
    __privateAdd(this, _forceMount4);
    __privateAdd(this, _group3, null);
    __privateAdd(this, _trueForceMount, derived(() => {
      var _a;
      return __privateGet(this, _forceMount4).current || strict_equals((_a = __privateGet(this, _group3)) == null ? void 0 : _a.forceMount.current, true);
    }));
    __privateAdd(this, _trueValue2, state(""));
    __privateAdd(this, _shouldRender5, derived(() => {
      if (get(__privateGet(this, _trueForceMount)) || strict_equals(this.root.shouldFilter.current, false) || !this.root.commandState.search) {
        return true;
      }
      const currentScore = this.root.commandState.filtered.items.get(this.id.current);
      if (strict_equals(currentScore, void 0)) return false;
      return currentScore > 0;
    }));
    __privateAdd(this, _isSelected2, derived(() => strict_equals(this.root.valueProp.current, this.trueValue) && strict_equals(this.trueValue, "", false)));
    __privateAdd(this, _onSelect, () => {
      var _a;
      if (__privateGet(this, _disabled6).current) return;
      __privateGet(this, _select).call(this);
      (_a = __privateGet(this, _onSelectProp)) == null ? void 0 : _a.current();
    });
    __privateAdd(this, _select, () => {
      if (__privateGet(this, _disabled6).current) return;
      this.root.setValue(this.trueValue, true);
    });
    __privateAdd(this, _onpointermove4, () => {
      if (__privateGet(this, _disabled6).current || this.root.disablePointerSelection.current) return;
      __privateGet(this, _select).call(this);
    });
    __privateAdd(this, _onclick9, () => {
      if (__privateGet(this, _disabled6).current) return;
      __privateGet(this, _onSelect).call(this);
    });
    __privateAdd(this, _props56, derived(() => ({
      id: this.id.current,
      "aria-disabled": getAriaDisabled(__privateGet(this, _disabled6).current),
      "aria-selected": getAriaSelected(this.isSelected),
      "data-disabled": getDataDisabled(__privateGet(this, _disabled6).current),
      "data-selected": getDataSelected(this.isSelected),
      [ITEM_ATTR]: "",
      role: "option",
      onpointermove: __privateGet(this, _onpointermove4),
      onclick: __privateGet(this, _onclick9)
    })));
    __privateSet(this, _ref37, props.ref);
    this.id = props.id;
    this.root = root17;
    __privateSet(this, _value6, props.value);
    __privateSet(this, _disabled6, props.disabled);
    __privateSet(this, _onSelectProp, props.onSelect);
    __privateSet(this, _forceMount4, props.forceMount);
    __privateSet(this, _group3, getCommandGroupContainerContext(null));
    this.trueValue = props.value.current;
    useRefById({
      id: this.id,
      ref: __privateGet(this, _ref37),
      deps: () => Boolean(this.root.commandState.search)
    });
    user_effect(() => {
      var _a;
      this.id.current;
      (_a = __privateGet(this, _group3)) == null ? void 0 : _a.id.current;
      if (!__privateGet(this, _forceMount4).current) {
        return untrack(() => {
          var _a2;
          return this.root.registerItem(this.id.current, (_a2 = __privateGet(this, _group3)) == null ? void 0 : _a2.id.current);
        });
      }
    });
    user_effect(() => {
      const value = __privateGet(this, _value6).current;
      const node = __privateGet(this, _ref37).current;
      if (!node) return;
      if (!value && node.textContent) {
        this.trueValue = node.textContent.trim();
      }
      untrack(() => {
        this.root.registerValue(this.id.current, this.trueValue, props.keywords.current.map((keyword) => keyword.trim()));
        node.setAttribute(VALUE_ATTR, this.trueValue);
      });
    });
  }
  get trueValue() {
    return get(__privateGet(this, _trueValue2));
  }
  set trueValue(value) {
    set(__privateGet(this, _trueValue2), proxy(value, null, __privateGet(this, _trueValue2)));
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender5));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get isSelected() {
    return get(__privateGet(this, _isSelected2));
  }
  set isSelected(_) {
    throw new Error("Cannot update a derived property ('isSelected')");
  }
  get props() {
    return get(__privateGet(this, _props56));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _trueValue2)), owner, false);
    add_owner(get(__privateGet(this, _shouldRender5)), owner, false);
    add_owner(get(__privateGet(this, _isSelected2)), owner, false);
    add_owner(get(__privateGet(this, _props56)), owner, false);
  }
};
_ref37 = new WeakMap();
_value6 = new WeakMap();
_disabled6 = new WeakMap();
_onSelectProp = new WeakMap();
_forceMount4 = new WeakMap();
_group3 = new WeakMap();
_trueForceMount = new WeakMap();
_trueValue2 = new WeakMap();
_shouldRender5 = new WeakMap();
_isSelected2 = new WeakMap();
_onSelect = new WeakMap();
_select = new WeakMap();
_onpointermove4 = new WeakMap();
_onclick9 = new WeakMap();
_props56 = new WeakMap();
var _ref38, _id36, _progress, _props57;
var CommandLoadingState = class {
  constructor(props) {
    __privateAdd(this, _ref38);
    __privateAdd(this, _id36);
    __privateAdd(this, _progress);
    __privateAdd(this, _props57, derived(() => ({
      id: __privateGet(this, _id36).current,
      role: "progressbar",
      "aria-valuenow": __privateGet(this, _progress).current,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-label": "Loading...",
      [LOADING_ATTR]: ""
    })));
    __privateSet(this, _ref38, props.ref);
    __privateSet(this, _id36, props.id);
    __privateSet(this, _progress, props.progress);
    useRefById({ id: __privateGet(this, _id36), ref: __privateGet(this, _ref38) });
  }
  get props() {
    return get(__privateGet(this, _props57));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props57)), owner, false);
  }
};
_ref38 = new WeakMap();
_id36 = new WeakMap();
_progress = new WeakMap();
_props57 = new WeakMap();
var _ref39, _id37, _root14, _forceMount5, _shouldRender6, _props58;
var CommandSeparatorState = class {
  constructor(props, root17) {
    __privateAdd(this, _ref39);
    __privateAdd(this, _id37);
    __privateAdd(this, _root14);
    __privateAdd(this, _forceMount5);
    __privateAdd(this, _shouldRender6, derived(() => !__privateGet(this, _root14).commandState.search || __privateGet(this, _forceMount5).current));
    __privateAdd(this, _props58, derived(() => ({
      id: __privateGet(this, _id37).current,
      role: "separator",
      [SEPARATOR_ATTR]: ""
    })));
    __privateSet(this, _ref39, props.ref);
    __privateSet(this, _id37, props.id);
    __privateSet(this, _root14, root17);
    __privateSet(this, _forceMount5, props.forceMount);
    useRefById({
      id: __privateGet(this, _id37),
      ref: __privateGet(this, _ref39),
      deps: () => this.shouldRender
    });
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender6));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get props() {
    return get(__privateGet(this, _props58));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _shouldRender6)), owner, false);
    add_owner(get(__privateGet(this, _props58)), owner, false);
  }
};
_ref39 = new WeakMap();
_id37 = new WeakMap();
_root14 = new WeakMap();
_forceMount5 = new WeakMap();
_shouldRender6 = new WeakMap();
_props58 = new WeakMap();
var _id38, _ariaLabel, _props59;
var CommandListState = class {
  constructor(props, root17) {
    __publicField(this, "ref");
    __privateAdd(this, _id38);
    __privateAdd(this, _ariaLabel);
    __publicField(this, "root");
    __privateAdd(this, _props59, derived(() => ({
      id: __privateGet(this, _id38).current,
      role: "listbox",
      "aria-label": __privateGet(this, _ariaLabel).current,
      [LIST_ATTR]: ""
    })));
    this.ref = props.ref;
    __privateSet(this, _id38, props.id);
    this.root = root17;
    __privateSet(this, _ariaLabel, props.ariaLabel);
    useRefById({ id: __privateGet(this, _id38), ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props59));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props59)), owner, false);
  }
};
_id38 = new WeakMap();
_ariaLabel = new WeakMap();
_props59 = new WeakMap();
var _ref40, _id39, _root15, _for, _props60;
var CommandLabelState = class {
  constructor(props, root17) {
    __privateAdd(this, _ref40);
    __privateAdd(this, _id39);
    __privateAdd(this, _root15);
    __privateAdd(this, _for);
    __privateAdd(this, _props60, derived(() => {
      var _a;
      return {
        id: __privateGet(this, _id39).current,
        [INPUT_LABEL_ATTR]: "",
        for: (_a = __privateGet(this, _for)) == null ? void 0 : _a.current,
        style: srOnlyStyles
      };
    }));
    __privateSet(this, _ref40, props.ref);
    __privateSet(this, _id39, props.id);
    __privateSet(this, _root15, root17);
    __privateSet(this, _for, props.for);
    useRefById({
      id: __privateGet(this, _id39),
      ref: __privateGet(this, _ref40),
      onRefChange: (node) => {
        __privateGet(this, _root15).labelNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props60));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props60)), owner, false);
  }
};
_ref40 = new WeakMap();
_id39 = new WeakMap();
_root15 = new WeakMap();
_for = new WeakMap();
_props60 = new WeakMap();
var _ref41, _id40, _list, _props61;
var CommandViewportState = class {
  constructor(props, list) {
    __privateAdd(this, _ref41);
    __privateAdd(this, _id40);
    __privateAdd(this, _list);
    __privateAdd(this, _props61, derived(() => ({ id: __privateGet(this, _id40).current, [VIEWPORT_ATTR]: "" })));
    __privateSet(this, _ref41, props.ref);
    __privateSet(this, _id40, props.id);
    __privateSet(this, _list, list);
    useRefById({
      id: __privateGet(this, _id40),
      ref: __privateGet(this, _ref41),
      onRefChange: (node) => {
        __privateGet(this, _list).root.viewportNode = node;
      }
    });
    user_effect(() => {
      const node = __privateGet(this, _ref41).current;
      const listNode = __privateGet(this, _list).ref.current;
      if (!node || !listNode) return;
      let aF;
      const observer = new ResizeObserver(() => {
        aF = requestAnimationFrame(() => {
          const height = node.offsetHeight;
          listNode.style.setProperty("--bits-command-list-height", `${height.toFixed(1)}px`);
        });
      });
      observer.observe(node);
      return () => {
        cancelAnimationFrame(aF);
        observer.unobserve(node);
      };
    });
  }
  get props() {
    return get(__privateGet(this, _props61));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props61)), owner, false);
  }
};
_ref41 = new WeakMap();
_id40 = new WeakMap();
_list = new WeakMap();
_props61 = new WeakMap();
function useCommandRoot(props) {
  return setCommandRootContext(new CommandRootState(props));
}
function useCommandEmpty(props) {
  const root17 = getCommandRootContext();
  return new CommandEmptyState(props, root17);
}
function useCommandItem(props) {
  const root17 = getCommandRootContext();
  return new CommandItemState(props, root17);
}
function useCommandGroupContainer(props) {
  const root17 = getCommandRootContext();
  return setCommandGroupContainerContext(new CommandGroupContainerState(props, root17));
}
function useCommandGroupHeading(props) {
  const groupContainer = getCommandGroupContainerContext();
  return new CommandGroupHeadingState(props, groupContainer);
}
function useCommandGroupItems(props) {
  const groupContainer = getCommandGroupContainerContext();
  return new CommandGroupItemsState(props, groupContainer);
}
function useCommandInput(props) {
  const root17 = getCommandRootContext();
  return new CommandInputState(props, root17);
}
function useCommandLoading(props) {
  return new CommandLoadingState(props);
}
function useCommandSeparator(props) {
  const root17 = getCommandRootContext();
  return new CommandSeparatorState(props, root17);
}
function useCommandList(props) {
  const root17 = getCommandRootContext();
  return setCommandListContext(new CommandListState(props, root17));
}
function useCommandViewport(props) {
  const list = getCommandListContext();
  return new CommandViewportState(props, list);
}
function useCommandLabel(props) {
  const root17 = getCommandRootContext();
  return new CommandLabelState(props, root17);
}

// node_modules/bits-ui/dist/bits/pin-input/usePasswordManager.svelte.js
var PWM_BADGE_MARGIN_RIGHT = 18;
var PWM_BADGE_SPACE_WIDTH_PX = 40;
var PWM_BADGE_SPACE_WIDTH = `${PWM_BADGE_SPACE_WIDTH_PX}px`;
var PASSWORD_MANAGER_SELECTORS = [
  "[data-lastpass-icon-root]",
  // LastPass,
  "com-1password-button",
  // 1Password,
  "[data-dashlanecreated]",
  // Dashlane,
  '[style$="2147483647 !important;"]'
  // Bitwarden
].join(",");
function usePasswordManagerBadge({
  containerRef,
  inputRef,
  pushPasswordManagerStrategy,
  isFocused
}) {
  let pwmMetadata = proxy({ done: false, refocused: false });
  let hasPwmBadge = state(false);
  let hasPwmBadgeSpace = state(false);
  let done = state(false);
  function willPushPwmBadge() {
    const strategy = pushPasswordManagerStrategy.current;
    if (strict_equals(strategy, "none")) return false;
    const increaseWidthCase = strict_equals(strategy, "increase-width") && get(hasPwmBadge) && get(hasPwmBadgeSpace);
    return increaseWidthCase;
  }
  function trackPwmBadge() {
    const container = containerRef.current;
    const input = inputRef.current;
    if (!container || !input || get(done) || strict_equals(pushPasswordManagerStrategy.current, "none")) return;
    const elementToCompare = container;
    const rightCornerX = elementToCompare.getBoundingClientRect().left + elementToCompare.offsetWidth;
    const centeredY = elementToCompare.getBoundingClientRect().top + elementToCompare.offsetHeight / 2;
    const x = rightCornerX - PWM_BADGE_MARGIN_RIGHT;
    const y = centeredY;
    const passwordManagerStrategy = document.querySelectorAll(PASSWORD_MANAGER_SELECTORS);
    if (strict_equals(passwordManagerStrategy.length, 0)) {
      const maybeBadgeEl = document.elementFromPoint(x, y);
      if (strict_equals(maybeBadgeEl, container)) return;
    }
    set(hasPwmBadge, true);
    set(done, true);
    if (!pwmMetadata.refocused && strict_equals(document.activeElement, input)) {
      const selections = [
        input.selectionStart ?? 0,
        input.selectionEnd ?? 0
      ];
      input.blur();
      input.focus();
      input.focus();
      input.setSelectionRange(selections[0], selections[1]);
      pwmMetadata.refocused = true;
    }
  }
  user_effect(() => {
    const container = containerRef.current;
    if (!container || strict_equals(pushPasswordManagerStrategy.current, "none")) return;
    function checkHasSpace() {
      const viewportWidth = window.innerWidth;
      const distanceToRightEdge = viewportWidth - container.getBoundingClientRect().right;
      set(hasPwmBadgeSpace, distanceToRightEdge >= PWM_BADGE_SPACE_WIDTH_PX);
    }
    checkHasSpace();
    const interval = setInterval(checkHasSpace, 1e3);
    return () => {
      clearInterval(interval);
    };
  });
  user_effect(() => {
    const focused = isFocused.current || strict_equals(document.activeElement, inputRef.current);
    if (strict_equals(pushPasswordManagerStrategy.current, "none") || !focused) return;
    const t1 = setTimeout(trackPwmBadge, 0);
    const t2 = setTimeout(trackPwmBadge, 2e3);
    const t3 = setTimeout(trackPwmBadge, 5e3);
    const t4 = setTimeout(
      () => {
        set(done, true);
      },
      6e3
    );
    return () => {
      clearTimeout(t1);
      clearTimeout(t2);
      clearTimeout(t3);
      clearTimeout(t4);
    };
  });
  return {
    get hasPwmBadge() {
      return get(hasPwmBadge);
    },
    get willPushPwmBadge() {
      return willPushPwmBadge();
    },
    PWM_BADGE_SPACE_WIDTH
  };
}

// node_modules/bits-ui/dist/bits/pin-input/pin-input.svelte.js
var REGEXP_ONLY_DIGITS = "^\\d+$";
var REGEXP_ONLY_CHARS = "^[a-zA-Z]+$";
var REGEXP_ONLY_DIGITS_AND_CHARS = "^[a-zA-Z0-9]+$";
var ROOT_ATTR3 = "data-pin-input-root";
var CELL_ATTR = "data-pin-input-cell";
var _id41, _ref42, _inputId, _inputRef, _isHoveringInput, _isFocused, _mirrorSelectionStart, _mirrorSelectionEnd, _onComplete, _onPaste, _previousValue, _maxLength, _disabled7, _pattern, _textAlign, _autocomplete, _inputmode, _regexPattern, _prevInputMetadata, _pushPasswordManagerStrategy, _pwmb, _initialLoad, _onkeydown13, _rootStyles, _rootProps, _inputWrapperProps, _inputStyle, _onDocumentSelectionChange, _oninput2, _onfocus2, _onpaste, _onmouseover, _onmouseleave, _onblur, _inputProps, _cells, _snippetProps10;
var PinInputRootState = class {
  constructor(props) {
    __privateAdd(this, _id41);
    __privateAdd(this, _ref42);
    __privateAdd(this, _inputId);
    __privateAdd(this, _inputRef, box(null));
    __privateAdd(this, _isHoveringInput, state(false));
    __privateAdd(this, _isFocused, box(false));
    __privateAdd(this, _mirrorSelectionStart, state(null));
    __privateAdd(this, _mirrorSelectionEnd, state(null));
    __privateAdd(this, _onComplete);
    __privateAdd(this, _onPaste);
    __publicField(this, "value");
    __privateAdd(this, _previousValue, new Previous(() => this.value.current ?? ""));
    __privateAdd(this, _maxLength);
    __privateAdd(this, _disabled7);
    __privateAdd(this, _pattern);
    __privateAdd(this, _textAlign);
    __privateAdd(this, _autocomplete);
    __privateAdd(this, _inputmode);
    __privateAdd(this, _regexPattern, derived(() => {
      if (strict_equals(typeof __privateGet(this, _pattern).current, "string")) {
        return new RegExp(__privateGet(this, _pattern).current);
      } else {
        return __privateGet(this, _pattern).current;
      }
    }));
    __privateAdd(this, _prevInputMetadata, state(proxy({
      prev: [null, null, "none"],
      willSyntheticBlur: false
    })));
    __privateAdd(this, _pushPasswordManagerStrategy);
    __privateAdd(this, _pwmb);
    __privateAdd(this, _initialLoad);
    __publicField(this, "keysToIgnore", [
      "Backspace",
      "Delete",
      "ArrowLeft",
      "ArrowRight",
      "ArrowUp",
      "ArrowDown",
      "Home",
      "End",
      "Escape",
      "Enter",
      "Tab",
      "Shift",
      "Control",
      "Meta"
    ]);
    __privateAdd(this, _onkeydown13, (e) => {
      const key = e.key;
      if (this.keysToIgnore.includes(key)) return;
      if (key && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(key)) {
        e.preventDefault();
      }
    });
    __privateAdd(this, _rootStyles, derived(() => ({
      position: "relative",
      cursor: __privateGet(this, _disabled7).current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    __privateAdd(this, _rootProps, derived(() => ({
      id: __privateGet(this, _id41).current,
      [ROOT_ATTR3]: "",
      style: get(__privateGet(this, _rootStyles))
    })));
    __privateAdd(this, _inputWrapperProps, derived(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    __privateAdd(this, _inputStyle, derived(() => ({
      position: "absolute",
      inset: 0,
      width: __privateGet(this, _pwmb).willPushPwmBadge ? `calc(100% + ${__privateGet(this, _pwmb).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: __privateGet(this, _pwmb).willPushPwmBadge ? `inset(0 ${__privateGet(this, _pwmb).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: __privateGet(this, _textAlign).current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    __publicField(this, "applyStyles", () => {
      const styleEl = document.createElement("style");
      styleEl.id = "pin-input-style";
      document.head.appendChild(styleEl);
      if (styleEl.sheet) {
        const autoFillStyles = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        safeInsertRule(styleEl.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }");
        safeInsertRule(styleEl.sheet, `[data-pin-input-input]:autofill { ${autoFillStyles} }`);
        safeInsertRule(styleEl.sheet, `[data-pin-input-input]:-webkit-autofill { ${autoFillStyles} }`);
        safeInsertRule(styleEl.sheet, `@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }`);
        safeInsertRule(styleEl.sheet, `[data-pin-input-input] + * { pointer-events: all !important; }`);
      }
    });
    __privateAdd(this, _onDocumentSelectionChange, () => {
      var _a;
      const input = __privateGet(this, _inputRef).current;
      const container = __privateGet(this, _ref42).current;
      if (!input || !container) return;
      if (strict_equals(document.activeElement, input, false)) {
        set(__privateGet(this, _mirrorSelectionStart), null);
        set(__privateGet(this, _mirrorSelectionEnd), null);
        return;
      }
      const selStart = input.selectionStart;
      const selEnd = input.selectionEnd;
      const selDir = input.selectionDirection ?? "none";
      const maxLength = input.maxLength;
      const val = input.value;
      const prev2 = get(__privateGet(this, _prevInputMetadata)).prev;
      let start = -1;
      let end = -1;
      let direction;
      if (strict_equals(val.length, 0, false) && strict_equals(selStart, null, false) && strict_equals(selEnd, null, false)) {
        const isSingleCaret = strict_equals(selStart, selEnd);
        const isInsertMode = strict_equals(selStart, val.length) && val.length < maxLength;
        if (isSingleCaret && !isInsertMode) {
          const c = selStart;
          if (strict_equals(c, 0)) {
            start = 0;
            end = 1;
            direction = "forward";
          } else if (strict_equals(c, maxLength)) {
            start = c - 1;
            end = c;
            direction = "backward";
          } else if (maxLength > 1 && val.length > 1) {
            let offset2 = 0;
            if (strict_equals(prev2[0], null, false) && strict_equals(prev2[1], null, false)) {
              direction = c < prev2[0] ? "backward" : "forward";
              const wasPreviouslyInserting = strict_equals(prev2[0], prev2[1]) && prev2[0] < maxLength;
              if (strict_equals(direction, "backward") && !wasPreviouslyInserting) {
                offset2 = -1;
              }
            }
            start = offset2 - c;
            end = offset2 + c + 1;
          }
        }
        if (strict_equals(start, -1, false) && strict_equals(end, -1, false) && strict_equals(start, end, false)) {
          (_a = __privateGet(this, _inputRef).current) == null ? void 0 : _a.setSelectionRange(start, end, direction);
        }
      }
      const s = strict_equals(start, -1, false) ? start : selStart;
      const e = strict_equals(end, -1, false) ? end : selEnd;
      const dir = direction ?? selDir;
      set(__privateGet(this, _mirrorSelectionStart), proxy(s, null, __privateGet(this, _mirrorSelectionStart)));
      set(__privateGet(this, _mirrorSelectionEnd), proxy(e, null, __privateGet(this, _mirrorSelectionEnd)));
      get(__privateGet(this, _prevInputMetadata)).prev = [s, e, dir];
    });
    __privateAdd(this, _oninput2, (e) => {
      const newValue = e.currentTarget.value.slice(0, __privateGet(this, _maxLength).current);
      if (newValue.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(newValue)) {
        e.preventDefault();
        return;
      }
      const maybeHasDeleted = strict_equals(typeof __privateGet(this, _previousValue).current, "string") && newValue.length < __privateGet(this, _previousValue).current.length;
      if (maybeHasDeleted) {
        document.dispatchEvent(new Event("selectionchange"));
      }
      this.value.current = newValue;
    });
    __privateAdd(this, _onfocus2, (_) => {
      const input = __privateGet(this, _inputRef).current;
      if (input) {
        const start = Math.min(input.value.length, __privateGet(this, _maxLength).current - 1);
        const end = input.value.length;
        input.setSelectionRange(start, end);
        set(__privateGet(this, _mirrorSelectionStart), proxy(start, null, __privateGet(this, _mirrorSelectionStart)));
        set(__privateGet(this, _mirrorSelectionEnd), proxy(end, null, __privateGet(this, _mirrorSelectionEnd)));
      }
      __privateGet(this, _isFocused).current = true;
    });
    __privateAdd(this, _onpaste, (e) => {
      var _a, _b, _c, _d;
      const input = __privateGet(this, _inputRef).current;
      if (!__privateGet(this, _initialLoad).isIOS) {
        if (!e.clipboardData || !input) return;
        const content2 = e.clipboardData.getData("text/plain");
        const sanitizedContent2 = ((_b = (_a = __privateGet(this, _onPaste)) == null ? void 0 : _a.current) == null ? void 0 : _b.call(_a, content2)) ?? content2;
        if (sanitizedContent2.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(sanitizedContent2)) {
          e.preventDefault();
          return;
        }
      }
      if (!__privateGet(this, _initialLoad).isIOS || !e.clipboardData || !input) return;
      const content = e.clipboardData.getData("text/plain");
      e.preventDefault();
      const sanitizedContent = ((_d = (_c = __privateGet(this, _onPaste)) == null ? void 0 : _c.current) == null ? void 0 : _d.call(_c, content)) ?? content;
      if (sanitizedContent.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(sanitizedContent)) {
        return;
      }
      const start = strict_equals(input.selectionStart, null) ? void 0 : input.selectionStart;
      const end = strict_equals(input.selectionEnd, null) ? void 0 : input.selectionEnd;
      const isReplacing = strict_equals(start, end, false);
      const initNewVal = this.value.current;
      const newValueUncapped = isReplacing ? initNewVal.slice(0, start) + sanitizedContent + initNewVal.slice(end) : initNewVal.slice(0, start) + sanitizedContent + initNewVal.slice(start);
      const newValue = newValueUncapped.slice(0, __privateGet(this, _maxLength).current);
      if (newValue.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(newValue)) {
        return;
      }
      input.value = newValue;
      this.value.current = newValue;
      const selStart = Math.min(newValue.length, __privateGet(this, _maxLength).current - 1);
      const selEnd = newValue.length;
      input.setSelectionRange(selStart, selEnd);
      set(__privateGet(this, _mirrorSelectionStart), proxy(selStart, null, __privateGet(this, _mirrorSelectionStart)));
      set(__privateGet(this, _mirrorSelectionEnd), proxy(selEnd, null, __privateGet(this, _mirrorSelectionEnd)));
    });
    __privateAdd(this, _onmouseover, () => {
      set(__privateGet(this, _isHoveringInput), true);
    });
    __privateAdd(this, _onmouseleave, () => {
      set(__privateGet(this, _isHoveringInput), false);
    });
    __privateAdd(this, _onblur, () => {
      if (get(__privateGet(this, _prevInputMetadata)).willSyntheticBlur) {
        get(__privateGet(this, _prevInputMetadata)).willSyntheticBlur = false;
        return;
      }
      __privateGet(this, _isFocused).current = false;
    });
    __privateAdd(this, _inputProps, derived(() => {
      var _a;
      return {
        id: __privateGet(this, _inputId).current,
        style: get(__privateGet(this, _inputStyle)),
        autocomplete: __privateGet(this, _autocomplete).current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": get(__privateGet(this, _mirrorSelectionStart)),
        "data-pin-input-input-mse": get(__privateGet(this, _mirrorSelectionEnd)),
        inputmode: __privateGet(this, _inputmode).current,
        pattern: (_a = get(__privateGet(this, _regexPattern))) == null ? void 0 : _a.source,
        maxlength: __privateGet(this, _maxLength).current,
        value: this.value.current,
        disabled: getDisabled(__privateGet(this, _disabled7).current),
        //
        onpaste: __privateGet(this, _onpaste),
        oninput: __privateGet(this, _oninput2),
        onkeydown: __privateGet(this, _onkeydown13),
        onmouseover: __privateGet(this, _onmouseover),
        onmouseleave: __privateGet(this, _onmouseleave),
        onfocus: __privateGet(this, _onfocus2),
        onblur: __privateGet(this, _onblur)
      };
    }));
    __privateAdd(this, _cells, derived(() => Array.from({ length: __privateGet(this, _maxLength).current }).map((_, idx) => {
      const isActive = __privateGet(this, _isFocused).current && strict_equals(get(__privateGet(this, _mirrorSelectionStart)), null, false) && strict_equals(get(__privateGet(this, _mirrorSelectionEnd)), null, false) && (strict_equals(get(__privateGet(this, _mirrorSelectionStart)), get(__privateGet(this, _mirrorSelectionEnd))) && strict_equals(idx, get(__privateGet(this, _mirrorSelectionStart))) || idx >= get(__privateGet(this, _mirrorSelectionStart)) && idx < get(__privateGet(this, _mirrorSelectionEnd)));
      const char = strict_equals(this.value.current[idx], void 0, false) ? this.value.current[idx] : null;
      return {
        char,
        isActive,
        hasFakeCaret: isActive && strict_equals(char, null)
      };
    })));
    __privateAdd(this, _snippetProps10, derived(() => ({
      cells: get(__privateGet(this, _cells)),
      isFocused: __privateGet(this, _isFocused).current,
      isHovering: get(__privateGet(this, _isHoveringInput))
    })));
    var _a;
    __privateSet(this, _id41, props.id);
    __privateSet(this, _ref42, props.ref);
    __privateSet(this, _pushPasswordManagerStrategy, props.pushPasswordManagerStrategy);
    this.value = props.value;
    __privateSet(this, _pattern, props.pattern);
    __privateSet(this, _maxLength, props.maxLength);
    __privateSet(this, _onComplete, props.onComplete);
    __privateSet(this, _disabled7, props.disabled);
    __privateSet(this, _textAlign, props.textAlign);
    __privateSet(this, _autocomplete, props.autocomplete);
    __privateSet(this, _inputmode, props.inputmode);
    __privateSet(this, _inputId, props.inputId);
    __privateSet(this, _onPaste, props.onPaste);
    __privateSet(this, _initialLoad, {
      value: this.value,
      isIOS: strict_equals(typeof window, "undefined", false) && ((_a = window == null ? void 0 : window.CSS) == null ? void 0 : _a.supports("-webkit-touch-callout", "none"))
    });
    __privateSet(this, _pwmb, usePasswordManagerBadge({
      containerRef: __privateGet(this, _ref42),
      inputRef: __privateGet(this, _inputRef),
      isFocused: __privateGet(this, _isFocused),
      pushPasswordManagerStrategy: __privateGet(this, _pushPasswordManagerStrategy)
    }));
    useRefById({ id: __privateGet(this, _id41), ref: __privateGet(this, _ref42) });
    useRefById({ id: __privateGet(this, _inputId), ref: __privateGet(this, _inputRef) });
    user_effect(() => {
      let unsub = noop2;
      return untrack(() => {
        const input = __privateGet(this, _inputRef).current;
        const container = __privateGet(this, _ref42).current;
        if (!input || !container) return;
        if (strict_equals(__privateGet(this, _initialLoad).value.current, input.value, false)) {
          this.value.current = input.value;
        }
        get(__privateGet(this, _prevInputMetadata)).prev = [
          input.selectionStart,
          input.selectionEnd,
          input.selectionDirection ?? "none"
        ];
        unsub = addEventListener2(document, "selectionchange", __privateGet(this, _onDocumentSelectionChange), { capture: true });
        __privateGet(this, _onDocumentSelectionChange).call(this);
        if (strict_equals(document.activeElement, input)) {
          __privateGet(this, _isFocused).current = true;
        }
        if (!document.getElementById("pin-input-style")) {
          this.applyStyles();
        }
        const updateRootHeight = () => {
          if (container) {
            container.style.setProperty("--bits-pin-input-root-height", `${input.clientHeight}px`);
          }
        };
        updateRootHeight();
        const resizeObserver = new ResizeObserver(updateRootHeight);
        resizeObserver.observe(input);
        return () => {
          unsub();
          resizeObserver.disconnect();
        };
      });
    });
    user_effect(() => {
      this.value.current;
      __privateGet(this, _inputRef).current;
      syncTimeouts(() => {
        const input = __privateGet(this, _inputRef).current;
        if (!input) return;
        input.dispatchEvent(new Event("input"));
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const dir = input.selectionDirection ?? "none";
        if (strict_equals(start, null, false) && strict_equals(end, null, false)) {
          set(__privateGet(this, _mirrorSelectionStart), proxy(start, null, __privateGet(this, _mirrorSelectionStart)));
          set(__privateGet(this, _mirrorSelectionEnd), proxy(end, null, __privateGet(this, _mirrorSelectionEnd)));
          get(__privateGet(this, _prevInputMetadata)).prev = [start, end, dir];
        }
      });
    });
    user_effect(() => {
      const value = this.value.current;
      const prevValue = __privateGet(this, _previousValue).current;
      const maxLength = __privateGet(this, _maxLength).current;
      const onComplete = __privateGet(this, _onComplete).current;
      if (strict_equals(prevValue, void 0)) return;
      if (strict_equals(value, prevValue, false) && prevValue.length < maxLength && strict_equals(value.length, maxLength)) {
        onComplete(value);
      }
    });
  }
  get rootProps() {
    return get(__privateGet(this, _rootProps));
  }
  set rootProps(_) {
    throw new Error("Cannot update a derived property ('rootProps')");
  }
  get inputWrapperProps() {
    return get(__privateGet(this, _inputWrapperProps));
  }
  set inputWrapperProps(_) {
    throw new Error("Cannot update a derived property ('inputWrapperProps')");
  }
  get inputProps() {
    return get(__privateGet(this, _inputProps));
  }
  set inputProps(_) {
    throw new Error("Cannot update a derived property ('inputProps')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps10));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _rootProps)), owner, false);
    add_owner(get(__privateGet(this, _inputWrapperProps)), owner, false);
    add_owner(get(__privateGet(this, _inputProps)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps10)), owner, false);
  }
};
_id41 = new WeakMap();
_ref42 = new WeakMap();
_inputId = new WeakMap();
_inputRef = new WeakMap();
_isHoveringInput = new WeakMap();
_isFocused = new WeakMap();
_mirrorSelectionStart = new WeakMap();
_mirrorSelectionEnd = new WeakMap();
_onComplete = new WeakMap();
_onPaste = new WeakMap();
_previousValue = new WeakMap();
_maxLength = new WeakMap();
_disabled7 = new WeakMap();
_pattern = new WeakMap();
_textAlign = new WeakMap();
_autocomplete = new WeakMap();
_inputmode = new WeakMap();
_regexPattern = new WeakMap();
_prevInputMetadata = new WeakMap();
_pushPasswordManagerStrategy = new WeakMap();
_pwmb = new WeakMap();
_initialLoad = new WeakMap();
_onkeydown13 = new WeakMap();
_rootStyles = new WeakMap();
_rootProps = new WeakMap();
_inputWrapperProps = new WeakMap();
_inputStyle = new WeakMap();
_onDocumentSelectionChange = new WeakMap();
_oninput2 = new WeakMap();
_onfocus2 = new WeakMap();
_onpaste = new WeakMap();
_onmouseover = new WeakMap();
_onmouseleave = new WeakMap();
_onblur = new WeakMap();
_inputProps = new WeakMap();
_cells = new WeakMap();
_snippetProps10 = new WeakMap();
var _id42, _ref43, _cell, _props62;
var PinInputCellState = class {
  constructor(props) {
    __privateAdd(this, _id42);
    __privateAdd(this, _ref43);
    __privateAdd(this, _cell);
    __privateAdd(this, _props62, derived(() => ({
      id: __privateGet(this, _id42).current,
      [CELL_ATTR]: "",
      "data-active": __privateGet(this, _cell).current.isActive ? "" : void 0,
      "data-inactive": !__privateGet(this, _cell).current.isActive ? "" : void 0
    })));
    __privateSet(this, _id42, props.id);
    __privateSet(this, _ref43, props.ref);
    __privateSet(this, _cell, props.cell);
    useRefById({ id: __privateGet(this, _id42), ref: __privateGet(this, _ref43) });
  }
  get props() {
    return get(__privateGet(this, _props62));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props62)), owner, false);
  }
};
_id42 = new WeakMap();
_ref43 = new WeakMap();
_cell = new WeakMap();
_props62 = new WeakMap();
function syncTimeouts(cb) {
  const t1 = setTimeout(cb, 0);
  const t2 = setTimeout(cb, 10);
  const t3 = setTimeout(cb, 50);
  return [t1, t2, t3];
}
function safeInsertRule(sheet, rule) {
  try {
    sheet.insertRule(rule);
  } catch {
    console.error(...log_if_contains_state("error", "pin input could not insert CSS rule:", rule));
  }
}
function usePinInput(props) {
  return new PinInputRootState(props);
}
function usePinInputCell(props) {
  return new PinInputCellState(props);
}

// node_modules/bits-ui/dist/bits/command/components/_command-label.svelte
mark_module_start();
_command_label[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/_command-label.svelte";
var root6 = add_locations(template(`<label><!></label>`), _command_label[FILENAME], [[30, 0]]);
function _command_label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, _command_label);
  validate_prop_bindings($$props, ["ref"], [], _command_label);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children"
    ],
    "restProps"
  );
  const labelState = useCommandLabel({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, labelState.props));
  var label = root6();
  let attributes;
  var node = child(label);
  snippet(node, () => $$props.children ?? noop);
  reset(label);
  template_effect(() => attributes = set_attributes(label, attributes, { ...get(mergedProps) }));
  append($$anchor, label);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  _command_label = hmr(_command_label, () => _command_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = _command_label[HMR].source;
    set(_command_label[HMR].source, module.default[HMR].original);
  });
}
var command_label_default = _command_label;
mark_module_end(_command_label);

// node_modules/bits-ui/dist/bits/command/components/command.svelte
mark_module_start();
Command[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command.svelte";
var root_37 = add_locations(template(`<!> <!>`, 1), Command[FILENAME], []);
var root_44 = add_locations(template(`<div><!> <!></div>`), Command[FILENAME], [[63, 1]]);
function Command($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command);
  const Label2 = wrap_snippet(Command, ($$anchor2) => {
    var fragment = comment();
    var node = first_child(fragment);
    command_label_default(node, {
      children: wrap_snippet(Command, ($$anchor3, $$slotProps) => {
        next();
        var text2 = text();
        template_effect(() => set_text(text2, label()));
        append($$anchor3, text2);
      }),
      $$slots: { default: true }
    });
    append($$anchor2, fragment);
  });
  validate_prop_bindings($$props, ["ref", "value"], [], Command);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop2), loop = prop($$props, "loop", 3, false), shouldFilter = prop($$props, "shouldFilter", 3, true), filter = prop($$props, "filter", 3, defaultFilter), label = prop($$props, "label", 3, ""), vimBindings = prop($$props, "vimBindings", 3, true), disablePointerSelection = prop($$props, "disablePointerSelection", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "loop",
      "shouldFilter",
      "filter",
      "label",
      "vimBindings",
      "disablePointerSelection",
      "controlledValue",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = useCommandRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    filter: box.with(() => filter()),
    shouldFilter: box.with(() => shouldFilter()),
    loop: box.with(() => loop()),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    vimBindings: box.with(() => vimBindings()),
    disablePointerSelection: box.with(() => disablePointerSelection())
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment_2 = comment();
  var node_1 = first_child(fragment_2);
  if_block(
    node_1,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_3 = root_37();
      var node_2 = first_child(fragment_3);
      Label2(node_2);
      var node_3 = sibling(node_2, 2);
      snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_3);
    },
    ($$anchor2) => {
      var div = root_44();
      let attributes;
      var node_4 = child(div);
      Label2(node_4);
      var node_5 = sibling(node_4, 2);
      snippet(node_5, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment_2);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command = hmr(Command, () => Command[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command[HMR].source;
    set(Command[HMR].source, module.default[HMR].original);
  });
}
var command_default = Command;
mark_module_end(Command);

// node_modules/bits-ui/dist/bits/command/components/command-empty.svelte
mark_module_start();
Command_empty[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-empty.svelte";
var root_38 = add_locations(template(`<div><!></div>`), Command_empty[FILENAME], [[32, 2]]);
function Command_empty($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_empty);
  validate_prop_bindings($$props, ["ref"], [], Command_empty);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const emptyState = useCommandEmpty({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount())
  });
  const mergedProps = derived(() => mergeProps(emptyState.props, restProps));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => emptyState.shouldRender, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    if_block(
      node_1,
      () => $$props.child,
      ($$anchor3) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
        append($$anchor3, fragment_2);
      },
      ($$anchor3) => {
        var div = root_38();
        let attributes;
        var node_3 = child(div);
        snippet(node_3, () => $$props.children ?? noop);
        reset(div);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
        append($$anchor3, div);
      }
    );
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_empty = hmr(Command_empty, () => Command_empty[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_empty[HMR].source;
    set(Command_empty[HMR].source, module.default[HMR].original);
  });
}
var command_empty_default = Command_empty;
mark_module_end(Command_empty);

// node_modules/bits-ui/dist/bits/command/components/command-group.svelte
mark_module_start();
Command_group[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group.svelte";
var root_239 = add_locations(template(`<div><!></div>`), Command_group[FILENAME], [[33, 1]]);
function Command_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_group);
  validate_prop_bindings($$props, ["ref"], [], Command_group);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "forceMount",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = useCommandGroupContainer({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount()),
    value: box.with(() => value())
  });
  const mergedProps = derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_239();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group = hmr(Command_group, () => Command_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group[HMR].source;
    set(Command_group[HMR].source, module.default[HMR].original);
  });
}
var command_group_default = Command_group;
mark_module_end(Command_group);

// node_modules/bits-ui/dist/bits/command/components/command-group-heading.svelte
mark_module_start();
Command_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group-heading.svelte";
var root_240 = add_locations(template(`<div><!></div>`), Command_group_heading[FILENAME], [[29, 1]]);
function Command_group_heading($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_group_heading);
  validate_prop_bindings($$props, ["ref"], [], Command_group_heading);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const headingState = useCommandGroupHeading({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, headingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_240();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group_heading = hmr(Command_group_heading, () => Command_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group_heading[HMR].source;
    set(Command_group_heading[HMR].source, module.default[HMR].original);
  });
}
var command_group_heading_default = Command_group_heading;
mark_module_end(Command_group_heading);

// node_modules/bits-ui/dist/bits/command/components/command-group-items.svelte
mark_module_start();
Command_group_items[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group-items.svelte";
var root_241 = add_locations(template(`<div><!></div>`), Command_group_items[FILENAME], [[30, 2]]);
var root7 = add_locations(template(`<div style="display: contents;"><!></div>`), Command_group_items[FILENAME], [[26, 0]]);
function Command_group_items($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_group_items);
  validate_prop_bindings($$props, ["ref"], [], Command_group_items);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupItemsState = useCommandGroupItems({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, groupItemsState.props));
  var div = root7();
  var node = child(div);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment);
    },
    ($$anchor2) => {
      var div_1 = root_241();
      let attributes;
      var node_2 = child(div_1);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div_1);
      template_effect(() => attributes = set_attributes(div_1, attributes, { ...get(mergedProps) }));
      append($$anchor2, div_1);
    }
  );
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group_items = hmr(Command_group_items, () => Command_group_items[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group_items[HMR].source;
    set(Command_group_items[HMR].source, module.default[HMR].original);
  });
}
var command_group_items_default = Command_group_items;
mark_module_end(Command_group_items);

// node_modules/bits-ui/dist/bits/command/components/command-input.svelte
mark_module_start();
Command_input[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-input.svelte";
var root_242 = add_locations(template(`<input>`), Command_input[FILENAME], [[37, 1]]);
function Command_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_input);
  validate_prop_bindings($$props, ["value", "ref"], [], Command_input);
  let value = prop($$props, "value", 15, ""), autofocus = prop($$props, "autofocus", 3, false), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "value",
      "autofocus",
      "id",
      "ref",
      "child"
    ],
    "restProps"
  );
  const inputState = useCommandInput({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      value(v);
    }),
    autofocus: box.with(() => autofocus() ?? false)
  });
  const mergedProps = derived(() => mergeProps(restProps, inputState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var input = root_242();
      remove_input_defaults(input);
      let attributes;
      template_effect(() => attributes = set_attributes(input, attributes, { ...get(mergedProps) }));
      bind_value(input, value);
      append($$anchor2, input);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_input = hmr(Command_input, () => Command_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_input[HMR].source;
    set(Command_input[HMR].source, module.default[HMR].original);
  });
}
var command_input_default = Command_input;
mark_module_end(Command_input);

// node_modules/bits-ui/dist/bits/command/components/command-item.svelte
mark_module_start();
Command_item[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-item.svelte";
var root_45 = add_locations(template(`<div><!></div>`), Command_item[FILENAME], [[46, 4]]);
var root_14 = add_locations(template(`<div style="display: contents;" data-item-wrapper=""><!></div>`), Command_item[FILENAME], [[41, 1]]);
function Command_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_item);
  validate_prop_bindings($$props, ["ref"], [], Command_item);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "disabled",
      "children",
      "child",
      "onSelect",
      "forceMount",
      "keywords"
    ],
    "restProps"
  );
  const group = getCommandGroupContainerContext(null);
  const itemState = useCommandItem({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    forceMount: box.with(() => forceMount()),
    keywords: box.with(() => keywords()),
    group
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => itemState.root.key, ($$anchor2) => {
    var div = root_14();
    var node_1 = child(div);
    if_block(node_1, () => itemState.shouldRender, ($$anchor3) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      if_block(
        node_2,
        () => $$props.child,
        ($$anchor4) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor4, fragment_2);
        },
        ($$anchor4) => {
          var div_1 = root_45();
          let attributes;
          var node_4 = child(div_1);
          snippet(node_4, () => $$props.children ?? noop);
          reset(div_1);
          template_effect(() => attributes = set_attributes(div_1, attributes, { ...get(mergedProps) }));
          append($$anchor4, div_1);
        }
      );
      append($$anchor3, fragment_1);
    });
    reset(div);
    template_effect(() => set_attribute(div, "data-value", value()));
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_item = hmr(Command_item, () => Command_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_item[HMR].source;
    set(Command_item[HMR].source, module.default[HMR].original);
  });
}
var command_item_default = Command_item;
mark_module_end(Command_item);

// node_modules/bits-ui/dist/bits/command/components/command-link-item.svelte
mark_module_start();
Command_link_item[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-link-item.svelte";
var root_46 = add_locations(template(`<a><!></a>`), Command_link_item[FILENAME], [[46, 4]]);
var root_15 = add_locations(template(`<div style="display: contents;"><!></div>`), Command_link_item[FILENAME], [[41, 1]]);
function Command_link_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_link_item);
  validate_prop_bindings($$props, ["ref"], [], Command_link_item);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "disabled",
      "children",
      "child",
      "onSelect",
      "forceMount",
      "keywords"
    ],
    "restProps"
  );
  const group = getCommandGroupContainerContext(null);
  const itemState = useCommandItem({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    forceMount: box.with(() => forceMount()),
    keywords: box.with(() => keywords()),
    group
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => itemState.root.key, ($$anchor2) => {
    var div = root_15();
    var node_1 = child(div);
    if_block(node_1, () => itemState.shouldRender, ($$anchor3) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      if_block(
        node_2,
        () => $$props.child,
        ($$anchor4) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor4, fragment_2);
        },
        ($$anchor4) => {
          var a2 = root_46();
          let attributes;
          var node_4 = child(a2);
          snippet(node_4, () => $$props.children ?? noop);
          reset(a2);
          template_effect(() => attributes = set_attributes(a2, attributes, { ...get(mergedProps) }));
          append($$anchor4, a2);
        }
      );
      append($$anchor3, fragment_1);
    });
    reset(div);
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_link_item = hmr(Command_link_item, () => Command_link_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_link_item[HMR].source;
    set(Command_link_item[HMR].source, module.default[HMR].original);
  });
}
var command_link_item_default = Command_link_item;
mark_module_end(Command_link_item);

// node_modules/bits-ui/dist/bits/command/components/command-list.svelte
mark_module_start();
Command_list[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-list.svelte";
var root_243 = add_locations(template(`<div><!></div>`), Command_list[FILENAME], [[31, 1]]);
function Command_list($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_list);
  validate_prop_bindings($$props, ["ref"], [], Command_list);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "aria-label"
    ],
    "restProps"
  );
  const listState = useCommandList({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    ariaLabel: box.with(() => $$props["aria-label"] ?? "Suggestions...")
  });
  const mergedProps = derived(() => mergeProps(restProps, listState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_243();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_list = hmr(Command_list, () => Command_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_list[HMR].source;
    set(Command_list[HMR].source, module.default[HMR].original);
  });
}
var command_list_default = Command_list;
mark_module_end(Command_list);

// node_modules/bits-ui/dist/bits/command/components/command-viewport.svelte
mark_module_start();
Command_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-viewport.svelte";
var root_244 = add_locations(template(`<div><!></div>`), Command_viewport[FILENAME], [[29, 1]]);
function Command_viewport($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_viewport);
  validate_prop_bindings($$props, ["ref"], [], Command_viewport);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const listViewportState = useCommandViewport({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, listViewportState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_244();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_viewport = hmr(Command_viewport, () => Command_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_viewport[HMR].source;
    set(Command_viewport[HMR].source, module.default[HMR].original);
  });
}
var command_viewport_default = Command_viewport;
mark_module_end(Command_viewport);

// node_modules/bits-ui/dist/bits/command/components/command-loading.svelte
mark_module_start();
Command_loading[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-loading.svelte";
var root_245 = add_locations(template(`<div><!></div>`), Command_loading[FILENAME], [[31, 1]]);
function Command_loading($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_loading);
  validate_prop_bindings($$props, ["ref"], [], Command_loading);
  let progress = prop($$props, "progress", 3, 0), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "progress",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const loadingState = useCommandLoading({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    progress: box.with(() => progress())
  });
  const mergedProps = derived(() => mergeProps(restProps, loadingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_245();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_loading = hmr(Command_loading, () => Command_loading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_loading[HMR].source;
    set(Command_loading[HMR].source, module.default[HMR].original);
  });
}
var command_loading_default = Command_loading;
mark_module_end(Command_loading);

// node_modules/bits-ui/dist/bits/command/components/command-separator.svelte
mark_module_start();
Command_separator[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-separator.svelte";
var root_39 = add_locations(template(`<div><!></div>`), Command_separator[FILENAME], [[32, 2]]);
function Command_separator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Command_separator);
  validate_prop_bindings($$props, ["ref"], [], Command_separator);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "children",
      "child"
    ],
    "restProps"
  );
  const separatorState = useCommandSeparator({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount())
  });
  const mergedProps = derived(() => mergeProps(restProps, separatorState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => separatorState.shouldRender, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    if_block(
      node_1,
      () => $$props.child,
      ($$anchor3) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
        append($$anchor3, fragment_2);
      },
      ($$anchor3) => {
        var div = root_39();
        let attributes;
        var node_3 = child(div);
        snippet(node_3, () => $$props.children ?? noop);
        reset(div);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
        append($$anchor3, div);
      }
    );
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_separator = hmr(Command_separator, () => Command_separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_separator[HMR].source;
    set(Command_separator[HMR].source, module.default[HMR].original);
  });
}
var command_separator_default = Command_separator;
mark_module_end(Command_separator);

// node_modules/bits-ui/dist/bits/context-menu/exports.js
var exports_exports11 = {};
__export(exports_exports11, {
  Arrow: () => menu_arrow_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => context_menu_content_default,
  ContentStatic: () => context_menu_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => context_menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => context_menu_trigger_default
});

// node_modules/bits-ui/dist/bits/menu/utils.js
var SELECTION_KEYS3 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var FIRST_KEYS3 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS3 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS3 = [...FIRST_KEYS3, ...LAST_KEYS3];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS3, kbd_constants_exports.ARROW_RIGHT],
  rtl: [...SELECTION_KEYS3, kbd_constants_exports.ARROW_LEFT]
};
var SUB_CLOSE_KEYS = {
  ltr: [kbd_constants_exports.ARROW_LEFT],
  rtl: [kbd_constants_exports.ARROW_RIGHT]
};
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function isMouseEvent(event) {
  return event.pointerType === "mouse";
}

// node_modules/bits-ui/dist/internal/polygon.js
function makeHull(points) {
  const newPoints = points.slice();
  newPoints.sort(POINT_COMPARATOR);
  return makeHullPresorted(newPoints);
}
function makeHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
function POINT_COMPARATOR(a2, b) {
  if (a2.x < b.x)
    return -1;
  else if (a2.x > b.x)
    return 1;
  else if (a2.y < b.y)
    return -1;
  else if (a2.y > b.y)
    return 1;
  else
    return 0;
}
function getPointsFromEl(el) {
  const rect = el.getBoundingClientRect();
  return [
    { x: rect.left, y: rect.top },
    { x: rect.right, y: rect.top },
    { x: rect.right, y: rect.bottom },
    { x: rect.left, y: rect.bottom }
  ];
}
function makeHullFromElements(els) {
  const points = els.flatMap((el) => getPointsFromEl(el));
  return makeHull(points);
}
function pointInPolygon(point, polygon) {
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(e, area) {
  if (!area)
    return false;
  return pointInPolygon({ x: e.clientX, y: e.clientY }, area);
}

// node_modules/bits-ui/dist/bits/menu/menu.svelte.js
var CONTEXT_MENU_TRIGGER_ATTR = "data-context-menu-trigger";
var [setMenuRootContext, getMenuRootContext] = createContext("Menu.Root");
var [setMenuMenuContext, getMenuMenuContext] = createContext(["Menu.Root", "Menu.Sub"], "MenuContext");
var [setMenuContentContext, getMenuContentContext] = createContext("Menu.Content");
var [setMenuGroupContext, getMenuGroupContext] = createContext("Menu.Group");
var [
  setMenuRadioGroupContext,
  getMenuRadioGroupContext
] = createContext("Menu.RadioGroup");
var MenuRootState = class {
  constructor(props) {
    __publicField(this, "onClose");
    __publicField(this, "variant");
    __publicField(this, "isUsingKeyboard", box(false));
    __publicField(this, "dir");
    __publicField(this, "getAttr", (name) => {
      return `data-${this.variant.current}-${name}`;
    });
    this.onClose = props.onClose;
    this.dir = props.dir;
    this.variant = props.variant;
    user_effect(() => {
      const callbacksToDispose = [];
      const handlePointer = (_) => {
        this.isUsingKeyboard.current = false;
      };
      const handleKeydown = (_) => {
        this.isUsingKeyboard.current = true;
        const disposePointerDown = addEventListener2(document, "pointerdown", handlePointer, { capture: true, once: true });
        const disposePointerMove = addEventListener2(document, "pointermove", handlePointer, { capture: true, once: true });
        callbacksToDispose.push(disposePointerDown, disposePointerMove);
      };
      const disposeKeydown = addEventListener2(document, "keydown", handleKeydown, { capture: true });
      callbacksToDispose.push(disposeKeydown);
      return () => {
        executeCallbacks(callbacksToDispose);
      };
    });
  }
};
var _contentNode4, _triggerNode3;
var MenuMenuState = class {
  constructor(props, root17, parentMenu) {
    __publicField(this, "root");
    __publicField(this, "open");
    __publicField(this, "contentId", box.with(() => ""));
    __privateAdd(this, _contentNode4, state(null));
    __privateAdd(this, _triggerNode3, state(null));
    __publicField(this, "parentMenu");
    __publicField(this, "toggleOpen", () => {
      this.open.current = !this.open.current;
    });
    __publicField(this, "onOpen", () => {
      this.open.current = true;
    });
    __publicField(this, "onClose", () => {
      this.open.current = false;
    });
    this.root = root17;
    this.open = props.open;
    this.parentMenu = parentMenu;
    if (parentMenu) {
      user_effect(() => {
        parentMenu.open;
        untrack(() => {
          var _a;
          if (!((_a = this.parentMenu) == null ? void 0 : _a.open)) this.open.current = false;
        });
      });
    }
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode4));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode4), proxy(value, null, __privateGet(this, _contentNode4)));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode3));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode3), proxy(value, null, __privateGet(this, _triggerNode3)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _contentNode4)), owner, false);
    add_owner(get(__privateGet(this, _triggerNode3)), owner, false);
  }
};
_contentNode4 = new WeakMap();
_triggerNode3 = new WeakMap();
var _id43, _search, _loop2, _timer, _pointerGraceTimer, _pointerGraceIntent, _pointerDir, _lastPointerX, _handleTypeaheadSearch, _onkeydown14, _onblur2, _onfocus3, _onpointermove5, _snippetProps11, _props63;
var MenuContentState = class {
  constructor(props, parentMenu) {
    __privateAdd(this, _id43);
    __publicField(this, "contentRef");
    __publicField(this, "parentMenu");
    __privateAdd(this, _search, state(""));
    __privateAdd(this, _loop2);
    __privateAdd(this, _timer, state(0));
    __privateAdd(this, _pointerGraceTimer, state(0));
    __privateAdd(this, _pointerGraceIntent, state(null));
    __privateAdd(this, _pointerDir, state("right"));
    __privateAdd(this, _lastPointerX, state(0));
    __privateAdd(this, _handleTypeaheadSearch);
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "isMounted");
    __publicField(this, "isFocusWithin", new IsFocusWithin(() => this.parentMenu.contentNode ?? void 0));
    __publicField(this, "getCandidateNodes", () => {
      const node = this.parentMenu.contentNode;
      if (!node) return [];
      const candidates = Array.from(node.querySelectorAll(`[${this.parentMenu.root.getAttr("item")}]:not([data-disabled])`));
      return candidates;
    });
    __publicField(this, "isPointerMovingToSubmenu", (e) => {
      var _a, _b;
      const isMovingTowards = strict_equals(get(__privateGet(this, _pointerDir)), (_a = get(__privateGet(this, _pointerGraceIntent))) == null ? void 0 : _a.side);
      return isMovingTowards && isPointerInGraceArea(e, (_b = get(__privateGet(this, _pointerGraceIntent))) == null ? void 0 : _b.area);
    });
    __publicField(this, "onPointerGraceIntentChange", (intent) => {
      set(__privateGet(this, _pointerGraceIntent), proxy(intent, null, __privateGet(this, _pointerGraceIntent)));
    });
    __privateAdd(this, _onkeydown14, (e) => {
      var _a, _b;
      if (e.defaultPrevented) return;
      const target = e.target;
      const currentTarget = e.currentTarget;
      if (!isHTMLElement(target) || !isHTMLElement(currentTarget)) return;
      const isKeydownInside = strict_equals((_a = target.closest(`[${this.parentMenu.root.getAttr("content")}]`)) == null ? void 0 : _a.id, this.parentMenu.contentId.current);
      const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
      const isCharacterKey = strict_equals(e.key.length, 1);
      const kbdFocusedEl = this.rovingFocusGroup.handleKeydown(target, e);
      if (kbdFocusedEl) return;
      if (strict_equals(e.code, "Space")) return;
      const candidateNodes = this.getCandidateNodes();
      if (isKeydownInside) {
        if (strict_equals(e.key, kbd_constants_exports.TAB)) e.preventDefault();
        if (!isModifierKey && isCharacterKey) {
          __privateGet(this, _handleTypeaheadSearch).call(this, e.key, candidateNodes);
        }
      }
      if (strict_equals((_b = e.target) == null ? void 0 : _b.id, this.parentMenu.contentId.current, false)) return;
      if (!FIRST_LAST_KEYS3.includes(e.key)) return;
      e.preventDefault();
      if (LAST_KEYS3.includes(e.key)) {
        candidateNodes.reverse();
      }
      focusFirst(candidateNodes);
    });
    __privateAdd(this, _onblur2, (e) => {
      var _a, _b;
      if (!isElement(e.currentTarget)) return;
      if (!isElement(e.target)) return;
      if (!((_b = (_a = e.currentTarget).contains) == null ? void 0 : _b.call(_a, e.target))) {
        window.clearTimeout(get(__privateGet(this, _timer)));
        this.search = "";
      }
    });
    __privateAdd(this, _onfocus3, () => {
      if (!this.parentMenu.root.isUsingKeyboard.current) return;
      afterTick(() => this.rovingFocusGroup.focusFirstCandidate());
    });
    __privateAdd(this, _onpointermove5, (e) => {
      if (!isMouseEvent(e)) return;
      const target = e.target;
      if (!isElement(target)) return;
      const pointerXHasChanged = strict_equals(get(__privateGet(this, _lastPointerX)), e.clientX, false);
      const currentTarget = e.currentTarget;
      if (!isElement(currentTarget)) return;
      if (currentTarget.contains(target) && pointerXHasChanged) {
        const newDir = e.clientX > get(__privateGet(this, _lastPointerX)) ? "right" : "left";
        set(__privateGet(this, _pointerDir), proxy(newDir, null, __privateGet(this, _pointerDir)));
        set(__privateGet(this, _lastPointerX), proxy(e.clientX, null, __privateGet(this, _lastPointerX)));
      }
    });
    __publicField(this, "onItemEnter", (e) => {
      if (this.isPointerMovingToSubmenu(e)) return true;
      return false;
    });
    __publicField(this, "onItemLeave", (e) => {
      if (this.isPointerMovingToSubmenu(e)) return;
      const contentNode = this.parentMenu.contentNode;
      contentNode == null ? void 0 : contentNode.focus();
      this.rovingFocusGroup.setCurrentTabStopId("");
    });
    __publicField(this, "onTriggerLeave", (e) => {
      if (this.isPointerMovingToSubmenu(e)) return true;
      return false;
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      if (e.defaultPrevented) return;
      e.preventDefault();
      const contentNode = this.parentMenu.contentNode;
      contentNode == null ? void 0 : contentNode.focus();
    });
    __publicField(this, "handleInteractOutside", (e) => {
      var _a;
      if (!isElementOrSVGElement(e.target)) return;
      const triggerId = (_a = this.parentMenu.triggerNode) == null ? void 0 : _a.id;
      if (strict_equals(e.target.id, triggerId)) {
        e.preventDefault();
        return;
      }
      if (e.target.closest(`#${triggerId}`)) {
        e.preventDefault();
      }
    });
    __privateAdd(this, _snippetProps11, derived(() => ({ open: this.parentMenu.open.current })));
    __privateAdd(this, _props63, derived(() => ({
      id: __privateGet(this, _id43).current,
      role: "menu",
      "aria-orientation": getAriaOrientation("vertical"),
      [this.parentMenu.root.getAttr("content")]: "",
      "data-state": getDataOpenClosed(this.parentMenu.open.current),
      onkeydown: __privateGet(this, _onkeydown14),
      onblur: __privateGet(this, _onblur2),
      onpointermove: __privateGet(this, _onpointermove5),
      onfocus: __privateGet(this, _onfocus3),
      dir: this.parentMenu.root.dir.current,
      style: { pointerEvents: "auto" }
    })));
    __privateSet(this, _id43, props.id);
    __privateSet(this, _loop2, props.loop);
    this.parentMenu = parentMenu;
    this.parentMenu.contentId = props.id;
    this.contentRef = props.ref;
    this.isMounted = props.isMounted;
    useRefById({
      id: __privateGet(this, _id43),
      ref: this.contentRef,
      deps: () => this.parentMenu.open.current,
      onRefChange: (node) => {
        if (strict_equals(this.parentMenu.contentNode, node, false)) {
          this.parentMenu.contentNode = node;
        }
      }
    });
    onDestroyEffect(() => {
      window.clearTimeout(get(__privateGet(this, _timer)));
    });
    __privateSet(this, _handleTypeaheadSearch, useDOMTypeahead().handleTypeaheadSearch);
    this.rovingFocusGroup = useRovingFocus({
      rootNodeId: this.parentMenu.contentId,
      candidateAttr: this.parentMenu.root.getAttr("item"),
      loop: __privateGet(this, _loop2),
      orientation: box.with(() => "vertical")
    });
  }
  get search() {
    return get(__privateGet(this, _search));
  }
  set search(value) {
    set(__privateGet(this, _search), proxy(value, null, __privateGet(this, _search)));
  }
  get pointerGraceTimer() {
    return get(__privateGet(this, _pointerGraceTimer));
  }
  set pointerGraceTimer(value) {
    set(__privateGet(this, _pointerGraceTimer), proxy(value, null, __privateGet(this, _pointerGraceTimer)));
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps11));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props63));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _search)), owner, false);
    add_owner(get(__privateGet(this, _pointerGraceTimer)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps11)), owner, false);
    add_owner(get(__privateGet(this, _props63)), owner, false);
  }
};
_id43 = new WeakMap();
_search = new WeakMap();
_loop2 = new WeakMap();
_timer = new WeakMap();
_pointerGraceTimer = new WeakMap();
_pointerGraceIntent = new WeakMap();
_pointerDir = new WeakMap();
_lastPointerX = new WeakMap();
_handleTypeaheadSearch = new WeakMap();
_onkeydown14 = new WeakMap();
_onblur2 = new WeakMap();
_onfocus3 = new WeakMap();
_onpointermove5 = new WeakMap();
_snippetProps11 = new WeakMap();
_props63 = new WeakMap();
var _isFocused2, _onpointermove6, _onpointerleave2, _onfocus4, _onblur3, _props64;
var MenuItemSharedState = class {
  constructor(props, content) {
    __publicField(this, "content");
    __publicField(this, "ref");
    __publicField(this, "id");
    __publicField(this, "disabled");
    __privateAdd(this, _isFocused2, state(false));
    __privateAdd(this, _onpointermove6, (e) => {
      if (e.defaultPrevented) return;
      if (!isMouseEvent(e)) return;
      if (this.disabled.current) {
        this.content.onItemLeave(e);
      } else {
        const defaultPrevented = this.content.onItemEnter(e);
        if (defaultPrevented) return;
        const item = e.currentTarget;
        if (!isHTMLElement(item)) return;
        item.focus();
      }
    });
    __privateAdd(this, _onpointerleave2, async (e) => {
      afterTick(() => {
        if (e.defaultPrevented) return;
        if (!isMouseEvent(e)) return;
        this.content.onItemLeave(e);
      });
    });
    __privateAdd(this, _onfocus4, async (e) => {
      afterTick(() => {
        if (e.defaultPrevented || this.disabled.current) return;
        set(__privateGet(this, _isFocused2), true);
      });
    });
    __privateAdd(this, _onblur3, async (e) => {
      afterTick(() => {
        if (e.defaultPrevented) return;
        set(__privateGet(this, _isFocused2), false);
      });
    });
    __privateAdd(this, _props64, derived(() => ({
      id: this.id.current,
      tabindex: -1,
      role: "menuitem",
      "aria-disabled": getAriaDisabled(this.disabled.current),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-highlighted": get(__privateGet(this, _isFocused2)) ? "" : void 0,
      [this.content.parentMenu.root.getAttr("item")]: "",
      //
      onpointermove: __privateGet(this, _onpointermove6),
      onpointerleave: __privateGet(this, _onpointerleave2),
      onfocus: __privateGet(this, _onfocus4),
      onblur: __privateGet(this, _onblur3)
    })));
    this.content = content;
    this.id = props.id;
    this.disabled = props.disabled;
    this.ref = props.ref;
    useRefById({
      id: this.id,
      ref: this.ref,
      deps: () => this.content.isMounted.current
    });
  }
  get props() {
    return get(__privateGet(this, _props64));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props64)), owner, false);
  }
};
_isFocused2 = new WeakMap();
_onpointermove6 = new WeakMap();
_onpointerleave2 = new WeakMap();
_onfocus4 = new WeakMap();
_onblur3 = new WeakMap();
_props64 = new WeakMap();
var _item2, _onSelect2, _closeOnSelect, _isPointerDown, _onkeydown15, _handleSelect, _onclick10, _onpointerup5, _onpointerdown10, _props65;
var MenuItemState = class {
  constructor(props, item) {
    __privateAdd(this, _item2);
    __privateAdd(this, _onSelect2);
    __privateAdd(this, _closeOnSelect);
    __privateAdd(this, _isPointerDown, state(false));
    __publicField(this, "root");
    __privateAdd(this, _onkeydown15, (e) => {
      const isTypingAhead = strict_equals(__privateGet(this, _item2).content.search, "", false);
      if (__privateGet(this, _item2).disabled.current || isTypingAhead && strict_equals(e.key, kbd_constants_exports.SPACE)) return;
      if (SELECTION_KEYS3.includes(e.key)) {
        if (!isHTMLElement(e.currentTarget)) return;
        e.currentTarget.click();
        e.preventDefault();
      }
    });
    __privateAdd(this, _handleSelect, async () => {
      if (__privateGet(this, _item2).disabled.current) return;
      const selectEvent = new CustomEvent("menuitemselect", { bubbles: true, cancelable: true });
      __privateGet(this, _onSelect2).current(selectEvent);
      await tick();
      if (selectEvent.defaultPrevented) {
        __privateGet(this, _item2).content.parentMenu.root.isUsingKeyboard.current = false;
        return;
      }
      if (__privateGet(this, _closeOnSelect).current) {
        __privateGet(this, _item2).content.parentMenu.root.onClose();
      }
    });
    __privateAdd(this, _onclick10, () => {
      if (__privateGet(this, _item2).disabled.current) return;
      __privateGet(this, _handleSelect).call(this);
    });
    __privateAdd(this, _onpointerup5, async (e) => {
      var _a;
      if (e.defaultPrevented) return;
      if (!get(__privateGet(this, _isPointerDown))) {
        if (!isHTMLElement(e.currentTarget)) return;
        (_a = e.currentTarget) == null ? void 0 : _a.click();
      }
    });
    __privateAdd(this, _onpointerdown10, () => {
      set(__privateGet(this, _isPointerDown), true);
    });
    __privateAdd(this, _props65, derived(() => mergeProps(__privateGet(this, _item2).props, {
      onclick: __privateGet(this, _onclick10),
      onpointerdown: __privateGet(this, _onpointerdown10),
      onpointerup: __privateGet(this, _onpointerup5),
      onkeydown: __privateGet(this, _onkeydown15)
    })));
    __privateSet(this, _item2, item);
    this.root = item.content.parentMenu.root;
    __privateSet(this, _onSelect2, props.onSelect);
    __privateSet(this, _closeOnSelect, props.closeOnSelect);
  }
  get props() {
    return get(__privateGet(this, _props65));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props65)), owner, false);
  }
};
_item2 = new WeakMap();
_onSelect2 = new WeakMap();
_closeOnSelect = new WeakMap();
_isPointerDown = new WeakMap();
_onkeydown15 = new WeakMap();
_handleSelect = new WeakMap();
_onclick10 = new WeakMap();
_onpointerup5 = new WeakMap();
_onpointerdown10 = new WeakMap();
_props65 = new WeakMap();
var _item3, _content2, _submenu, _openTimer, _clearOpenTimer, _onpointermove7, _onpointerleave3, _onkeydown16, _onclick11, _props66;
var MenuSubTriggerState = class {
  constructor(item, content, submenu) {
    __privateAdd(this, _item3);
    // The menu this sub-trigger item belongs within
    __privateAdd(this, _content2);
    // the menu this sub-trigger item opens
    __privateAdd(this, _submenu);
    __privateAdd(this, _openTimer, state(null));
    __privateAdd(this, _clearOpenTimer, () => {
      if (strict_equals(get(__privateGet(this, _openTimer)), null)) return;
      window.clearTimeout(get(__privateGet(this, _openTimer)));
      set(__privateGet(this, _openTimer), null);
    });
    __privateAdd(this, _onpointermove7, (e) => {
      if (!isMouseEvent(e)) return;
      const defaultPrevented = __privateGet(this, _content2).onItemEnter(e);
      if (defaultPrevented) return;
      if (!__privateGet(this, _item3).disabled.current && !__privateGet(this, _submenu).open.current && !get(__privateGet(this, _openTimer))) {
        __privateGet(this, _content2).onPointerGraceIntentChange(null);
        set(__privateGet(this, _openTimer), proxy(
          window.setTimeout(
            () => {
              __privateGet(this, _submenu).onOpen();
              __privateGet(this, _clearOpenTimer).call(this);
            },
            100
          ),
          null,
          __privateGet(this, _openTimer)
        ));
      }
    });
    __privateAdd(this, _onpointerleave3, (e) => {
      if (!isMouseEvent(e)) return;
      __privateGet(this, _clearOpenTimer).call(this);
      const contentNode = __privateGet(this, _submenu).contentNode;
      const subTriggerNode = __privateGet(this, _item3).ref.current;
      if (contentNode && subTriggerNode) {
        const polygon = makeHullFromElements([subTriggerNode, contentNode]);
        const side = contentNode == null ? void 0 : contentNode.dataset.side;
        __privateGet(this, _content2).onPointerGraceIntentChange({ area: polygon, side });
        window.clearTimeout(__privateGet(this, _content2).pointerGraceTimer);
        __privateGet(this, _content2).pointerGraceTimer = window.setTimeout(() => __privateGet(this, _content2).onPointerGraceIntentChange(null), 300);
      } else {
        const defaultPrevented = __privateGet(this, _content2).onTriggerLeave(e);
        if (defaultPrevented) return;
        __privateGet(this, _content2).onPointerGraceIntentChange(null);
      }
    });
    __privateAdd(this, _onkeydown16, (e) => {
      const isTypingAhead = strict_equals(__privateGet(this, _content2).search, "", false);
      if (__privateGet(this, _item3).disabled.current || isTypingAhead && strict_equals(e.key, kbd_constants_exports.SPACE)) return;
      if (SUB_OPEN_KEYS[__privateGet(this, _submenu).root.dir.current].includes(e.key)) {
        __privateGet(this, _submenu).onOpen();
        const contentNode = __privateGet(this, _submenu).contentNode;
        contentNode == null ? void 0 : contentNode.focus();
        e.preventDefault();
      }
    });
    __privateAdd(this, _onclick11, (e) => {
      if (__privateGet(this, _item3).disabled.current) return;
      if (!isHTMLElement(e.currentTarget)) return;
      e.currentTarget.focus();
      if (!__privateGet(this, _submenu).open.current) {
        __privateGet(this, _submenu).onOpen();
      }
    });
    __privateAdd(this, _props66, derived(() => mergeProps(
      {
        "aria-haspopup": "menu",
        "aria-expanded": getAriaExpanded(__privateGet(this, _submenu).open.current),
        "data-state": getDataOpenClosed(__privateGet(this, _submenu).open.current),
        "aria-controls": __privateGet(this, _submenu).open.current ? __privateGet(this, _submenu).contentId.current : void 0,
        [__privateGet(this, _submenu).root.getAttr("sub-trigger")]: "",
        onclick: __privateGet(this, _onclick11),
        onpointermove: __privateGet(this, _onpointermove7),
        onpointerleave: __privateGet(this, _onpointerleave3),
        onkeydown: __privateGet(this, _onkeydown16)
      },
      __privateGet(this, _item3).props
    )));
    __privateSet(this, _item3, item);
    __privateSet(this, _content2, content);
    __privateSet(this, _submenu, submenu);
    onDestroyEffect(() => {
      __privateGet(this, _clearOpenTimer).call(this);
    });
    useRefById({
      id: __privateGet(this, _item3).id,
      ref: __privateGet(this, _item3).ref,
      onRefChange: (node) => {
        __privateGet(this, _submenu).triggerNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props66));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props66)), owner, false);
  }
};
_item3 = new WeakMap();
_content2 = new WeakMap();
_submenu = new WeakMap();
_openTimer = new WeakMap();
_clearOpenTimer = new WeakMap();
_onpointermove7 = new WeakMap();
_onpointerleave3 = new WeakMap();
_onkeydown16 = new WeakMap();
_onclick11 = new WeakMap();
_props66 = new WeakMap();
var _item4, _checked, _indeterminate, _snippetProps12, _props67;
var MenuCheckboxItemState = class {
  constructor(props, item) {
    __privateAdd(this, _item4);
    __privateAdd(this, _checked);
    __privateAdd(this, _indeterminate);
    __publicField(this, "toggleChecked", () => {
      if (__privateGet(this, _indeterminate).current) {
        __privateGet(this, _indeterminate).current = false;
        __privateGet(this, _checked).current = true;
      } else {
        __privateGet(this, _checked).current = !__privateGet(this, _checked).current;
      }
    });
    __privateAdd(this, _snippetProps12, derived(() => ({
      checked: __privateGet(this, _checked).current,
      indeterminate: __privateGet(this, _indeterminate).current
    })));
    __privateAdd(this, _props67, derived(() => ({
      ...__privateGet(this, _item4).props,
      role: "menuitemcheckbox",
      "aria-checked": getAriaChecked(__privateGet(this, _checked).current, __privateGet(this, _indeterminate).current),
      "data-state": getCheckedState(__privateGet(this, _checked).current),
      [__privateGet(this, _item4).root.getAttr("checkbox-item")]: ""
    })));
    __privateSet(this, _item4, item);
    __privateSet(this, _checked, props.checked);
    __privateSet(this, _indeterminate, props.indeterminate);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps12));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props67));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps12)), owner, false);
    add_owner(get(__privateGet(this, _props67)), owner, false);
  }
};
_item4 = new WeakMap();
_checked = new WeakMap();
_indeterminate = new WeakMap();
_snippetProps12 = new WeakMap();
_props67 = new WeakMap();
var _id44, _ref44, _groupHeadingId, _props68;
var MenuGroupState = class {
  constructor(props, root17) {
    __privateAdd(this, _id44);
    __privateAdd(this, _ref44);
    __privateAdd(this, _groupHeadingId, state(void 0));
    __publicField(this, "root");
    __privateAdd(this, _props68, derived(() => ({
      id: __privateGet(this, _id44).current,
      role: "group",
      "aria-labelledby": this.groupHeadingId,
      [this.root.getAttr("group")]: ""
    })));
    __privateSet(this, _id44, props.id);
    __privateSet(this, _ref44, props.ref);
    this.root = root17;
    useRefById({ id: __privateGet(this, _id44), ref: __privateGet(this, _ref44) });
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId), proxy(value, null, __privateGet(this, _groupHeadingId)));
  }
  get props() {
    return get(__privateGet(this, _props68));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _groupHeadingId)), owner, false);
    add_owner(get(__privateGet(this, _props68)), owner, false);
  }
};
_id44 = new WeakMap();
_ref44 = new WeakMap();
_groupHeadingId = new WeakMap();
_props68 = new WeakMap();
var _id45, _ref45, _group4, _props69;
var MenuGroupHeadingState = class {
  constructor(props, group) {
    __privateAdd(this, _id45);
    __privateAdd(this, _ref45);
    __privateAdd(this, _group4);
    __privateAdd(this, _props69, derived(() => ({
      id: __privateGet(this, _id45).current,
      role: "group",
      [__privateGet(this, _group4).root.getAttr("group-heading")]: ""
    })));
    __privateSet(this, _id45, props.id);
    __privateSet(this, _ref45, props.ref);
    __privateSet(this, _group4, group);
    useRefById({
      id: __privateGet(this, _id45),
      ref: __privateGet(this, _ref45),
      onRefChange: (node) => {
        __privateGet(this, _group4).groupHeadingId = node == null ? void 0 : node.id;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props69));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props69)), owner, false);
  }
};
_id45 = new WeakMap();
_ref45 = new WeakMap();
_group4 = new WeakMap();
_props69 = new WeakMap();
var _id46, _ref46, _root16, _props70;
var MenuSeparatorState = class {
  constructor(props, root17) {
    __privateAdd(this, _id46);
    __privateAdd(this, _ref46);
    __privateAdd(this, _root16);
    __privateAdd(this, _props70, derived(() => ({
      id: __privateGet(this, _id46).current,
      role: "group",
      [__privateGet(this, _root16).getAttr("separator")]: ""
    })));
    __privateSet(this, _id46, props.id);
    __privateSet(this, _ref46, props.ref);
    __privateSet(this, _root16, root17);
    useRefById({ id: __privateGet(this, _id46), ref: __privateGet(this, _ref46) });
  }
  get props() {
    return get(__privateGet(this, _props70));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props70)), owner, false);
  }
};
_id46 = new WeakMap();
_ref46 = new WeakMap();
_root16 = new WeakMap();
_props70 = new WeakMap();
var _root17, _props71;
var MenuArrowState = class {
  constructor(root17) {
    __privateAdd(this, _root17);
    __privateAdd(this, _props71, derived(() => ({ [__privateGet(this, _root17).getAttr("arrow")]: "" })));
    __privateSet(this, _root17, root17);
  }
  get props() {
    return get(__privateGet(this, _props71));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props71)), owner, false);
  }
};
_root17 = new WeakMap();
_props71 = new WeakMap();
var _id47, _ref47, _groupHeadingId2, _props72;
var MenuRadioGroupState = class {
  constructor(props, content) {
    __privateAdd(this, _id47);
    __publicField(this, "value");
    __privateAdd(this, _ref47);
    __publicField(this, "content");
    __privateAdd(this, _groupHeadingId2, state(null));
    __publicField(this, "root");
    __publicField(this, "setValue", (v) => {
      this.value.current = v;
    });
    __privateAdd(this, _props72, derived(() => ({
      id: __privateGet(this, _id47).current,
      [this.root.getAttr("radio-group")]: "",
      role: "group",
      "aria-labelledby": this.groupHeadingId
    })));
    this.value = props.value;
    __privateSet(this, _id47, props.id);
    __privateSet(this, _ref47, props.ref);
    this.content = content;
    this.root = content.parentMenu.root;
    useRefById({ id: __privateGet(this, _id47), ref: __privateGet(this, _ref47) });
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId2));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId2), proxy(value, null, __privateGet(this, _groupHeadingId2)));
  }
  get props() {
    return get(__privateGet(this, _props72));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _groupHeadingId2)), owner, false);
    add_owner(get(__privateGet(this, _props72)), owner, false);
  }
};
_id47 = new WeakMap();
_ref47 = new WeakMap();
_groupHeadingId2 = new WeakMap();
_props72 = new WeakMap();
var _id48, _ref48, _closeOnSelect2, _item5, _value7, _group5, _isChecked, _props73;
var MenuRadioItemState = class {
  constructor(props, item, group) {
    __privateAdd(this, _id48);
    __privateAdd(this, _ref48);
    __privateAdd(this, _closeOnSelect2);
    __privateAdd(this, _item5);
    __privateAdd(this, _value7);
    __privateAdd(this, _group5);
    __privateAdd(this, _isChecked, derived(() => strict_equals(__privateGet(this, _group5).value.current, __privateGet(this, _value7).current)));
    __publicField(this, "selectValue", () => {
      __privateGet(this, _group5).setValue(__privateGet(this, _value7).current);
    });
    __privateAdd(this, _props73, derived(() => ({
      [__privateGet(this, _group5).root.getAttr("radio-item")]: "",
      ...__privateGet(this, _item5).props,
      role: "menuitemradio",
      "aria-checked": getAriaChecked(this.isChecked, false),
      "data-state": getCheckedState(this.isChecked)
    })));
    __privateSet(this, _item5, item);
    __privateSet(this, _id48, props.id);
    __privateSet(this, _ref48, props.ref);
    __privateSet(this, _group5, group);
    __privateSet(this, _value7, props.value);
    __privateSet(this, _closeOnSelect2, props.closeOnSelect);
    useRefById({ id: __privateGet(this, _id48), ref: __privateGet(this, _ref48) });
  }
  get isChecked() {
    return get(__privateGet(this, _isChecked));
  }
  set isChecked(_) {
    throw new Error("Cannot update a derived property ('isChecked')");
  }
  get props() {
    return get(__privateGet(this, _props73));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isChecked)), owner, false);
    add_owner(get(__privateGet(this, _props73)), owner, false);
  }
};
_id48 = new WeakMap();
_ref48 = new WeakMap();
_closeOnSelect2 = new WeakMap();
_item5 = new WeakMap();
_value7 = new WeakMap();
_group5 = new WeakMap();
_isChecked = new WeakMap();
_props73 = new WeakMap();
var _id49, _ref49, _parentMenu, _disabled8, _onpointerdown11, _onpointerup6, _onkeydown17, _ariaControls, _props74;
var DropdownMenuTriggerState = class {
  constructor(props, parentMenu) {
    __privateAdd(this, _id49);
    __privateAdd(this, _ref49);
    __privateAdd(this, _parentMenu);
    __privateAdd(this, _disabled8);
    __privateAdd(this, _onpointerdown11, (e) => {
      if (__privateGet(this, _disabled8).current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      if (strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
        __privateGet(this, _parentMenu).toggleOpen();
        if (!__privateGet(this, _parentMenu).open.current) e.preventDefault();
      }
    });
    __privateAdd(this, _onpointerup6, (e) => {
      if (__privateGet(this, _disabled8).current) return;
      if (strict_equals(e.pointerType, "touch")) {
        e.preventDefault();
        __privateGet(this, _parentMenu).toggleOpen();
      }
    });
    __privateAdd(this, _onkeydown17, (e) => {
      if (__privateGet(this, _disabled8).current) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        __privateGet(this, _parentMenu).toggleOpen();
        e.preventDefault();
        return;
      }
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        __privateGet(this, _parentMenu).onOpen();
        e.preventDefault();
      }
    });
    __privateAdd(this, _ariaControls, derived(() => {
      if (__privateGet(this, _parentMenu).open.current && __privateGet(this, _parentMenu).contentId.current) return __privateGet(this, _parentMenu).contentId.current;
      return void 0;
    }));
    __privateAdd(this, _props74, derived(() => ({
      id: __privateGet(this, _id49).current,
      disabled: __privateGet(this, _disabled8).current,
      "aria-haspopup": "menu",
      "aria-expanded": getAriaExpanded(__privateGet(this, _parentMenu).open.current),
      "aria-controls": get(__privateGet(this, _ariaControls)),
      "data-disabled": getDataDisabled(__privateGet(this, _disabled8).current),
      "data-state": getDataOpenClosed(__privateGet(this, _parentMenu).open.current),
      [__privateGet(this, _parentMenu).root.getAttr("trigger")]: "",
      //
      onpointerdown: __privateGet(this, _onpointerdown11),
      onpointerup: __privateGet(this, _onpointerup6),
      onkeydown: __privateGet(this, _onkeydown17)
    })));
    __privateSet(this, _ref49, props.ref);
    __privateSet(this, _id49, props.id);
    __privateSet(this, _parentMenu, parentMenu);
    __privateSet(this, _disabled8, props.disabled);
    useRefById({
      id: __privateGet(this, _id49),
      ref: __privateGet(this, _ref49),
      onRefChange: (ref) => {
        __privateGet(this, _parentMenu).triggerNode = ref;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props74));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props74)), owner, false);
  }
};
_id49 = new WeakMap();
_ref49 = new WeakMap();
_parentMenu = new WeakMap();
_disabled8 = new WeakMap();
_onpointerdown11 = new WeakMap();
_onpointerup6 = new WeakMap();
_onkeydown17 = new WeakMap();
_ariaControls = new WeakMap();
_props74 = new WeakMap();
var _id50, _ref50, _parentMenu2, _disabled9, _point, _longPressTimer, _clearLongPressTimer, _handleOpen2, _oncontextmenu, _onpointerdown12, _onpointermove8, _onpointercancel, _onpointerup7, _props75;
var ContextMenuTriggerState = class {
  constructor(props, parentMenu) {
    __privateAdd(this, _id50);
    __privateAdd(this, _ref50);
    __privateAdd(this, _parentMenu2);
    __privateAdd(this, _disabled9);
    __privateAdd(this, _point, state(proxy({ x: 0, y: 0 })));
    __publicField(this, "virtualElement", box({
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...get(__privateGet(this, _point))
      })
    }));
    __privateAdd(this, _longPressTimer, state(null));
    __privateAdd(this, _clearLongPressTimer, () => {
      if (strict_equals(get(__privateGet(this, _longPressTimer)), null)) return;
      window.clearTimeout(get(__privateGet(this, _longPressTimer)));
    });
    __privateAdd(this, _handleOpen2, (e) => {
      set(__privateGet(this, _point), proxy({ x: e.clientX, y: e.clientY }, null, __privateGet(this, _point)));
      __privateGet(this, _parentMenu2).onOpen();
    });
    __privateAdd(this, _oncontextmenu, (e) => {
      var _a;
      if (__privateGet(this, _disabled9).current) return;
      __privateGet(this, _clearLongPressTimer).call(this);
      __privateGet(this, _handleOpen2).call(this, e);
      e.preventDefault();
      (_a = __privateGet(this, _parentMenu2).contentNode) == null ? void 0 : _a.focus();
    });
    __privateAdd(this, _onpointerdown12, (e) => {
      if (__privateGet(this, _disabled9).current || isMouseEvent(e)) return;
      __privateGet(this, _clearLongPressTimer).call(this);
      set(__privateGet(this, _longPressTimer), proxy(window.setTimeout(() => __privateGet(this, _handleOpen2).call(this, e), 700), null, __privateGet(this, _longPressTimer)));
    });
    __privateAdd(this, _onpointermove8, (e) => {
      if (__privateGet(this, _disabled9).current || isMouseEvent(e)) return;
      __privateGet(this, _clearLongPressTimer).call(this);
    });
    __privateAdd(this, _onpointercancel, (e) => {
      if (__privateGet(this, _disabled9).current || isMouseEvent(e)) return;
      __privateGet(this, _clearLongPressTimer).call(this);
    });
    __privateAdd(this, _onpointerup7, (e) => {
      if (__privateGet(this, _disabled9).current || isMouseEvent(e)) return;
      __privateGet(this, _clearLongPressTimer).call(this);
    });
    __privateAdd(this, _props75, derived(() => ({
      id: __privateGet(this, _id50).current,
      disabled: __privateGet(this, _disabled9).current,
      "data-disabled": getDataDisabled(__privateGet(this, _disabled9).current),
      "data-state": getDataOpenClosed(__privateGet(this, _parentMenu2).open.current),
      [CONTEXT_MENU_TRIGGER_ATTR]: "",
      //
      onpointerdown: __privateGet(this, _onpointerdown12),
      onpointermove: __privateGet(this, _onpointermove8),
      onpointercancel: __privateGet(this, _onpointercancel),
      onpointerup: __privateGet(this, _onpointerup7),
      oncontextmenu: __privateGet(this, _oncontextmenu)
    })));
    __privateSet(this, _parentMenu2, parentMenu);
    __privateSet(this, _disabled9, props.disabled);
    __privateSet(this, _id50, props.id);
    __privateSet(this, _ref50, props.ref);
    useRefById({
      id: __privateGet(this, _id50),
      ref: __privateGet(this, _ref50),
      onRefChange: (node) => {
        __privateGet(this, _parentMenu2).triggerNode = node;
      },
      deps: () => __privateGet(this, _parentMenu2).open.current
    });
    user_effect(() => {
      get(__privateGet(this, _point));
      this.virtualElement.current = {
        getBoundingClientRect: () => DOMRect.fromRect({
          width: 0,
          height: 0,
          ...get(__privateGet(this, _point))
        })
      };
    });
    user_effect(() => {
      if (__privateGet(this, _disabled9).current) {
        __privateGet(this, _clearLongPressTimer).call(this);
      }
    });
    user_effect(() => {
      return () => {
        __privateGet(this, _clearLongPressTimer).call(this);
      };
    });
  }
  get props() {
    return get(__privateGet(this, _props75));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props75)), owner, false);
  }
};
_id50 = new WeakMap();
_ref50 = new WeakMap();
_parentMenu2 = new WeakMap();
_disabled9 = new WeakMap();
_point = new WeakMap();
_longPressTimer = new WeakMap();
_clearLongPressTimer = new WeakMap();
_handleOpen2 = new WeakMap();
_oncontextmenu = new WeakMap();
_onpointerdown12 = new WeakMap();
_onpointermove8 = new WeakMap();
_onpointercancel = new WeakMap();
_onpointerup7 = new WeakMap();
_props75 = new WeakMap();
function useMenuRoot(props) {
  return setMenuRootContext(new MenuRootState(props));
}
function useMenuMenu(root17, props) {
  const menu = new MenuMenuState(props, root17);
  return setMenuMenuContext(menu);
}
function useMenuSubmenu(props) {
  const menu = getMenuMenuContext();
  return setMenuMenuContext(new MenuMenuState(props, menu.root, menu));
}
function useMenuSubTrigger(props) {
  const content = getMenuContentContext();
  const item = new MenuItemSharedState(props, content);
  const submenu = getMenuMenuContext();
  return new MenuSubTriggerState(item, content, submenu);
}
function useMenuDropdownTrigger(props) {
  const menu = getMenuMenuContext();
  return new DropdownMenuTriggerState(props, menu);
}
function useMenuContextTrigger(props) {
  const menu = getMenuMenuContext();
  return new ContextMenuTriggerState(props, menu);
}
function useMenuContent(props) {
  const menu = getMenuMenuContext();
  return setMenuContentContext(new MenuContentState(props, menu));
}
function useMenuItem(props) {
  const content = getMenuContentContext();
  const item = new MenuItemSharedState(props, content);
  return new MenuItemState(props, item);
}
function useMenuCheckboxItem(props) {
  const content = getMenuContentContext();
  const item = new MenuItemState(props, new MenuItemSharedState(props, content));
  return new MenuCheckboxItemState(props, item);
}
function useMenuRadioGroup(props) {
  const content = getMenuContentContext();
  const radioGroup = new MenuRadioGroupState(props, content);
  return setMenuGroupContext(setMenuRadioGroupContext(radioGroup));
}
function useMenuRadioItem(props) {
  const radioGroup = getMenuRadioGroupContext();
  const sharedItem = new MenuItemSharedState(props, radioGroup.content);
  const item = new MenuItemState(props, sharedItem);
  return new MenuRadioItemState(props, item, radioGroup);
}
function useMenuGroup(props) {
  const root17 = getMenuRootContext();
  return setMenuGroupContext(new MenuGroupState(props, root17));
}
function useMenuGroupHeading(props) {
  const group = getMenuGroupContext();
  return new MenuGroupHeadingState(props, group);
}
function useMenuSeparator(props) {
  const root17 = getMenuRootContext();
  return new MenuSeparatorState(props, root17);
}
function useMenuArrow() {
  const root17 = getMenuRootContext();
  return new MenuArrowState(root17);
}

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte
mark_module_start();
Context_menu[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte";
function Context_menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu);
  validate_prop_bindings($$props, ["open"], [], Context_menu);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop2), controlledOpen = prop($$props, "controlledOpen", 3, false);
  const root17 = useMenuRoot({
    variant: box.with(() => "context-menu"),
    dir: box.with(() => dir()),
    onClose: () => {
      var _a;
      if (controlledOpen()) {
        onOpenChange()(false);
      } else {
        open(false);
        (_a = onOpenChange()) == null ? void 0 : _a(false);
      }
    }
  });
  useMenuMenu(root17, {
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    })
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Context_menu, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu = hmr(Context_menu, () => Context_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu[HMR].source;
    set(Context_menu[HMR].source, module.default[HMR].original);
  });
}
var context_menu_default = Context_menu;
mark_module_end(Context_menu);

// node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte
mark_module_start();
Menu_sub[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte";
function Menu_sub($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_sub);
  validate_prop_bindings($$props, ["open"], [], Menu_sub);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), controlledOpen = prop($$props, "controlledOpen", 3, false);
  useMenuSubmenu({
    open: box.with(() => open(), (v) => {
      var _a;
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        (_a = onOpenChange()) == null ? void 0 : _a(v);
      }
    })
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Menu_sub, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub = hmr(Menu_sub, () => Menu_sub[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub[HMR].source;
    set(Menu_sub[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_default = Menu_sub;
mark_module_end(Menu_sub);

// node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte
mark_module_start();
Menu_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte";
var root_246 = add_locations(template(`<div><!></div>`), Menu_item[FILENAME], [[36, 1]]);
function Menu_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_item);
  validate_prop_bindings($$props, ["ref"], [], Menu_item);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop2), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "disabled",
      "onSelect",
      "closeOnSelect"
    ],
    "restProps"
  );
  const itemState = useMenuItem({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    ref: box.with(() => ref(), (v) => ref(v)),
    closeOnSelect: box.with(() => closeOnSelect())
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_246();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_item = hmr(Menu_item, () => Menu_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_item[HMR].source;
    set(Menu_item[HMR].source, module.default[HMR].original);
  });
}
var menu_item_default = Menu_item;
mark_module_end(Menu_item);

// node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte
mark_module_start();
Menu_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte";
var root_247 = add_locations(template(`<div><!></div>`), Menu_group[FILENAME], [[28, 1]]);
function Menu_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_group);
  validate_prop_bindings($$props, ["ref"], [], Menu_group);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const groupState = useMenuGroup({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_247();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_group = hmr(Menu_group, () => Menu_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_group[HMR].source;
    set(Menu_group[HMR].source, module.default[HMR].original);
  });
}
var menu_group_default = Menu_group;
mark_module_end(Menu_group);

// node_modules/bits-ui/dist/bits/menu/components/menu-group-heading.svelte
mark_module_start();
Menu_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-group-heading.svelte";
var root_248 = add_locations(template(`<div><!></div>`), Menu_group_heading[FILENAME], [[28, 1]]);
function Menu_group_heading($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_group_heading);
  validate_prop_bindings($$props, ["ref"], [], Menu_group_heading);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const groupHeadingState = useMenuGroupHeading({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, groupHeadingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_248();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_group_heading = hmr(Menu_group_heading, () => Menu_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_group_heading[HMR].source;
    set(Menu_group_heading[HMR].source, module.default[HMR].original);
  });
}
var menu_group_heading_default = Menu_group_heading;
mark_module_end(Menu_group_heading);

// node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte
mark_module_start();
Menu_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte";
function Menu_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_arrow);
  validate_prop_bindings($$props, ["ref"], [], Menu_arrow);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  const arrowState = useMenuArrow();
  const mergedProps = derived(() => mergeProps(restProps, arrowState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, floating_layer_arrow_default);
    floating_layer_arrow_default(node, spread_props(
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      },
      () => get(mergedProps)
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_arrow = hmr(Menu_arrow, () => Menu_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_arrow[HMR].source;
    set(Menu_arrow[HMR].source, module.default[HMR].original);
  });
}
var menu_arrow_default = Menu_arrow;
mark_module_end(Menu_arrow);

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte
mark_module_start();
Context_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte";
var root_47 = add_locations(template(`<div><!></div>`), Context_menu_content[FILENAME], [[88, 4]]);
var root_249 = add_locations(template(`<!> <!>`, 1), Context_menu_content[FILENAME], []);
var root_93 = add_locations(template(`<div><!></div>`), Context_menu_content[FILENAME], [[117, 4]]);
var root_7 = add_locations(template(`<!> <!>`, 1), Context_menu_content[FILENAME], []);
function Context_menu_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_content);
  validate_prop_bindings($$props, ["ref"], [], Context_menu_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "preventScroll",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const contentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && strict_equals(e.button, 2)) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = strict_equals(target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`), contentState.parentMenu.triggerNode, false);
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Context_menu_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_249();
          const finalProps = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("context-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_47();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          side: "right",
          sideOffset: 2,
          align: "start",
          get enabled() {
            return contentState.parentMenu.open.current;
          },
          get preventScroll() {
            return preventScroll();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          isValidEvent: isValidEvent2,
          trapFocus: true,
          get loop() {
            return loop();
          },
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Context_menu_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_7();
              const finalProps = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("context-menu")
              }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_93();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              side: "right",
              sideOffset: 2,
              align: "start",
              get present() {
                return contentState.parentMenu.open.current;
              },
              get preventScroll() {
                return preventScroll();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              isValidEvent: isValidEvent2,
              trapFocus: true,
              get loop() {
                return loop();
              },
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_content = hmr(Context_menu_content, () => Context_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_content[HMR].source;
    set(Context_menu_content[HMR].source, module.default[HMR].original);
  });
}
var context_menu_content_default = Context_menu_content;
mark_module_end(Context_menu_content);

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content-static.svelte
mark_module_start();
Context_menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content-static.svelte";
var root_48 = add_locations(template(`<div><!></div>`), Context_menu_content_static[FILENAME], [[90, 4]]);
var root_250 = add_locations(template(`<!> <!>`, 1), Context_menu_content_static[FILENAME], []);
var root_94 = add_locations(template(`<div><!></div>`), Context_menu_content_static[FILENAME], [[121, 4]]);
var root_72 = add_locations(template(`<!> <!>`, 1), Context_menu_content_static[FILENAME], []);
function Context_menu_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_content_static);
  validate_prop_bindings($$props, ["ref"], [], Context_menu_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "preventScroll",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const contentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && strict_equals(e.button, 2)) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = strict_equals(target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`), contentState.parentMenu.triggerNode, false);
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Context_menu_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_250();
          const finalProps = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("context-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_48();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          isStatic: true,
          side: "right",
          sideOffset: 2,
          align: "start",
          get enabled() {
            return contentState.parentMenu.open.current;
          },
          get preventScroll() {
            return preventScroll();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          isValidEvent: isValidEvent2,
          trapFocus: true,
          get loop() {
            return loop();
          },
          get forceMount() {
            return forceMount();
          },
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Context_menu_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_72();
              const finalProps = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("context-menu")
              }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_94();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              isStatic: true,
              side: "right",
              sideOffset: 2,
              align: "start",
              get present() {
                return contentState.parentMenu.open.current;
              },
              get preventScroll() {
                return preventScroll();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              isValidEvent: isValidEvent2,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_content_static = hmr(Context_menu_content_static, () => Context_menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_content_static[HMR].source;
    set(Context_menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var context_menu_content_static_default = Context_menu_content_static;
mark_module_end(Context_menu_content_static);

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte
mark_module_start();
Context_menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte";
var root_310 = add_locations(template(`<div><!></div>`), Context_menu_trigger[FILENAME], [[35, 2]]);
function Context_menu_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_trigger);
  validate_prop_bindings($$props, ["ref"], [], Context_menu_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = useMenuContextTrigger({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props, { style: { pointerEvents: "auto" } }));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      get virtualEl() {
        return triggerState.virtualElement;
      },
      children: wrap_snippet(Context_menu_trigger, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        if_block(
          node_1,
          () => $$props.child,
          ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          },
          ($$anchor4) => {
            var div = root_310();
            let attributes;
            var node_3 = child(div);
            snippet(node_3, () => $$props.children ?? noop);
            reset(div);
            template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
            append($$anchor4, div);
          }
        );
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_trigger = hmr(Context_menu_trigger, () => Context_menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_trigger[HMR].source;
    set(Context_menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var context_menu_trigger_default = Context_menu_trigger;
mark_module_end(Context_menu_trigger);

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte
mark_module_start();
Menu_radio_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte";
var root_251 = add_locations(template(`<div><!></div>`), Menu_radio_item[FILENAME], [[44, 1]]);
function Menu_radio_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_radio_item);
  validate_prop_bindings($$props, ["ref"], [], Menu_radio_item);
  let ref = prop($$props, "ref", 15, null), onSelect = prop($$props, "onSelect", 3, noop2), id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "value",
      "onSelect",
      "id",
      "disabled",
      "closeOnSelect"
    ],
    "restProps"
  );
  const radioItemState = useMenuRadioItem({
    value: box.with(() => $$props.value),
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => handleSelect),
    ref: box.with(() => ref(), (v) => ref(v)),
    closeOnSelect: box.with(() => closeOnSelect())
  });
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    radioItemState.selectValue();
  }
  const mergedProps = derived(() => mergeProps(restProps, radioItemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        checked: radioItemState.isChecked
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_251();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ checked: radioItemState.isChecked }));
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_radio_item = hmr(Menu_radio_item, () => Menu_radio_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_radio_item[HMR].source;
    set(Menu_radio_item[HMR].source, module.default[HMR].original);
  });
}
var menu_radio_item_default = Menu_radio_item;
mark_module_end(Menu_radio_item);

// node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte
mark_module_start();
Menu_separator[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte";
var root_252 = add_locations(template(`<div><!></div>`), Menu_separator[FILENAME], [[29, 1]]);
function Menu_separator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_separator);
  validate_prop_bindings($$props, ["ref"], [], Menu_separator);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const separatorState = useMenuSeparator({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, separatorState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_252();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_separator = hmr(Menu_separator, () => Menu_separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_separator[HMR].source;
    set(Menu_separator[HMR].source, module.default[HMR].original);
  });
}
var menu_separator_default = Menu_separator;
mark_module_end(Menu_separator);

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte
mark_module_start();
Menu_radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte";
var root_253 = add_locations(template(`<div><!></div>`), Menu_radio_group[FILENAME], [[44, 1]]);
function Menu_radio_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_radio_group);
  validate_prop_bindings($$props, ["ref", "value"], [], Menu_radio_group);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop2), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "onValueChange",
      "controlledValue"
    ],
    "restProps"
  );
  const radioGroupState = useMenuRadioGroup({
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id())
  });
  const mergedProps = derived(() => mergeProps(restProps, radioGroupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_253();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_radio_group = hmr(Menu_radio_group, () => Menu_radio_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_radio_group[HMR].source;
    set(Menu_radio_group[HMR].source, module.default[HMR].original);
  });
}
var menu_radio_group_default = Menu_radio_group;
mark_module_end(Menu_radio_group);

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte
mark_module_start();
Menu_sub_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte";
var root_49 = add_locations(template(`<div><!></div>`), Menu_sub_content[FILENAME], [[131, 4]]);
var root_254 = add_locations(template(`<!> <!>`, 1), Menu_sub_content[FILENAME], []);
var root_95 = add_locations(template(`<div><!></div>`), Menu_sub_content[FILENAME], [[160, 4]]);
var root_73 = add_locations(template(`<!> <!>`, 1), Menu_sub_content[FILENAME], []);
function Menu_sub_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_sub_content);
  validate_prop_bindings($$props, ["ref"], [], Menu_sub_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop2), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop2), onFocusOutside = prop($$props, "onFocusOutside", 3, noop2), side = prop($$props, "side", 3, "right"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "loop",
      "onInteractOutside",
      "forceMount",
      "onEscapeKeydown",
      "interactOutsideBehavior",
      "escapeKeydownBehavior",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "onFocusOutside",
      "side"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const subContentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode == null ? void 0 : triggerNode.focus();
      e.preventDefault();
    }
  }
  const dataAttr = derived(() => subContentState.parentMenu.root.getAttr("sub-content"));
  const mergedProps = derived(() => mergeProps(restProps, subContentState.props, {
    side: side(),
    onkeydown,
    [get(dataAttr)]: ""
  }));
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    afterTick(() => {
      e.preventDefault();
      if (subContentState.parentMenu.root.isUsingKeyboard.current) {
        const subContentEl = subContentState.parentMenu.contentNode;
        subContentEl == null ? void 0 : subContentEl.focus();
      }
    });
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    var _a;
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement(e.target)) return;
    if (strict_equals(e.target.id, (_a = subContentState.parentMenu.triggerNode) == null ? void 0 : _a.id, false)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_sub_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_254();
          const finalProps = derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...subContentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_49();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get escapeKeydownBehavior() {
            return escapeKeydownBehavior();
          },
          onCloseAutoFocus: handleCloseAutoFocus,
          onOpenAutoFocus: handleOpenAutoFocus,
          get enabled() {
            return subContentState.parentMenu.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onFocusOutside: handleOnFocusOutside,
          preventScroll: false,
          get loop() {
            return loop();
          },
          trapFocus: false,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_sub_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_73();
              const finalProps = derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...subContentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_95();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              get interactOutsideBehavior() {
                return interactOutsideBehavior();
              },
              get escapeKeydownBehavior() {
                return escapeKeydownBehavior();
              },
              onCloseAutoFocus: handleCloseAutoFocus,
              onOpenAutoFocus: handleOpenAutoFocus,
              get present() {
                return subContentState.parentMenu.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onFocusOutside: handleOnFocusOutside,
              preventScroll: false,
              get loop() {
                return loop();
              },
              trapFocus: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_content = hmr(Menu_sub_content, () => Menu_sub_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_content[HMR].source;
    set(Menu_sub_content[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_content_default = Menu_sub_content;
mark_module_end(Menu_sub_content);

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content-static.svelte
mark_module_start();
Menu_sub_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-content-static.svelte";
var root_410 = add_locations(template(`<div><!></div>`), Menu_sub_content_static[FILENAME], [[132, 4]]);
var root_255 = add_locations(template(`<!> <!>`, 1), Menu_sub_content_static[FILENAME], []);
var root_96 = add_locations(template(`<div><!></div>`), Menu_sub_content_static[FILENAME], [[162, 4]]);
var root_74 = add_locations(template(`<!> <!>`, 1), Menu_sub_content_static[FILENAME], []);
function Menu_sub_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_sub_content_static);
  validate_prop_bindings($$props, ["ref"], [], Menu_sub_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop2), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop2), onFocusOutside = prop($$props, "onFocusOutside", 3, noop2), side = prop($$props, "side", 3, "right"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "loop",
      "onInteractOutside",
      "forceMount",
      "onEscapeKeydown",
      "interactOutsideBehavior",
      "escapeKeydownBehavior",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "onFocusOutside",
      "side"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const subContentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode == null ? void 0 : triggerNode.focus();
      e.preventDefault();
    }
  }
  const dataAttr = derived(() => subContentState.parentMenu.root.getAttr("sub-content"));
  const mergedProps = derived(() => mergeProps(restProps, subContentState.props, {
    side: side(),
    onkeydown,
    [get(dataAttr)]: ""
  }));
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    afterTick(() => {
      e.preventDefault();
      if (subContentState.parentMenu.root.isUsingKeyboard.current) {
        const subContentEl = subContentState.parentMenu.contentNode;
        subContentEl == null ? void 0 : subContentEl.focus();
      }
    });
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    var _a;
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement(e.target)) return;
    if (strict_equals(e.target.id, (_a = subContentState.parentMenu.triggerNode) == null ? void 0 : _a.id, false)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_sub_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_255();
          const finalProps = derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...subContentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_410();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get escapeKeydownBehavior() {
            return escapeKeydownBehavior();
          },
          onCloseAutoFocus: handleCloseAutoFocus,
          onOpenAutoFocus: handleOpenAutoFocus,
          get enabled() {
            return subContentState.parentMenu.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onFocusOutside: handleOnFocusOutside,
          preventScroll: false,
          get loop() {
            return loop();
          },
          trapFocus: false,
          isStatic: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_sub_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_74();
              const finalProps = derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...subContentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_96();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              get interactOutsideBehavior() {
                return interactOutsideBehavior();
              },
              get escapeKeydownBehavior() {
                return escapeKeydownBehavior();
              },
              onCloseAutoFocus: handleCloseAutoFocus,
              onOpenAutoFocus: handleOpenAutoFocus,
              get present() {
                return subContentState.parentMenu.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onFocusOutside: handleOnFocusOutside,
              preventScroll: false,
              get loop() {
                return loop();
              },
              trapFocus: false,
              isStatic: true,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_content_static = hmr(Menu_sub_content_static, () => Menu_sub_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_content_static[HMR].source;
    set(Menu_sub_content_static[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_content_static_default = Menu_sub_content_static;
mark_module_end(Menu_sub_content_static);

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte
mark_module_start();
Menu_sub_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte";
var root_311 = add_locations(template(`<div><!></div>`), Menu_sub_trigger[FILENAME], [[32, 2]]);
function Menu_sub_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_sub_trigger);
  validate_prop_bindings($$props, ["ref"], [], Menu_sub_trigger);
  let id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const subTriggerState = useMenuSubTrigger({
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, subTriggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    children: wrap_snippet(Menu_sub_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var div = root_311();
          let attributes;
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
          append($$anchor3, div);
        }
      );
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_trigger = hmr(Menu_sub_trigger, () => Menu_sub_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_trigger[HMR].source;
    set(Menu_sub_trigger[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_trigger_default = Menu_sub_trigger;
mark_module_end(Menu_sub_trigger);

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte
mark_module_start();
Menu_checkbox_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte";
var root_256 = add_locations(template(`<div><!></div>`), Menu_checkbox_item[FILENAME], [[70, 1]]);
function Menu_checkbox_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_checkbox_item);
  validate_prop_bindings($$props, ["ref", "checked", "indeterminate"], [], Menu_checkbox_item);
  let ref = prop($$props, "ref", 15, null), checked = prop($$props, "checked", 15, false), id = prop($$props, "id", 19, useId), onCheckedChange = prop($$props, "onCheckedChange", 3, noop2), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop2), controlledChecked = prop($$props, "controlledChecked", 3, false), closeOnSelect = prop($$props, "closeOnSelect", 3, true), indeterminate = prop($$props, "indeterminate", 15, false), controlledIndeterminate = prop($$props, "controlledIndeterminate", 3, false), onIndeterminateChange = prop($$props, "onIndeterminateChange", 3, noop2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "checked",
      "id",
      "onCheckedChange",
      "disabled",
      "onSelect",
      "controlledChecked",
      "closeOnSelect",
      "indeterminate",
      "controlledIndeterminate",
      "onIndeterminateChange"
    ],
    "restProps"
  );
  const checkboxItemState = useMenuCheckboxItem({
    checked: box.with(() => checked(), (v) => {
      if (controlledChecked()) {
        onCheckedChange()(v);
      } else {
        checked(v);
        onCheckedChange()(v);
      }
    }),
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => handleSelect),
    ref: box.with(() => ref(), (v) => ref(v)),
    closeOnSelect: box.with(() => closeOnSelect()),
    indeterminate: box.with(() => indeterminate(), (v) => {
      if (controlledIndeterminate()) {
        onIndeterminateChange()(v);
      } else {
        indeterminate(v);
        onIndeterminateChange()(v);
      }
    })
  });
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    checkboxItemState.toggleChecked();
  }
  const mergedProps = derived(() => mergeProps(restProps, checkboxItemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...checkboxItemState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_256();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => checkboxItemState.snippetProps);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_checkbox_item = hmr(Menu_checkbox_item, () => Menu_checkbox_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_checkbox_item[HMR].source;
    set(Menu_checkbox_item[HMR].source, module.default[HMR].original);
  });
}
var menu_checkbox_item_default = Menu_checkbox_item;
mark_module_end(Menu_checkbox_item);

// node_modules/bits-ui/dist/bits/date-field/exports.js
var exports_exports12 = {};
__export(exports_exports12, {
  Input: () => date_field_input_default,
  Label: () => date_field_label_default,
  Root: () => date_field_default,
  Segment: () => date_field_segment_default
});

// node_modules/bits-ui/dist/internal/date-time/placeholders.js
var supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
];
var placeholderFields = ["year", "month", "day"];
var placeholders = {
  ach: { year: "mwaka", month: "dwe", day: "nino" },
  af: { year: "jjjj", month: "mm", day: "dd" },
  am: { year: "", month: "", day: "" },
  an: { year: "aaaa", month: "mm", day: "dd" },
  ar: { year: "", month: "", day: "" },
  ast: { year: "aaaa", month: "mm", day: "dd" },
  az: { year: "iiii", month: "aa", day: "gg" },
  be: { year: "", month: "", day: "" },
  bg: { year: "", month: "", day: "" },
  bn: { year: "yyyy", month: "", day: "dd" },
  br: { year: "bbbb", month: "mm", day: "dd" },
  bs: { year: "gggg", month: "mm", day: "dd" },
  ca: { year: "aaaa", month: "mm", day: "dd" },
  cak: { year: "jjjj", month: "ii", day: "q'q'" },
  ckb: { year: "", month: "", day: "" },
  cs: { year: "rrrr", month: "mm", day: "dd" },
  cy: { year: "bbbb", month: "mm", day: "dd" },
  da: { year: "", month: "mm", day: "dd" },
  de: { year: "jjjj", month: "mm", day: "tt" },
  dsb: { year: "llll", month: "mm", day: "" },
  el: { year: "", month: "", day: "" },
  en: { year: "yyyy", month: "mm", day: "dd" },
  eo: { year: "jjjj", month: "mm", day: "tt" },
  es: { year: "aaaa", month: "mm", day: "dd" },
  et: { year: "aaaa", month: "kk", day: "pp" },
  eu: { year: "uuuu", month: "hh", day: "ee" },
  fa: { year: "", month: "", day: "" },
  ff: { year: "hhhh", month: "ll", day: "" },
  fi: { year: "vvvv", month: "kk", day: "pp" },
  fr: { year: "aaaa", month: "mm", day: "jj" },
  fy: { year: "jjjj", month: "mm", day: "dd" },
  ga: { year: "bbbb", month: "mm", day: "ll" },
  gd: { year: "bbbb", month: "mm", day: "ll" },
  gl: { year: "aaaa", month: "mm", day: "dd" },
  he: { year: "", month: "", day: "" },
  hr: { year: "gggg", month: "mm", day: "dd" },
  hsb: { year: "llll", month: "mm", day: "dd" },
  hu: { year: "", month: "hh", day: "nn" },
  ia: { year: "aaaa", month: "mm", day: "dd" },
  id: { year: "tttt", month: "bb", day: "hh" },
  it: { year: "aaaa", month: "mm", day: "gg" },
  ja: { year: "  ", month: "", day: "" },
  ka: { year: "", month: "", day: "" },
  kk: { year: "", month: "", day: "" },
  kn: { year: "", month: "", day: "" },
  ko: { year: "", month: "", day: "" },
  lb: { year: "jjjj", month: "mm", day: "dd" },
  lo: { year: "", month: "", day: "" },
  lt: { year: "mmmm", month: "mm", day: "dd" },
  lv: { year: "gggg", month: "mm", day: "dd" },
  meh: { year: "aaaa", month: "mm", day: "dd" },
  ml: { year: "", month: "", day: "" },
  ms: { year: "tttt", month: "mm", day: "hh" },
  nl: { year: "jjjj", month: "mm", day: "dd" },
  nn: { year: "", month: "mm", day: "dd" },
  no: { year: "", month: "mm", day: "dd" },
  oc: { year: "aaaa", month: "mm", day: "jj" },
  pl: { year: "rrrr", month: "mm", day: "dd" },
  pt: { year: "aaaa", month: "mm", day: "dd" },
  rm: { year: "oooo", month: "mm", day: "dd" },
  ro: { year: "aaaa", month: "ll", day: "zz" },
  ru: { year: "", month: "", day: "" },
  sc: { year: "aaaa", month: "mm", day: "dd" },
  scn: { year: "aaaa", month: "mm", day: "jj" },
  sk: { year: "rrrr", month: "mm", day: "dd" },
  sl: { year: "llll", month: "mm", day: "dd" },
  sr: { year: "", month: "", day: "" },
  sv: { year: "", month: "mm", day: "dd" },
  szl: { year: "rrrr", month: "mm", day: "dd" },
  tg: { year: "", month: "", day: "" },
  th: { year: "", month: "", day: "" },
  tr: { year: "yyyy", month: "aa", day: "gg" },
  uk: { year: "", month: "", day: "" },
  "zh-CN": { year: "", month: "", day: "" },
  "zh-TW": { year: "", month: "", day: "" }
};
function getPlaceholderObj(locale) {
  if (!isSupportedLocale(locale)) {
    const localeLanguage = getLocaleLanguage(locale);
    if (!isSupportedLocale(localeLanguage)) {
      return placeholders.en;
    } else {
      return placeholders[localeLanguage];
    }
  } else {
    return placeholders[locale];
  }
}
function getPlaceholder(field, value, locale) {
  if (isPlaceholderField(field))
    return getPlaceholderObj(locale)[field];
  if (isDefaultField(field))
    return value;
  if (isTimeField(field))
    return "";
  return "";
}
function isSupportedLocale(locale) {
  return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
  return placeholderFields.includes(field);
}
function isTimeField(field) {
  return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
  return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
  if (Intl.Locale) {
    return new Intl.Locale(locale).language;
  }
  return locale.split("-")[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/parts.js
var DATE_SEGMENT_PARTS = ["day", "month", "year"];
var TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS];
var ALL_SEGMENT_PARTS = [
  ...EDITABLE_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter((part) => part !== "literal");

// node_modules/bits-ui/dist/internal/date-time/field/segments.js
function handleSegmentNavigation(e, fieldNode) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement(currentTarget))
    return;
  const { prev: prev2, next: next3 } = getPrevNextSegments(currentTarget, fieldNode);
  if (e.key === kbd_constants_exports.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd_constants_exports.ARROW_RIGHT) {
    if (!next3)
      return;
    next3.focus();
  }
}
function getNextSegment(node, segments) {
  const index2 = segments.indexOf(node);
  if (index2 === segments.length - 1 || index2 === -1)
    return null;
  const nextIndex = index2 + 1;
  const nextSegment = segments[nextIndex];
  return nextSegment;
}
function getPrevSegment(node, segments) {
  const index2 = segments.indexOf(node);
  if (index2 === 0 || index2 === -1)
    return null;
  const prevIndex = index2 - 1;
  const prevSegment = segments[prevIndex];
  return prevSegment;
}
function getPrevNextSegments(startingNode, fieldNode) {
  const segments = getSegments(fieldNode);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(startingNode, segments),
    prev: getPrevSegment(startingNode, segments)
  };
}
function moveToNextSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement(node))
    return;
  const { next: next3 } = getPrevNextSegments(node, fieldNode);
  if (!next3)
    return;
  next3.focus();
}
function moveToPrevSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement(node))
    return;
  const { prev: prev2 } = getPrevNextSegments(node, fieldNode);
  if (!prev2)
    return;
  prev2.focus();
}
function isSegmentNavigationKey(key) {
  if (key === kbd_constants_exports.ARROW_RIGHT || key === kbd_constants_exports.ARROW_LEFT)
    return true;
  return false;
}
function getSegments(fieldNode) {
  if (!fieldNode)
    return [];
  const segments = Array.from(fieldNode.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (!isAnySegmentPart(segment) || segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getFirstSegment(fieldNode) {
  return getSegments(fieldNode)[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/helpers.js
function initializeSegmentValues(granularity) {
  const calendarDateTimeGranularities = ["hour", "minute", "second"];
  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") {
      return [part, "AM"];
    }
    return [part, null];
  }).filter(([key]) => {
    if (key === "literal" || key === null)
      return false;
    if (granularity === "day") {
      return !calendarDateTimeGranularities.includes(key);
    } else {
      return true;
    }
  });
  return Object.fromEntries(initialParts);
}
function createContentObj(props) {
  const { segmentValues, formatter, locale, dateRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isSegmentPart(part))
      return obj;
    if ("hour" in segmentValues && part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    if ("hour" in segmentValues) {
      const value = segmentValues[part];
      const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
      const intValue = value !== null ? Number.parseInt(value) : null;
      if (value === "0" && part !== "year") {
        return "0";
      } else if (!isNull(value) && !isNull(intValue)) {
        const formatted = formatter.part(dateRef.set({ [part]: value }), part, {
          hourCycle: props.hourCycle === 24 ? "h23" : void 0
        });
        if (part === "hour" && "dayPeriod" in segmentValues && props.hourCycle !== 24) {
          if (intValue > 12) {
            const hour = intValue - 12;
            if (hour === 0) {
              return "12";
            } else if (hour < 10) {
              return `0${hour}`;
            } else {
              return `${hour}`;
            }
          }
          if (intValue === 0) {
            return "12";
          }
          if (intValue < 10) {
            return `0${intValue}`;
          }
          return `${intValue}`;
        }
        if (part === "year") {
          return `${value}`;
        }
        if (leadingZero && formatted.length === 1) {
          return `0${formatted}`;
        }
        return formatted;
      } else {
        return getPlaceholder(part, "", locale);
      }
    } else {
      if (isDateSegmentPart(part)) {
        const value = segmentValues[part];
        const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
        if (value === "0") {
          return "0";
        } else if (!isNull(value)) {
          const formatted = formatter.part(dateRef.set({ [part]: value }), part);
          if (part === "year") {
            return `${value}`;
          }
          if (leadingZero && formatted.length === 1) {
            return `0${formatted}`;
          }
          return formatted;
        } else {
          return getPlaceholder(part, "", locale);
        }
      }
      return "";
    }
  }
  return content;
}
function createContentArr(props) {
  const { granularity, dateRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(dateRef, getOptsByGranularity(granularity, hourCycle));
  const segmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "dayPeriod", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(dateRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return segmentContentArr;
}
function createContent(props) {
  const contentObj = createContentObj(props);
  const contentArr = createContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity(granularity, hourCycle) {
  const opts = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "day") {
    delete opts.second;
    delete opts.hour;
    delete opts.minute;
    delete opts.timeZoneName;
  }
  if (granularity === "hour") {
    delete opts.minute;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initSegmentStates() {
  return EDITABLE_SEGMENT_PARTS.reduce((acc, key) => {
    acc[key] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      updating: null
    };
    return acc;
  }, {});
}
function isDateSegmentPart(part) {
  return DATE_SEGMENT_PARTS.includes(part);
}
function isSegmentPart(part) {
  return EDITABLE_SEGMENT_PARTS.includes(part);
}
function isAnySegmentPart(part) {
  return ALL_SEGMENT_PARTS.includes(part);
}
function getUsedSegments(fieldNode) {
  if (!isBrowser || !fieldNode)
    return [];
  const usedSegments = getSegments(fieldNode).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getValueFromSegments(props) {
  const { segmentObj, fieldNode, dateRef } = props;
  const usedSegments = getUsedSegments(fieldNode);
  let date = dateRef;
  for (const part of usedSegments) {
    if ("hour" in segmentObj) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    } else if (isDateSegmentPart(part)) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    }
  }
  return date;
}
function areAllSegmentsFilled(segmentValues, fieldNode) {
  const usedSegments = getUsedSegments(fieldNode);
  for (const part of usedSegments) {
    if ("hour" in segmentValues) {
      if (segmentValues[part] === null) {
        return false;
      }
    } else if (isDateSegmentPart(part)) {
      if (segmentValues[part] === null) {
        return false;
      }
    }
  }
  return true;
}
function isDateAndTimeSegmentObj(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return Object.entries(obj).every(([key, value]) => {
    const validKey = TIME_SEGMENT_PARTS.includes(key) || DATE_SEGMENT_PARTS.includes(key);
    const validValue = key === "dayPeriod" ? value === "AM" || value === "PM" || value === null : typeof value === "string" || typeof value === "number" || value === null;
    return validKey && validValue;
  });
}
function inferGranularity(value, granularity) {
  if (granularity)
    return granularity;
  if (hasTime(value))
    return "minute";
  return "day";
}
function isAcceptableSegmentKey(key) {
  const acceptableSegmentKeys = [
    kbd_constants_exports.ENTER,
    kbd_constants_exports.ARROW_UP,
    kbd_constants_exports.ARROW_DOWN,
    kbd_constants_exports.ARROW_LEFT,
    kbd_constants_exports.ARROW_RIGHT,
    kbd_constants_exports.BACKSPACE,
    kbd_constants_exports.SPACE
  ];
  if (acceptableSegmentKeys.includes(key))
    return true;
  if (isNumberString(key))
    return true;
  return false;
}
function isFirstSegment(id, fieldNode) {
  if (!isBrowser)
    return false;
  const segments = getSegments(fieldNode);
  return segments.length ? segments[0].id === id : false;
}
function setDescription(id, formatter, value) {
  if (!isBrowser)
    return;
  const valueString = formatter.selectedDate(value);
  const el = document.getElementById(id);
  if (!el) {
    const div = document.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = id;
    div.innerText = `Selected Date: ${valueString}`;
    document.body.appendChild(div);
  } else {
    el.innerText = `Selected Date: ${valueString}`;
  }
}
function removeDescriptionElement(id) {
  if (!isBrowser)
    return;
  const el = document.getElementById(id);
  if (!el)
    return;
  document.body.removeChild(el);
}

// node_modules/bits-ui/dist/bits/date-field/date-field.svelte.js
var DATE_FIELD_INPUT_ATTR = "data-date-field-input";
var DATE_FIELD_LABEL_ATTR = "data-date-field-label";
var _segmentValues, _readonlySegmentsSet, _fieldNode, _labelNode3, _descriptionNode2, _validationNode, _dayPeriodNode, _name, _validationStatus, _isInvalid2, _inferredGranularity, _allSegmentContent, _segmentContents;
var DateFieldRootState = class {
  constructor(props, rangeRoot) {
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "validate");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "readonly");
    __publicField(this, "granularity");
    __publicField(this, "readonlySegments");
    __publicField(this, "hourCycle");
    __publicField(this, "locale");
    __publicField(this, "hideTimeZone");
    __publicField(this, "required");
    __publicField(this, "onInvalid");
    __publicField(this, "errorMessageId");
    __publicField(this, "isInvalidProp");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __publicField(this, "initialSegments");
    __privateAdd(this, _segmentValues, state());
    __publicField(this, "announcer");
    __privateAdd(this, _readonlySegmentsSet, derived(() => new Set(this.readonlySegments.current)));
    __publicField(this, "segmentStates", initSegmentStates());
    __privateAdd(this, _fieldNode, state(null));
    __privateAdd(this, _labelNode3, state(null));
    __privateAdd(this, _descriptionNode2, state(null));
    __privateAdd(this, _validationNode, state(null));
    __publicField(this, "states", initSegmentStates());
    __privateAdd(this, _dayPeriodNode, state(null));
    __publicField(this, "rangeRoot");
    __privateAdd(this, _name, state(""));
    __publicField(this, "setName", (name) => {
      this.name = name;
    });
    /**
     * Sets the field node for the `DateFieldRootState` instance. We use this method so we can
     * keep `#fieldNode` private to prevent accidental usage of the incorrect field node.
     */
    __publicField(this, "setFieldNode", (node) => {
      set(__privateGet(this, _fieldNode), proxy(node, null, __privateGet(this, _fieldNode)));
    });
    /**
     * Gets the correct field node for the date field regardless of whether it's being
     * used in a standalone context or within a `DateRangeField` component.
     */
    __publicField(this, "getFieldNode", () => {
      if (!this.rangeRoot) {
        return get(__privateGet(this, _fieldNode));
      } else {
        return this.rangeRoot.fieldNode;
      }
    });
    /**
     * Sets the label node for the `DateFieldRootState` instance. We use this method so we can
     * keep `#labelNode` private to prevent accidental usage of the incorrect label node.
     */
    __publicField(this, "setLabelNode", (node) => {
      set(__privateGet(this, _labelNode3), proxy(node, null, __privateGet(this, _labelNode3)));
    });
    /**
     * Gets the correct label node for the date field regardless of whether it's being used in
     * a standalone context or within a `DateRangeField` component.
     */
    __publicField(this, "getLabelNode", () => {
      if (!this.rangeRoot) {
        return get(__privateGet(this, _labelNode3));
      }
      return this.rangeRoot.labelNode;
    });
    __publicField(this, "clearUpdating", () => {
      this.states.day.updating = null;
      this.states.month.updating = null;
      this.states.year.updating = null;
      this.states.hour.updating = null;
      this.states.minute.updating = null;
      this.states.dayPeriod.updating = null;
    });
    __privateAdd(this, _validationStatus, derived(() => {
      var _a, _b;
      const value = this.value.current;
      if (!value) return false;
      const msg = (_b = (_a = this.validate).current) == null ? void 0 : _b.call(_a, value);
      if (msg) {
        return { reason: "custom", message: msg };
      }
      const minValue = this.minValue.current;
      if (minValue && isBefore(value, minValue)) {
        return { reason: "min" };
      }
      const maxValue = this.maxValue.current;
      if (maxValue && isBefore(maxValue, value)) {
        return { reason: "max" };
      }
      return false;
    }));
    __privateAdd(this, _isInvalid2, derived(() => {
      if (strict_equals(this.validationStatus, false)) return false;
      if (this.isInvalidProp.current) return true;
      return true;
    }));
    __privateAdd(this, _inferredGranularity, derived(() => {
      const granularity = this.granularity.current;
      if (granularity) return granularity;
      const inferred = inferGranularity(this.placeholder.current, this.granularity.current);
      return inferred;
    }));
    __privateAdd(this, _allSegmentContent, derived(() => createContent({
      segmentValues: this.segmentValues,
      formatter: this.formatter,
      locale: this.locale.current,
      granularity: this.inferredGranularity,
      dateRef: this.placeholder.current,
      hideTimeZone: this.hideTimeZone.current,
      hourCycle: this.hourCycle.current
    })));
    __privateAdd(this, _segmentContents, derived(() => this.allSegmentContent.arr));
    __publicField(this, "sharedSegmentAttrs", {
      role: "spinbutton",
      contenteditable: "true",
      tabindex: 0,
      spellcheck: false,
      inputmode: "numeric",
      autocorrect: "off",
      enterkeyhint: "next",
      style: { caretColor: "transparent" }
    });
    __publicField(this, "getLabelledBy", (segmentId) => {
      var _a;
      return `${segmentId} ${((_a = this.getLabelNode()) == null ? void 0 : _a.id) ?? ""}`;
    });
    __publicField(this, "updateSegment", (part, cb) => {
      const disabled = this.disabled.current;
      const readonly = this.readonly.current;
      const readonlySegmentsSet = this.readonlySegmentsSet;
      if (disabled || readonly || readonlySegmentsSet.has(part)) return;
      const prev2 = this.segmentValues;
      let newSegmentValues = prev2;
      const dateRef = this.placeholder.current;
      if (isDateAndTimeSegmentObj(prev2)) {
        const pVal = prev2[part];
        const castCb = cb;
        if (strict_equals(part, "month")) {
          const next3 = castCb(pVal);
          this.states.month.updating = next3;
          if (strict_equals(next3, null, false) && strict_equals(prev2.day, null, false)) {
            const date = dateRef.set({ month: Number.parseInt(next3) });
            const daysInMonth = getDaysInMonth(toDate(date));
            const prevDay = Number.parseInt(prev2.day);
            if (prevDay > daysInMonth) {
              prev2.day = `${daysInMonth}`;
            }
          }
          newSegmentValues = { ...prev2, [part]: next3 };
        } else if (strict_equals(part, "dayPeriod")) {
          const next3 = castCb(pVal);
          this.states.dayPeriod.updating = next3;
          const date = this.value.current;
          if (date && "hour" in date) {
            const trueHour = date.hour;
            if (strict_equals(next3, "AM")) {
              if (trueHour >= 12) {
                prev2.hour = `${trueHour - 12}`;
              }
            } else if (strict_equals(next3, "PM")) {
              if (trueHour < 12) {
                prev2.hour = `${trueHour + 12}`;
              }
            }
          }
          newSegmentValues = { ...prev2, [part]: next3 };
        } else if (strict_equals(part, "hour")) {
          const next3 = castCb(pVal);
          this.states.hour.updating = next3;
          if (strict_equals(next3, null, false) && strict_equals(prev2.dayPeriod, null, false)) {
            const dayPeriod = this.formatter.dayPeriod(toDate(dateRef.set({ hour: Number.parseInt(next3) })), this.hourCycle.current);
            if (strict_equals(dayPeriod, "AM") || strict_equals(dayPeriod, "PM")) {
              prev2.dayPeriod = dayPeriod;
            }
          }
          newSegmentValues = { ...prev2, [part]: next3 };
        } else if (strict_equals(part, "minute")) {
          const next3 = castCb(pVal);
          this.states.minute.updating = next3;
          newSegmentValues = { ...prev2, [part]: next3 };
        } else if (strict_equals(part, "second")) {
          const next3 = castCb(pVal);
          this.states.second.updating = next3;
          newSegmentValues = { ...prev2, [part]: next3 };
        } else if (strict_equals(part, "year")) {
          const next3 = castCb(pVal);
          this.states.year.updating = next3;
          newSegmentValues = { ...prev2, [part]: next3 };
        } else if (strict_equals(part, "day")) {
          const next3 = castCb(pVal);
          this.states.day.updating = next3;
          newSegmentValues = { ...prev2, [part]: next3 };
        } else {
          const next3 = castCb(pVal);
          newSegmentValues = { ...prev2, [part]: next3 };
        }
      } else if (isDateSegmentPart(part)) {
        const pVal = prev2[part];
        const castCb = cb;
        const next3 = castCb(pVal);
        if (strict_equals(part, "month") && strict_equals(next3, null, false) && strict_equals(prev2.day, null, false)) {
          this.states.month.updating = next3;
          const date = dateRef.set({ month: Number.parseInt(next3) });
          const daysInMonth = getDaysInMonth(toDate(date));
          if (Number.parseInt(prev2.day) > daysInMonth) {
            prev2.day = `${daysInMonth}`;
          }
          newSegmentValues = { ...prev2, [part]: next3 };
        } else if (strict_equals(part, "year")) {
          const next4 = castCb(pVal);
          this.states.year.updating = next4;
          newSegmentValues = { ...prev2, [part]: next4 };
        } else if (strict_equals(part, "day")) {
          const next4 = castCb(pVal);
          this.states.day.updating = next4;
          newSegmentValues = { ...prev2, [part]: next4 };
        } else {
          newSegmentValues = { ...prev2, [part]: next3 };
        }
      }
      this.segmentValues = newSegmentValues;
      if (areAllSegmentsFilled(newSegmentValues, get(__privateGet(this, _fieldNode)))) {
        this.setValue(getValueFromSegments({
          segmentObj: newSegmentValues,
          fieldNode: get(__privateGet(this, _fieldNode)),
          dateRef: this.placeholder.current
        }));
      } else {
        this.setValue(void 0);
        this.segmentValues = newSegmentValues;
      }
    });
    __publicField(this, "handleSegmentClick", (e) => {
      if (this.disabled.current) {
        e.preventDefault();
      }
    });
    __publicField(this, "getBaseSegmentAttrs", (part, segmentId) => {
      var _a, _b;
      const inReadonlySegments = this.readonlySegmentsSet.has(part);
      const defaultAttrs = {
        "aria-invalid": getAriaInvalid(this.isInvalid),
        "aria-disabled": getAriaDisabled(this.disabled.current),
        "aria-readonly": getAriaReadonly(this.readonly.current || inReadonlySegments),
        "data-invalid": getDataInvalid(this.isInvalid),
        "data-disabled": getDataDisabled(this.disabled.current),
        "data-readonly": getDataReadonly(this.readonly.current || inReadonlySegments),
        "data-segment": `${part}`
      };
      if (strict_equals(part, "literal")) return defaultAttrs;
      const descriptionId = (_a = this.descriptionNode) == null ? void 0 : _a.id;
      const hasDescription = isFirstSegment(segmentId, get(__privateGet(this, _fieldNode))) && descriptionId;
      const errorMsgId = (_b = this.errorMessageId) == null ? void 0 : _b.current;
      const describedBy = hasDescription ? `${descriptionId} ${this.isInvalid && errorMsgId ? errorMsgId : ""}` : void 0;
      const contenteditable = !(this.readonly.current || inReadonlySegments || this.disabled.current);
      return {
        ...defaultAttrs,
        "aria-labelledby": this.getLabelledBy(segmentId),
        contenteditable: contenteditable ? "true" : void 0,
        "aria-describedby": describedBy,
        tabindex: this.disabled.current ? void 0 : 0
      };
    });
    this.rangeRoot = rangeRoot;
    this.value = props.value;
    this.placeholder = rangeRoot ? rangeRoot.placeholder : props.placeholder;
    this.validate = rangeRoot ? box(void 0) : props.validate;
    this.minValue = rangeRoot ? rangeRoot.minValue : props.minValue;
    this.maxValue = rangeRoot ? rangeRoot.maxValue : props.maxValue;
    this.disabled = rangeRoot ? rangeRoot.disabled : props.disabled;
    this.readonly = rangeRoot ? rangeRoot.readonly : props.readonly;
    this.granularity = rangeRoot ? rangeRoot.granularity : props.granularity;
    this.readonlySegments = rangeRoot ? rangeRoot.readonlySegments : props.readonlySegments;
    this.hourCycle = rangeRoot ? rangeRoot.hourCycle : props.hourCycle;
    this.locale = rangeRoot ? rangeRoot.locale : props.locale;
    this.hideTimeZone = rangeRoot ? rangeRoot.hideTimeZone : props.hideTimeZone;
    this.required = rangeRoot ? rangeRoot.required : props.required;
    this.onInvalid = rangeRoot ? rangeRoot.onInvalid : props.onInvalid;
    this.errorMessageId = rangeRoot ? rangeRoot.errorMessageId : props.errorMessageId;
    this.isInvalidProp = props.isInvalidProp;
    this.formatter = createFormatter(this.locale.current);
    this.initialSegments = initializeSegmentValues(this.inferredGranularity);
    this.segmentValues = this.initialSegments;
    this.announcer = getAnnouncer();
    user_effect(() => {
      untrack(() => {
        this.initialSegments = initializeSegmentValues(this.inferredGranularity);
      });
    });
    onMount(() => {
      this.announcer = getAnnouncer();
    });
    onDestroyEffect(() => {
      if (rangeRoot) return;
      removeDescriptionElement(this.descriptionId);
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (this.value.current) {
        const descriptionId = untrack(() => this.descriptionId);
        setDescription(descriptionId, this.formatter, this.value.current);
      }
      const placeholder = untrack(() => this.placeholder.current);
      if (this.value.current && strict_equals(placeholder, this.value.current, false)) {
        untrack(() => {
          if (this.value.current) {
            this.placeholder.current = this.value.current;
          }
        });
      }
    });
    if (this.value.current) {
      this.syncSegmentValues(this.value.current);
    }
    user_effect(() => {
      this.locale.current;
      if (this.value.current) {
        this.syncSegmentValues(this.value.current);
      }
      this.clearUpdating();
    });
    user_effect(() => {
      this.validationStatus;
      untrack(() => {
        var _a, _b;
        if (strict_equals(this.validationStatus, false, false)) {
          (_b = (_a = this.onInvalid).current) == null ? void 0 : _b.call(_a, this.validationStatus.reason, this.validationStatus.message);
        }
      });
    });
  }
  get segmentValues() {
    return get(__privateGet(this, _segmentValues));
  }
  set segmentValues(value) {
    set(__privateGet(this, _segmentValues), proxy(value, null, __privateGet(this, _segmentValues)));
  }
  get readonlySegmentsSet() {
    return get(__privateGet(this, _readonlySegmentsSet));
  }
  set readonlySegmentsSet(_) {
    throw new Error("Cannot update a derived property ('readonlySegmentsSet')");
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode2));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode2), proxy(value, null, __privateGet(this, _descriptionNode2)));
  }
  get validationNode() {
    return get(__privateGet(this, _validationNode));
  }
  set validationNode(value) {
    set(__privateGet(this, _validationNode), proxy(value, null, __privateGet(this, _validationNode)));
  }
  get dayPeriodNode() {
    return get(__privateGet(this, _dayPeriodNode));
  }
  set dayPeriodNode(value) {
    set(__privateGet(this, _dayPeriodNode), proxy(value, null, __privateGet(this, _dayPeriodNode)));
  }
  get name() {
    return get(__privateGet(this, _name));
  }
  set name(value) {
    set(__privateGet(this, _name), proxy(value, null, __privateGet(this, _name)));
  }
  setValue(value) {
    this.value.current = value;
  }
  syncSegmentValues(value) {
    const dateValues = DATE_SEGMENT_PARTS.map((part) => {
      const partValue = value[part];
      if (strict_equals(part, "month")) {
        if (this.states.month.updating) {
          return [part, this.states.month.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (strict_equals(part, "day")) {
        if (this.states.day.updating) {
          return [part, this.states.day.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (strict_equals(part, "year")) {
        if (this.states.year.updating) {
          return [part, this.states.year.updating];
        }
        const valueDigits = `${partValue}`.length;
        const diff = 4 - valueDigits;
        if (diff > 0) {
          return [part, `${"0".repeat(diff)}${partValue}`];
        }
      }
      return [part, `${partValue}`];
    });
    if ("hour" in value) {
      const timeValues = TIME_SEGMENT_PARTS.map((part) => {
        if (strict_equals(part, "dayPeriod")) {
          if (this.states.dayPeriod.updating) {
            return [part, this.states.dayPeriod.updating];
          } else {
            return [
              part,
              this.formatter.dayPeriod(toDate(value))
            ];
          }
        } else if (strict_equals(part, "hour")) {
          if (this.states.hour.updating) {
            return [part, this.states.hour.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
          if (strict_equals(value[part], 0)) {
            if (this.dayPeriodNode) {
              return [part, "12"];
            }
          }
        } else if (strict_equals(part, "minute")) {
          if (this.states.minute.updating) {
            return [part, this.states.minute.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        } else if (strict_equals(part, "second")) {
          if (this.states.second.updating) {
            return [part, this.states.second.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        }
        return [part, `${value[part]}`];
      });
      const mergedSegmentValues = [...dateValues, ...timeValues];
      this.segmentValues = Object.fromEntries(mergedSegmentValues);
      this.clearUpdating();
      return;
    }
    this.segmentValues = Object.fromEntries(dateValues);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus));
  }
  set validationStatus(_) {
    throw new Error("Cannot update a derived property ('validationStatus')");
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid2));
  }
  set isInvalid(_) {
    throw new Error("Cannot update a derived property ('isInvalid')");
  }
  get inferredGranularity() {
    return get(__privateGet(this, _inferredGranularity));
  }
  set inferredGranularity(_) {
    throw new Error("Cannot update a derived property ('inferredGranularity')");
  }
  get allSegmentContent() {
    return get(__privateGet(this, _allSegmentContent));
  }
  set allSegmentContent(_) {
    throw new Error("Cannot update a derived property ('allSegmentContent')");
  }
  get segmentContents() {
    return get(__privateGet(this, _segmentContents));
  }
  set segmentContents(_) {
    throw new Error("Cannot update a derived property ('segmentContents')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _segmentValues)), owner, false);
    add_owner(get(__privateGet(this, _readonlySegmentsSet)), owner, false);
    add_owner(get(__privateGet(this, _descriptionNode2)), owner, false);
    add_owner(get(__privateGet(this, _validationNode)), owner, false);
    add_owner(get(__privateGet(this, _dayPeriodNode)), owner, false);
    add_owner(get(__privateGet(this, _name)), owner, false);
    add_owner(get(__privateGet(this, _validationStatus)), owner, false);
    add_owner(get(__privateGet(this, _isInvalid2)), owner, false);
    add_owner(get(__privateGet(this, _inferredGranularity)), owner, false);
    add_owner(get(__privateGet(this, _allSegmentContent)), owner, false);
    add_owner(get(__privateGet(this, _segmentContents)), owner, false);
  }
};
_segmentValues = new WeakMap();
_readonlySegmentsSet = new WeakMap();
_fieldNode = new WeakMap();
_labelNode3 = new WeakMap();
_descriptionNode2 = new WeakMap();
_validationNode = new WeakMap();
_dayPeriodNode = new WeakMap();
_name = new WeakMap();
_validationStatus = new WeakMap();
_isInvalid2 = new WeakMap();
_inferredGranularity = new WeakMap();
_allSegmentContent = new WeakMap();
_segmentContents = new WeakMap();
var _id51, _ref51, _name2, _ariaDescribedBy, _props76;
var DateFieldInputState = class {
  constructor(props, root17) {
    __privateAdd(this, _id51);
    __privateAdd(this, _ref51);
    __privateAdd(this, _name2);
    __publicField(this, "root");
    __privateAdd(this, _ariaDescribedBy, derived(() => {
      if (!isBrowser) return void 0;
      const doesDescriptionExist = document.getElementById(this.root.descriptionId);
      if (!doesDescriptionExist) return void 0;
      return this.root.descriptionId;
    }));
    __privateAdd(this, _props76, derived(() => {
      var _a;
      return {
        id: __privateGet(this, _id51).current,
        role: "group",
        "aria-labelledby": ((_a = this.root.getLabelNode()) == null ? void 0 : _a.id) ?? void 0,
        "aria-describedby": get(__privateGet(this, _ariaDescribedBy)),
        "aria-disabled": getAriaDisabled(this.root.disabled.current),
        "data-invalid": this.root.isInvalid ? "" : void 0,
        "data-disabled": getDataDisabled(this.root.disabled.current),
        [DATE_FIELD_INPUT_ATTR]: ""
      };
    }));
    __privateSet(this, _id51, props.id);
    __privateSet(this, _ref51, props.ref);
    this.root = root17;
    __privateSet(this, _name2, props.name);
    user_effect(() => {
      this.root.setName(__privateGet(this, _name2).current);
    });
    useRefById({
      id: __privateGet(this, _id51),
      ref: __privateGet(this, _ref51),
      onRefChange: (node) => {
        this.root.setFieldNode(node);
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props76));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props76)), owner, false);
  }
};
_id51 = new WeakMap();
_ref51 = new WeakMap();
_name2 = new WeakMap();
_ariaDescribedBy = new WeakMap();
_props76 = new WeakMap();
var _root18, _shouldRender7, _isoValue, _props77;
var DateFieldHiddenInputState = class {
  constructor(root17) {
    __privateAdd(this, _root18);
    __privateAdd(this, _shouldRender7, derived(() => strict_equals(__privateGet(this, _root18).name, "", false)));
    __privateAdd(this, _isoValue, derived(() => __privateGet(this, _root18).value.current ? __privateGet(this, _root18).value.current.toString() : ""));
    __privateAdd(this, _props77, derived(() => {
      return {
        name: __privateGet(this, _root18).name,
        value: this.isoValue,
        required: __privateGet(this, _root18).required.current,
        "aria-hidden": getAriaHidden(true)
      };
    }));
    __privateSet(this, _root18, root17);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender7));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get isoValue() {
    return get(__privateGet(this, _isoValue));
  }
  set isoValue(_) {
    throw new Error("Cannot update a derived property ('isoValue')");
  }
  get props() {
    return get(__privateGet(this, _props77));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _shouldRender7)), owner, false);
    add_owner(get(__privateGet(this, _isoValue)), owner, false);
    add_owner(get(__privateGet(this, _props77)), owner, false);
  }
};
_root18 = new WeakMap();
_shouldRender7 = new WeakMap();
_isoValue = new WeakMap();
_props77 = new WeakMap();
var _id52, _ref52, _root19, _onclick12, _props78;
var DateFieldLabelState = class {
  constructor(props, root17) {
    __privateAdd(this, _id52);
    __privateAdd(this, _ref52);
    __privateAdd(this, _root19);
    __privateAdd(this, _onclick12, () => {
      if (__privateGet(this, _root19).disabled.current) return;
      const firstSegment = getFirstSegment(__privateGet(this, _root19).getFieldNode());
      if (!firstSegment) return;
      firstSegment.focus();
    });
    __privateAdd(this, _props78, derived(() => ({
      id: __privateGet(this, _id52).current,
      "data-invalid": getDataInvalid(__privateGet(this, _root19).isInvalid),
      "data-disabled": getDataDisabled(__privateGet(this, _root19).disabled.current),
      [DATE_FIELD_LABEL_ATTR]: "",
      onclick: __privateGet(this, _onclick12)
    })));
    __privateSet(this, _id52, props.id);
    __privateSet(this, _ref52, props.ref);
    __privateSet(this, _root19, root17);
    useRefById({
      id: __privateGet(this, _id52),
      ref: __privateGet(this, _ref52),
      onRefChange: (node) => {
        __privateGet(this, _root19).setLabelNode(node);
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props78));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props78)), owner, false);
  }
};
_id52 = new WeakMap();
_ref52 = new WeakMap();
_root19 = new WeakMap();
_onclick12 = new WeakMap();
_props78 = new WeakMap();
var _id53, _ref53, _root20, _announcer, _updateSegment, _onkeydown18, _onfocusout, _props79;
var DateFieldDaySegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id53);
    __privateAdd(this, _ref53);
    __privateAdd(this, _root20);
    __privateAdd(this, _announcer);
    __privateAdd(this, _updateSegment);
    __privateAdd(this, _onkeydown18, (e) => {
      const placeholder = __privateGet(this, _root20).placeholder.current;
      if (e.ctrlKey || e.metaKey || __privateGet(this, _root20).disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (!isAcceptableSegmentKey(e.key)) return;
      const segmentMonthValue = __privateGet(this, _root20).segmentValues.month;
      const daysInMonth = segmentMonthValue ? getDaysInMonth(placeholder.set({ month: Number.parseInt(segmentMonthValue) })) : getDaysInMonth(placeholder);
      if (isArrowUp(e.key)) {
        __privateGet(this, _updateSegment).call(this, "day", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = placeholder.day;
            __privateGet(this, _announcer).announce(next4);
            if (next4 < 10) return `0${next4}`;
            return `${next4}`;
          }
          const next3 = placeholder.set({ day: Number.parseInt(prev2) }).cycle("day", 1).day;
          __privateGet(this, _announcer).announce(next3);
          if (next3 < 10) return `0${next3}`;
          return `${next3}`;
        });
        return;
      }
      if (isArrowDown(e.key)) {
        __privateGet(this, _updateSegment).call(this, "day", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = placeholder.day;
            __privateGet(this, _announcer).announce(next4);
            if (next4 < 10) return `0${next4}`;
            return `${next4}`;
          }
          const next3 = placeholder.set({ day: Number.parseInt(prev2) }).cycle("day", -1).day;
          __privateGet(this, _announcer).announce(next3);
          if (next3 < 10) return `0${next3}`;
          return `${next3}`;
        });
        return;
      }
      const fieldNode = __privateGet(this, _root20).getFieldNode();
      if (isNumberString(e.key)) {
        const num = Number.parseInt(e.key);
        let moveToNext = false;
        __privateGet(this, _updateSegment).call(this, "day", (prev2) => {
          const max = daysInMonth;
          const maxStart = Math.floor(max / 10);
          const numIsZero = strict_equals(num, 0);
          if (__privateGet(this, _root20).states.day.hasLeftFocus) {
            prev2 = null;
            __privateGet(this, _root20).states.day.hasLeftFocus = false;
          }
          if (strict_equals(prev2, null)) {
            if (numIsZero) {
              __privateGet(this, _root20).states.day.lastKeyZero = true;
              __privateGet(this, _announcer).announce("0");
              return "0";
            }
            if (__privateGet(this, _root20).states.day.lastKeyZero || num > maxStart) {
              moveToNext = true;
            }
            __privateGet(this, _root20).states.day.lastKeyZero = false;
            if (moveToNext && strict_equals(String(num).length, 1)) {
              __privateGet(this, _announcer).announce(num);
              return `0${num}`;
            }
            return `${num}`;
          }
          const total = Number.parseInt(prev2 + num.toString());
          if (__privateGet(this, _root20).states.day.lastKeyZero) {
            if (strict_equals(num, 0, false)) {
              moveToNext = true;
              __privateGet(this, _root20).states.day.lastKeyZero = false;
              return `0${num}`;
            }
            return prev2;
          }
          if (total > max) {
            moveToNext = true;
            return `0${num}`;
          }
          moveToNext = true;
          return `${total}`;
        });
        if (moveToNext) {
          moveToNextSegment(e, fieldNode);
        }
      }
      if (isBackspace(e.key)) {
        let moveToPrev = false;
        __privateGet(this, _updateSegment).call(this, "day", (prev2) => {
          __privateGet(this, _root20).states.day.hasLeftFocus = false;
          if (strict_equals(prev2, null)) {
            moveToPrev = true;
            return null;
          }
          if (strict_equals(prev2.length, 2) && prev2.startsWith("0")) {
            return null;
          }
          const str = prev2.toString();
          if (strict_equals(str.length, 1)) return null;
          return str.slice(0, -1);
        });
        if (moveToPrev) {
          moveToPrevSegment(e, fieldNode);
        }
      }
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, fieldNode);
      }
    });
    __privateAdd(this, _onfocusout, () => {
      __privateGet(this, _root20).states.day.hasLeftFocus = true;
      __privateGet(this, _updateSegment).call(this, "month", (prev2) => {
        if (prev2 && strict_equals(prev2.length, 1)) {
          return `0${prev2}`;
        }
        return prev2;
      });
    });
    __privateAdd(this, _props79, derived(() => {
      const date = __privateGet(this, _root20).segmentValues.day ? __privateGet(this, _root20).placeholder.current.set({
        day: Number.parseInt(__privateGet(this, _root20).segmentValues.day)
      }) : __privateGet(this, _root20).placeholder.current;
      return {
        ...__privateGet(this, _root20).sharedSegmentAttrs,
        id: __privateGet(this, _id53).current,
        "aria-label": "day,",
        "aria-valuemin": 1,
        "aria-valuemax": getDaysInMonth(toDate(date)),
        "aria-valuenow": date.day,
        "aria-valuetext": strict_equals(__privateGet(this, _root20).segmentValues.day, null) ? "Empty" : `${date.day}`,
        onkeydown: __privateGet(this, _onkeydown18),
        onfocusout: __privateGet(this, _onfocusout),
        onclick: __privateGet(this, _root20).handleSegmentClick,
        ...__privateGet(this, _root20).getBaseSegmentAttrs("day", __privateGet(this, _id53).current)
      };
    }));
    __privateSet(this, _id53, props.id);
    __privateSet(this, _ref53, props.ref);
    __privateSet(this, _root20, root17);
    __privateSet(this, _announcer, __privateGet(this, _root20).announcer);
    __privateSet(this, _updateSegment, __privateGet(this, _root20).updateSegment);
    useRefById({ id: __privateGet(this, _id53), ref: __privateGet(this, _ref53) });
  }
  get props() {
    return get(__privateGet(this, _props79));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props79)), owner, false);
  }
};
_id53 = new WeakMap();
_ref53 = new WeakMap();
_root20 = new WeakMap();
_announcer = new WeakMap();
_updateSegment = new WeakMap();
_onkeydown18 = new WeakMap();
_onfocusout = new WeakMap();
_props79 = new WeakMap();
var _id54, _ref54, _root21, _announcer2, _updateSegment2, _onkeydown19, _onfocusout2, _props80;
var DateFieldMonthSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id54);
    __privateAdd(this, _ref54);
    __privateAdd(this, _root21);
    __privateAdd(this, _announcer2);
    __privateAdd(this, _updateSegment2);
    __publicField(this, "getAnnouncement", (month) => {
      return `${month} - ${__privateGet(this, _root21).formatter.fullMonth(toDate(__privateGet(this, _root21).placeholder.current.set({ month })))}`;
    });
    __privateAdd(this, _onkeydown19, (e) => {
      if (e.ctrlKey || e.metaKey || __privateGet(this, _root21).disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (!isAcceptableSegmentKey(e.key)) return;
      const max = 12;
      if (isArrowUp(e.key)) {
        __privateGet(this, _updateSegment2).call(this, "month", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = __privateGet(this, _root21).placeholder.current.month;
            __privateGet(this, _announcer2).announce(this.getAnnouncement(next4));
            if (strict_equals(String(next4).length, 1)) {
              return `0${next4}`;
            }
            return `${next4}`;
          }
          const next3 = __privateGet(this, _root21).placeholder.current.set({ month: Number.parseInt(prev2) }).cycle("month", 1).month;
          __privateGet(this, _announcer2).announce(this.getAnnouncement(next3));
          if (strict_equals(String(next3).length, 1)) {
            return `0${next3}`;
          }
          return `${next3}`;
        });
        return;
      }
      if (isArrowDown(e.key)) {
        __privateGet(this, _updateSegment2).call(this, "month", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = __privateGet(this, _root21).placeholder.current.month;
            __privateGet(this, _announcer2).announce(this.getAnnouncement(next4));
            if (strict_equals(String(next4).length, 1)) {
              return `0${next4}`;
            }
            return `${next4}`;
          }
          const next3 = __privateGet(this, _root21).placeholder.current.set({ month: Number.parseInt(prev2) }).cycle("month", -1).month;
          __privateGet(this, _announcer2).announce(this.getAnnouncement(next3));
          if (strict_equals(String(next3).length, 1)) {
            return `0${next3}`;
          }
          return `${next3}`;
        });
        return;
      }
      if (isNumberString(e.key)) {
        const num = Number.parseInt(e.key);
        let moveToNext = false;
        __privateGet(this, _updateSegment2).call(this, "month", (prev2) => {
          const maxStart = Math.floor(max / 10);
          const numIsZero = strict_equals(num, 0);
          if (__privateGet(this, _root21).states.month.hasLeftFocus) {
            prev2 = null;
            __privateGet(this, _root21).states.month.hasLeftFocus = false;
          }
          if (strict_equals(prev2, null)) {
            if (numIsZero) {
              __privateGet(this, _root21).states.month.lastKeyZero = true;
              __privateGet(this, _announcer2).announce("0");
              return "0";
            }
            if (__privateGet(this, _root21).states.month.lastKeyZero || num > maxStart) {
              moveToNext = true;
            }
            __privateGet(this, _root21).states.month.lastKeyZero = false;
            if (moveToNext && strict_equals(String(num).length, 1)) {
              __privateGet(this, _announcer2).announce(num);
              return `0${num}`;
            }
            return `${num}`;
          }
          const total = Number.parseInt(prev2 + num.toString());
          if (__privateGet(this, _root21).states.month.lastKeyZero) {
            if (strict_equals(num, 0, false)) {
              moveToNext = true;
              __privateGet(this, _root21).states.month.lastKeyZero = false;
              return `0${num}`;
            }
            return prev2;
          }
          if (total > max) {
            moveToNext = true;
            return `0${num}`;
          }
          moveToNext = true;
          return `${total}`;
        });
        if (moveToNext) {
          moveToNextSegment(e, __privateGet(this, _root21).getFieldNode());
        }
      }
      if (isBackspace(e.key)) {
        __privateGet(this, _root21).states.month.hasLeftFocus = false;
        let moveToPrev = false;
        __privateGet(this, _updateSegment2).call(this, "month", (prev2) => {
          if (strict_equals(prev2, null)) {
            __privateGet(this, _announcer2).announce(null);
            moveToPrev = true;
            return null;
          }
          if (strict_equals(prev2.length, 2) && prev2.startsWith("0")) {
            __privateGet(this, _announcer2).announce(null);
            return null;
          }
          const str = prev2.toString();
          if (strict_equals(str.length, 1)) {
            __privateGet(this, _announcer2).announce(null);
            return null;
          }
          const next3 = Number.parseInt(str.slice(0, -1));
          __privateGet(this, _announcer2).announce(this.getAnnouncement(next3));
          return `${next3}`;
        });
        if (moveToPrev) {
          moveToPrevSegment(e, __privateGet(this, _root21).getFieldNode());
        }
      }
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, __privateGet(this, _root21).getFieldNode());
      }
    });
    __privateAdd(this, _onfocusout2, () => {
      __privateGet(this, _root21).states.month.hasLeftFocus = true;
      __privateGet(this, _updateSegment2).call(this, "month", (prev2) => {
        if (prev2 && strict_equals(prev2.length, 1)) {
          return `0${prev2}`;
        }
        return prev2;
      });
    });
    __privateAdd(this, _props80, derived(() => {
      const date = __privateGet(this, _root21).segmentValues.month ? __privateGet(this, _root21).placeholder.current.set({
        month: Number.parseInt(__privateGet(this, _root21).segmentValues.month)
      }) : __privateGet(this, _root21).placeholder.current;
      return {
        ...__privateGet(this, _root21).sharedSegmentAttrs,
        id: __privateGet(this, _id54).current,
        "aria-label": "month, ",
        contenteditable: "true",
        "aria-valuemin": 1,
        "aria-valuemax": 12,
        "aria-valuenow": date.month,
        "aria-valuetext": strict_equals(__privateGet(this, _root21).segmentValues.month, null) ? "Empty" : `${date.month} - ${__privateGet(this, _root21).formatter.fullMonth(toDate(date))}`,
        onkeydown: __privateGet(this, _onkeydown19),
        onfocusout: __privateGet(this, _onfocusout2),
        onclick: __privateGet(this, _root21).handleSegmentClick,
        ...__privateGet(this, _root21).getBaseSegmentAttrs("month", __privateGet(this, _id54).current)
      };
    }));
    __privateSet(this, _id54, props.id);
    __privateSet(this, _ref54, props.ref);
    __privateSet(this, _root21, root17);
    __privateSet(this, _announcer2, __privateGet(this, _root21).announcer);
    __privateSet(this, _updateSegment2, __privateGet(this, _root21).updateSegment);
    useRefById({ id: __privateGet(this, _id54), ref: __privateGet(this, _ref54) });
  }
  get props() {
    return get(__privateGet(this, _props80));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props80)), owner, false);
  }
};
_id54 = new WeakMap();
_ref54 = new WeakMap();
_root21 = new WeakMap();
_announcer2 = new WeakMap();
_updateSegment2 = new WeakMap();
_onkeydown19 = new WeakMap();
_onfocusout2 = new WeakMap();
_props80 = new WeakMap();
var _id55, _ref55, _root22, _announcer3, _updateSegment3, _pressedKeys, _backspaceCount, _resetBackspaceCount, _incrementBackspaceCount, _onkeydown20, _onfocusout3, _props81;
var DateFieldYearSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id55);
    __privateAdd(this, _ref55);
    __privateAdd(this, _root22);
    __privateAdd(this, _announcer3);
    __privateAdd(this, _updateSegment3);
    /**
     * When typing a year, a user may want to type `0090` to represent `90`.
     * So we track the keys they've pressed in this specific interaction to
     * determine once they've pressed four to move to the next segment.
     *
     * On `focusout` this is reset to an empty array.
     */
    __privateAdd(this, _pressedKeys, []);
    /**
     * When a user re-enters a completed segment and backspaces, if they have
     * leading zeroes on the year, they won't automatically be sent to the next
     * segment even if they complete all 4 digits. This is because the leading zeroes
     * get stripped out for the digit count.
     *
     * This lets us keep track of how many times the user has backspaced in a row
     * to determine how many additional key presses should move them to the next segment.
     *
     * For example, if the user has `0098` in the year segment and backspaces once,
     * the segment will contain `009` and if the user types `7`, the segment should
     * contain `0097` and move to the next segment.
     *
     * If the segment contains `0100` and the user backspaces twice, the segment will
     * contain `01` and if the user types `2`, the segment should contain `012` and
     * it should _not_ move to the next segment until the user types another digit.
     */
    __privateAdd(this, _backspaceCount, 0);
    __privateAdd(this, _resetBackspaceCount, () => {
      __privateSet(this, _backspaceCount, 0);
    });
    __privateAdd(this, _incrementBackspaceCount, () => {
      __privateWrapper(this, _backspaceCount)._++;
    });
    __privateAdd(this, _onkeydown20, (e) => {
      const placeholder = __privateGet(this, _root22).placeholder.current;
      if (e.ctrlKey || e.metaKey || __privateGet(this, _root22).disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (!isAcceptableSegmentKey(e.key)) return;
      if (isArrowUp(e.key)) {
        __privateGet(this, _resetBackspaceCount).call(this);
        __privateGet(this, _updateSegment3).call(this, "year", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = placeholder.year;
            __privateGet(this, _announcer3).announce(next4);
            return `${next4}`;
          }
          const next3 = placeholder.set({ year: Number.parseInt(prev2) }).cycle("year", 1).year;
          __privateGet(this, _announcer3).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isArrowDown(e.key)) {
        __privateGet(this, _resetBackspaceCount).call(this);
        __privateGet(this, _updateSegment3).call(this, "year", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = placeholder.year;
            __privateGet(this, _announcer3).announce(next4);
            return `${next4}`;
          }
          const next3 = placeholder.set({ year: Number.parseInt(prev2) }).cycle("year", -1).year;
          __privateGet(this, _announcer3).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isNumberString(e.key)) {
        __privateGet(this, _pressedKeys).push(e.key);
        let moveToNext = false;
        const num = Number.parseInt(e.key);
        __privateGet(this, _updateSegment3).call(this, "year", (prev2) => {
          if (__privateGet(this, _root22).states.year.hasLeftFocus) {
            prev2 = null;
            __privateGet(this, _root22).states.year.hasLeftFocus = false;
          }
          if (strict_equals(prev2, null)) {
            __privateGet(this, _announcer3).announce(num);
            return `000${num}`;
          }
          const str = prev2.toString() + num.toString();
          const mergedInt = Number.parseInt(str);
          const mergedIntDigits = String(mergedInt).length;
          if (mergedIntDigits < 4) {
            if (__privateGet(this, _backspaceCount) > 0 && __privateGet(this, _pressedKeys).length <= __privateGet(this, _backspaceCount) && str.length <= 4) {
              __privateGet(this, _announcer3).announce(mergedInt);
              return str;
            }
            __privateGet(this, _announcer3).announce(mergedInt);
            return prependYearZeros(mergedInt);
          }
          __privateGet(this, _announcer3).announce(mergedInt);
          moveToNext = true;
          const mergedIntStr = `${mergedInt}`;
          if (mergedIntStr.length > 4) {
            return mergedIntStr.slice(0, 4);
          }
          return mergedIntStr;
        });
        if (strict_equals(__privateGet(this, _pressedKeys).length, 4) || strict_equals(__privateGet(this, _pressedKeys).length, __privateGet(this, _backspaceCount))) {
          moveToNext = true;
        }
        if (moveToNext) {
          moveToNextSegment(e, __privateGet(this, _root22).getFieldNode());
        }
      }
      if (isBackspace(e.key)) {
        __privateSet(this, _pressedKeys, []);
        __privateGet(this, _incrementBackspaceCount).call(this);
        let moveToPrev = false;
        __privateGet(this, _updateSegment3).call(this, "year", (prev2) => {
          __privateGet(this, _root22).states.year.hasLeftFocus = false;
          if (strict_equals(prev2, null)) {
            moveToPrev = true;
            __privateGet(this, _announcer3).announce(null);
            return null;
          }
          const str = prev2.toString();
          if (strict_equals(str.length, 1)) {
            __privateGet(this, _announcer3).announce(null);
            return null;
          }
          const next3 = str.slice(0, -1);
          __privateGet(this, _announcer3).announce(next3);
          return `${next3}`;
        });
        if (moveToPrev) {
          moveToPrevSegment(e, __privateGet(this, _root22).getFieldNode());
        }
      }
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, __privateGet(this, _root22).getFieldNode());
      }
    });
    __privateAdd(this, _onfocusout3, () => {
      __privateGet(this, _root22).states.year.hasLeftFocus = true;
      __privateSet(this, _pressedKeys, []);
      __privateGet(this, _resetBackspaceCount).call(this);
      __privateGet(this, _updateSegment3).call(this, "year", (prev2) => {
        if (prev2 && strict_equals(prev2.length, 4, false)) {
          return prependYearZeros(Number.parseInt(prev2));
        }
        return prev2;
      });
    });
    __privateAdd(this, _props81, derived(() => {
      const segmentValues = __privateGet(this, _root22).segmentValues;
      const placeholder = __privateGet(this, _root22).placeholder.current;
      const isEmpty = strict_equals(segmentValues.year, null);
      const date = segmentValues.year ? placeholder.set({ year: Number.parseInt(segmentValues.year) }) : placeholder;
      const valueMin = 1;
      const valueMax = 9999;
      const valueNow = date.year;
      const valueText = isEmpty ? "Empty" : `${valueNow}`;
      return {
        ...__privateGet(this, _root22).sharedSegmentAttrs,
        id: __privateGet(this, _id55).current,
        "aria-label": "year, ",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: __privateGet(this, _onkeydown20),
        onclick: __privateGet(this, _root22).handleSegmentClick,
        onfocusout: __privateGet(this, _onfocusout3),
        ...__privateGet(this, _root22).getBaseSegmentAttrs("year", __privateGet(this, _id55).current)
      };
    }));
    __privateSet(this, _id55, props.id);
    __privateSet(this, _ref55, props.ref);
    __privateSet(this, _root22, root17);
    __privateSet(this, _announcer3, __privateGet(this, _root22).announcer);
    __privateSet(this, _updateSegment3, __privateGet(this, _root22).updateSegment);
    useRefById({ id: __privateGet(this, _id55), ref: __privateGet(this, _ref55) });
  }
  get props() {
    return get(__privateGet(this, _props81));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props81)), owner, false);
  }
};
_id55 = new WeakMap();
_ref55 = new WeakMap();
_root22 = new WeakMap();
_announcer3 = new WeakMap();
_updateSegment3 = new WeakMap();
_pressedKeys = new WeakMap();
_backspaceCount = new WeakMap();
_resetBackspaceCount = new WeakMap();
_incrementBackspaceCount = new WeakMap();
_onkeydown20 = new WeakMap();
_onfocusout3 = new WeakMap();
_props81 = new WeakMap();
var _id56, _ref56, _root23, _announcer4, _updateSegment4, _onkeydown21, _onfocusout4, _props82;
var DateFieldHourSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id56);
    __privateAdd(this, _ref56);
    __privateAdd(this, _root23);
    __privateAdd(this, _announcer4);
    __privateAdd(this, _updateSegment4);
    __privateAdd(this, _onkeydown21, (e) => {
      const placeholder = __privateGet(this, _root23).placeholder.current;
      if (e.ctrlKey || e.metaKey || __privateGet(this, _root23).disabled.current || !("hour" in placeholder)) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (!isAcceptableSegmentKey(e.key)) return;
      const hourCycle = __privateGet(this, _root23).hourCycle.current;
      if (isArrowUp(e.key)) {
        __privateGet(this, _updateSegment4).call(this, "hour", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = placeholder.cycle("hour", 1, { hourCycle }).hour;
            __privateGet(this, _announcer4).announce(next4);
            return `${next4}`;
          }
          const next3 = placeholder.set({ hour: Number.parseInt(prev2) }).cycle("hour", 1, { hourCycle }).hour;
          if (strict_equals(next3, 0) && "dayPeriod" in __privateGet(this, _root23).segmentValues && strict_equals(__privateGet(this, _root23).segmentValues.dayPeriod, null, false) && strict_equals(__privateGet(this, _root23).hourCycle.current, 24, false)) {
            __privateGet(this, _announcer4).announce("12");
            return "12";
          }
          if (strict_equals(next3, 0) && strict_equals(__privateGet(this, _root23).hourCycle.current, 24)) {
            __privateGet(this, _announcer4).announce("00");
            return "00";
          }
          __privateGet(this, _announcer4).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isArrowDown(e.key)) {
        __privateGet(this, _updateSegment4).call(this, "hour", (prev2) => {
          if (strict_equals(prev2, null)) {
            const next4 = placeholder.cycle("hour", -1, { hourCycle }).hour;
            __privateGet(this, _announcer4).announce(next4);
            return `${next4}`;
          }
          const next3 = placeholder.set({ hour: Number.parseInt(prev2) }).cycle("hour", -1, { hourCycle }).hour;
          if (strict_equals(next3, 0) && "dayPeriod" in __privateGet(this, _root23).segmentValues && strict_equals(__privateGet(this, _root23).segmentValues.dayPeriod, null, false) && strict_equals(__privateGet(this, _root23).hourCycle.current, 24, false)) {
            __privateGet(this, _announcer4).announce("12");
            return "12";
          }
          if (strict_equals(next3, 0) && strict_equals(__privateGet(this, _root23).hourCycle.current, 24)) {
            __privateGet(this, _announcer4).announce("00");
            return "00";
          }
          __privateGet(this, _announcer4).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isNumberString(e.key)) {
        const num = Number.parseInt(e.key);
        const max = strict_equals(__privateGet(this, _root23).hourCycle.current, 24) ? 23 : "dayPeriod" in __privateGet(this, _root23).segmentValues && strict_equals(__privateGet(this, _root23).segmentValues.dayPeriod, null, false) ? 12 : 23;
        const maxStart = Math.floor(max / 10);
        let moveToNext = false;
        const numIsZero = strict_equals(num, 0);
        __privateGet(this, _updateSegment4).call(this, "hour", (prev2) => {
          if (__privateGet(this, _root23).states.hour.hasLeftFocus) {
            prev2 = null;
            __privateGet(this, _root23).states.hour.hasLeftFocus = false;
          }
          if (strict_equals(prev2, null)) {
            if (numIsZero) {
              __privateGet(this, _root23).states.hour.lastKeyZero = true;
              __privateGet(this, _announcer4).announce("0");
              return "0";
            }
            if (__privateGet(this, _root23).states.hour.lastKeyZero || num > maxStart) {
              moveToNext = true;
            }
            __privateGet(this, _root23).states.hour.lastKeyZero = false;
            if (moveToNext && strict_equals(String(num).length, 1)) {
              __privateGet(this, _announcer4).announce(num);
              return `0${num}`;
            }
            return `${num}`;
          }
          const total = Number.parseInt(prev2 + num.toString());
          if (__privateGet(this, _root23).states.hour.lastKeyZero) {
            if (strict_equals(num, 0, false)) {
              moveToNext = true;
              __privateGet(this, _root23).states.hour.lastKeyZero = false;
              return `0${num}`;
            }
            if (strict_equals(num, 0) && strict_equals(__privateGet(this, _root23).hourCycle.current, 24)) {
              moveToNext = true;
              __privateGet(this, _root23).states.hour.lastKeyZero = false;
              return `0${num}`;
            }
            return prev2;
          }
          if (total > max) {
            moveToNext = true;
            return `0${num}`;
          }
          moveToNext = true;
          return `${total}`;
        });
        if (moveToNext) {
          moveToNextSegment(e, __privateGet(this, _root23).getFieldNode());
        }
      }
      if (isBackspace(e.key)) {
        __privateGet(this, _root23).states.hour.hasLeftFocus = false;
        let moveToPrev = false;
        __privateGet(this, _updateSegment4).call(this, "hour", (prev2) => {
          if (strict_equals(prev2, null)) {
            __privateGet(this, _announcer4).announce(null);
            moveToPrev = true;
            return null;
          }
          const str = prev2.toString();
          if (strict_equals(str.length, 1)) {
            __privateGet(this, _announcer4).announce(null);
            return null;
          }
          const next3 = Number.parseInt(str.slice(0, -1));
          __privateGet(this, _announcer4).announce(next3);
          return `${next3}`;
        });
        if (moveToPrev) {
          moveToPrevSegment(e, __privateGet(this, _root23).getFieldNode());
        }
      }
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, __privateGet(this, _root23).getFieldNode());
      }
    });
    __privateAdd(this, _onfocusout4, () => {
      __privateGet(this, _root23).states.hour.hasLeftFocus = true;
    });
    __privateAdd(this, _props82, derived(() => {
      const segmentValues = __privateGet(this, _root23).segmentValues;
      const hourCycle = __privateGet(this, _root23).hourCycle.current;
      const placeholder = __privateGet(this, _root23).placeholder.current;
      if (!("hour" in segmentValues) || !("hour" in placeholder)) return {};
      const isEmpty = strict_equals(segmentValues.hour, null);
      const date = segmentValues.hour ? placeholder.set({ hour: Number.parseInt(segmentValues.hour) }) : placeholder;
      const valueMin = strict_equals(hourCycle, 12) ? 1 : 0;
      const valueMax = strict_equals(hourCycle, 12) ? 12 : 23;
      const valueNow = date.hour;
      const valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod ?? ""}`;
      return {
        ...__privateGet(this, _root23).sharedSegmentAttrs,
        id: __privateGet(this, _id56).current,
        "aria-label": "hour, ",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: __privateGet(this, _onkeydown21),
        onfocusout: __privateGet(this, _onfocusout4),
        onclick: __privateGet(this, _root23).handleSegmentClick,
        ...__privateGet(this, _root23).getBaseSegmentAttrs("hour", __privateGet(this, _id56).current)
      };
    }));
    __privateSet(this, _id56, props.id);
    __privateSet(this, _ref56, props.ref);
    __privateSet(this, _root23, root17);
    __privateSet(this, _announcer4, __privateGet(this, _root23).announcer);
    __privateSet(this, _updateSegment4, __privateGet(this, _root23).updateSegment);
    useRefById({ id: __privateGet(this, _id56), ref: __privateGet(this, _ref56) });
  }
  get props() {
    return get(__privateGet(this, _props82));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props82)), owner, false);
  }
};
_id56 = new WeakMap();
_ref56 = new WeakMap();
_root23 = new WeakMap();
_announcer4 = new WeakMap();
_updateSegment4 = new WeakMap();
_onkeydown21 = new WeakMap();
_onfocusout4 = new WeakMap();
_props82 = new WeakMap();
var _id57, _ref57, _root24, _announcer5, _updateSegment5, _onkeydown22, _onfocusout5, _props83;
var DateFieldMinuteSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id57);
    __privateAdd(this, _ref57);
    __privateAdd(this, _root24);
    __privateAdd(this, _announcer5);
    __privateAdd(this, _updateSegment5);
    __privateAdd(this, _onkeydown22, (e) => {
      const placeholder = __privateGet(this, _root24).placeholder.current;
      if (e.ctrlKey || e.metaKey || __privateGet(this, _root24).disabled.current || !("minute" in placeholder)) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (!isAcceptableSegmentKey(e.key)) return;
      const min = 0;
      const max = 59;
      if (isArrowUp(e.key)) {
        __privateGet(this, _updateSegment5).call(this, "minute", (prev2) => {
          if (strict_equals(prev2, null)) {
            __privateGet(this, _announcer5).announce(min);
            return `${min}`;
          }
          const next3 = placeholder.set({ minute: Number.parseInt(prev2) }).cycle("minute", 1).minute;
          __privateGet(this, _announcer5).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isArrowDown(e.key)) {
        __privateGet(this, _updateSegment5).call(this, "minute", (prev2) => {
          if (strict_equals(prev2, null)) {
            __privateGet(this, _announcer5).announce(max);
            return `${max}`;
          }
          const next3 = placeholder.set({ minute: Number.parseInt(prev2) }).cycle("minute", -1).minute;
          __privateGet(this, _announcer5).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isNumberString(e.key)) {
        const num = Number.parseInt(e.key);
        let moveToNext = false;
        const numIsZero = strict_equals(num, 0);
        __privateGet(this, _updateSegment5).call(this, "minute", (prev2) => {
          const maxStart = Math.floor(max / 10);
          if (__privateGet(this, _root24).states.minute.hasLeftFocus) {
            prev2 = null;
            __privateGet(this, _root24).states.minute.hasLeftFocus = false;
          }
          if (strict_equals(prev2, null)) {
            if (numIsZero) {
              __privateGet(this, _root24).states.minute.lastKeyZero = true;
              __privateGet(this, _announcer5).announce("0");
              return "0";
            }
            if (__privateGet(this, _root24).states.minute.lastKeyZero || num > maxStart) {
              moveToNext = true;
            }
            __privateGet(this, _root24).states.minute.lastKeyZero = false;
            if (moveToNext && strict_equals(String(num).length, 1)) {
              __privateGet(this, _announcer5).announce(num);
              return `0${num}`;
            }
            return `${num}`;
          }
          const total = Number.parseInt(prev2 + num.toString());
          if (__privateGet(this, _root24).states.minute.lastKeyZero) {
            if (strict_equals(num, 0, false)) {
              moveToNext = true;
              __privateGet(this, _root24).states.minute.lastKeyZero = false;
              return `0${num}`;
            }
            moveToNext = true;
            __privateGet(this, _root24).states.minute.lastKeyZero = false;
            return "00";
          }
          if (total > max) {
            moveToNext = true;
            return `0${num}`;
          }
          moveToNext = true;
          return `${total}`;
        });
        if (moveToNext) {
          moveToNextSegment(e, __privateGet(this, _root24).getFieldNode());
        }
        return;
      }
      if (isBackspace(e.key)) {
        __privateGet(this, _root24).states.minute.hasLeftFocus = false;
        let moveToPrev = false;
        __privateGet(this, _updateSegment5).call(this, "minute", (prev2) => {
          if (strict_equals(prev2, null)) {
            moveToPrev = true;
            __privateGet(this, _announcer5).announce("Empty");
            return null;
          }
          const str = prev2.toString();
          if (strict_equals(str.length, 1)) {
            __privateGet(this, _announcer5).announce("Empty");
            return null;
          }
          const next3 = Number.parseInt(str.slice(0, -1));
          __privateGet(this, _announcer5).announce(next3);
          return `${next3}`;
        });
        if (moveToPrev) {
          moveToPrevSegment(e, __privateGet(this, _root24).getFieldNode());
        }
        return;
      }
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, __privateGet(this, _root24).getFieldNode());
      }
    });
    __privateAdd(this, _onfocusout5, () => {
      __privateGet(this, _root24).states.minute.hasLeftFocus = true;
    });
    __privateAdd(this, _props83, derived(() => {
      const segmentValues = __privateGet(this, _root24).segmentValues;
      const placeholder = __privateGet(this, _root24).placeholder.current;
      if (!("minute" in segmentValues) || !("minute" in placeholder)) return {};
      const isEmpty = strict_equals(segmentValues.minute, null);
      const date = segmentValues.minute ? placeholder.set({
        minute: Number.parseInt(segmentValues.minute)
      }) : placeholder;
      const valueNow = date.minute;
      const valueMin = 0;
      const valueMax = 59;
      const valueText = isEmpty ? "Empty" : `${valueNow}`;
      return {
        ...__privateGet(this, _root24).sharedSegmentAttrs,
        id: __privateGet(this, _id57).current,
        "aria-label": "minute, ",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: __privateGet(this, _onkeydown22),
        onfocusout: __privateGet(this, _onfocusout5),
        onclick: __privateGet(this, _root24).handleSegmentClick,
        ...__privateGet(this, _root24).getBaseSegmentAttrs("minute", __privateGet(this, _id57).current)
      };
    }));
    __privateSet(this, _id57, props.id);
    __privateSet(this, _ref57, props.ref);
    __privateSet(this, _root24, root17);
    __privateSet(this, _announcer5, __privateGet(this, _root24).announcer);
    __privateSet(this, _updateSegment5, __privateGet(this, _root24).updateSegment);
    useRefById({ id: __privateGet(this, _id57), ref: __privateGet(this, _ref57) });
  }
  get props() {
    return get(__privateGet(this, _props83));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props83)), owner, false);
  }
};
_id57 = new WeakMap();
_ref57 = new WeakMap();
_root24 = new WeakMap();
_announcer5 = new WeakMap();
_updateSegment5 = new WeakMap();
_onkeydown22 = new WeakMap();
_onfocusout5 = new WeakMap();
_props83 = new WeakMap();
var _id58, _ref58, _root25, _announcer6, _updateSegment6, _onkeydown23, _onfocusout6, _props84;
var DateFieldSecondSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id58);
    __privateAdd(this, _ref58);
    __privateAdd(this, _root25);
    __privateAdd(this, _announcer6);
    __privateAdd(this, _updateSegment6);
    __privateAdd(this, _onkeydown23, (e) => {
      const placeholder = __privateGet(this, _root25).placeholder.current;
      if (e.ctrlKey || e.metaKey || __privateGet(this, _root25).disabled.current || !("second" in placeholder)) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (!isAcceptableSegmentKey(e.key)) return;
      const min = 0;
      const max = 59;
      if (isArrowUp(e.key)) {
        __privateGet(this, _updateSegment6).call(this, "second", (prev2) => {
          if (strict_equals(prev2, null)) {
            __privateGet(this, _announcer6).announce(min);
            return `${min}`;
          }
          const next3 = placeholder.set({ second: Number.parseInt(prev2) }).cycle("second", 1).second;
          __privateGet(this, _announcer6).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isArrowDown(e.key)) {
        __privateGet(this, _updateSegment6).call(this, "second", (prev2) => {
          if (strict_equals(prev2, null)) {
            __privateGet(this, _announcer6).announce(max);
            return `${max}`;
          }
          const next3 = placeholder.set({ second: Number.parseInt(prev2) }).cycle("second", -1).second;
          __privateGet(this, _announcer6).announce(next3);
          return `${next3}`;
        });
        return;
      }
      if (isNumberString(e.key)) {
        const num = Number.parseInt(e.key);
        const numIsZero = strict_equals(num, 0);
        let moveToNext = false;
        __privateGet(this, _updateSegment6).call(this, "second", (prev2) => {
          const maxStart = Math.floor(max / 10);
          if (__privateGet(this, _root25).states.second.hasLeftFocus) {
            prev2 = null;
            __privateGet(this, _root25).states.second.hasLeftFocus = false;
          }
          if (strict_equals(prev2, null)) {
            if (numIsZero) {
              __privateGet(this, _root25).states.second.lastKeyZero = true;
              __privateGet(this, _announcer6).announce("0");
              return "0";
            }
            if (__privateGet(this, _root25).states.second.lastKeyZero || num > maxStart) {
              moveToNext = true;
            }
            __privateGet(this, _root25).states.second.lastKeyZero = false;
            if (moveToNext && strict_equals(String(num).length, 1)) {
              __privateGet(this, _announcer6).announce(num);
              return `0${num}`;
            }
            return `${num}`;
          }
          const total = Number.parseInt(prev2 + num.toString());
          if (__privateGet(this, _root25).states.second.lastKeyZero) {
            if (strict_equals(num, 0, false)) {
              moveToNext = true;
              __privateGet(this, _root25).states.second.lastKeyZero = false;
              return `0${num}`;
            }
            moveToNext = true;
            __privateGet(this, _root25).states.second.lastKeyZero = false;
            return "00";
          }
          if (total > max) {
            moveToNext = true;
            return `0${num}`;
          }
          moveToNext = true;
          return `${total}`;
        });
        if (moveToNext) {
          moveToNextSegment(e, __privateGet(this, _root25).getFieldNode());
        }
      }
      if (isBackspace(e.key)) {
        __privateGet(this, _root25).states.second.hasLeftFocus = false;
        let moveToPrev = false;
        __privateGet(this, _updateSegment6).call(this, "second", (prev2) => {
          if (strict_equals(prev2, null)) {
            moveToPrev = true;
            __privateGet(this, _announcer6).announce(null);
            return null;
          }
          const str = prev2.toString();
          if (strict_equals(str.length, 1)) {
            __privateGet(this, _announcer6).announce(null);
            return null;
          }
          const next3 = Number.parseInt(str.slice(0, -1));
          __privateGet(this, _announcer6).announce(next3);
          return `${next3}`;
        });
        if (moveToPrev) {
          moveToPrevSegment(e, __privateGet(this, _root25).getFieldNode());
        }
      }
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, __privateGet(this, _root25).getFieldNode());
      }
    });
    __privateAdd(this, _onfocusout6, () => {
      __privateGet(this, _root25).states.second.hasLeftFocus = true;
    });
    __privateAdd(this, _props84, derived(() => {
      const segmentValues = __privateGet(this, _root25).segmentValues;
      const placeholder = __privateGet(this, _root25).placeholder.current;
      if (!("second" in segmentValues) || !("second" in placeholder)) return {};
      const isEmpty = strict_equals(segmentValues.second, null);
      const date = segmentValues.second ? placeholder.set({
        second: Number.parseInt(segmentValues.second)
      }) : placeholder;
      const valueNow = date.second;
      const valueMin = 0;
      const valueMax = 59;
      const valueText = isEmpty ? "Empty" : `${valueNow}`;
      return {
        ...__privateGet(this, _root25).sharedSegmentAttrs,
        id: __privateGet(this, _id58).current,
        "aria-label": "second, ",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: __privateGet(this, _onkeydown23),
        onfocusout: __privateGet(this, _onfocusout6),
        onclick: __privateGet(this, _root25).handleSegmentClick,
        ...__privateGet(this, _root25).getBaseSegmentAttrs("second", __privateGet(this, _id58).current)
      };
    }));
    __privateSet(this, _id58, props.id);
    __privateSet(this, _ref58, props.ref);
    __privateSet(this, _root25, root17);
    __privateSet(this, _announcer6, __privateGet(this, _root25).announcer);
    __privateSet(this, _updateSegment6, __privateGet(this, _root25).updateSegment);
    useRefById({ id: __privateGet(this, _id58), ref: __privateGet(this, _ref58) });
  }
  get props() {
    return get(__privateGet(this, _props84));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props84)), owner, false);
  }
};
_id58 = new WeakMap();
_ref58 = new WeakMap();
_root25 = new WeakMap();
_announcer6 = new WeakMap();
_updateSegment6 = new WeakMap();
_onkeydown23 = new WeakMap();
_onfocusout6 = new WeakMap();
_props84 = new WeakMap();
var _id59, _ref59, _root26, _announcer7, _updateSegment7, _onkeydown24, _props85;
var DateFieldDayPeriodSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id59);
    __privateAdd(this, _ref59);
    __privateAdd(this, _root26);
    __privateAdd(this, _announcer7);
    __privateAdd(this, _updateSegment7);
    __privateAdd(this, _onkeydown24, (e) => {
      if (e.ctrlKey || e.metaKey || __privateGet(this, _root26).disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (!isAcceptableDayPeriodKey(e.key)) return;
      if (isArrowUp(e.key) || isArrowDown(e.key)) {
        __privateGet(this, _updateSegment7).call(this, "dayPeriod", (prev2) => {
          if (strict_equals(prev2, "AM")) {
            const next4 = "PM";
            __privateGet(this, _announcer7).announce(next4);
            return next4;
          }
          const next3 = "AM";
          __privateGet(this, _announcer7).announce(next3);
          return next3;
        });
        return;
      }
      if (isBackspace(e.key)) {
        __privateGet(this, _root26).states.dayPeriod.hasLeftFocus = false;
        __privateGet(this, _updateSegment7).call(this, "dayPeriod", () => {
          const next3 = "AM";
          __privateGet(this, _announcer7).announce(next3);
          return next3;
        });
      }
      if (strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.P) || kbd_constants_exports.a || kbd_constants_exports.p) {
        __privateGet(this, _updateSegment7).call(this, "dayPeriod", () => {
          const next3 = strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.a) ? "AM" : "PM";
          __privateGet(this, _announcer7).announce(next3);
          return next3;
        });
      }
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, __privateGet(this, _root26).getFieldNode());
      }
    });
    __privateAdd(this, _props85, derived(() => {
      const segmentValues = __privateGet(this, _root26).segmentValues;
      if (!("dayPeriod" in segmentValues)) return;
      const valueMin = 0;
      const valueMax = 12;
      const valueNow = segmentValues.dayPeriod ?? 0;
      const valueText = segmentValues.dayPeriod ?? "AM";
      return {
        ...__privateGet(this, _root26).sharedSegmentAttrs,
        id: __privateGet(this, _id59).current,
        inputmode: "text",
        "aria-label": "AM/PM",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: __privateGet(this, _onkeydown24),
        onclick: __privateGet(this, _root26).handleSegmentClick,
        ...__privateGet(this, _root26).getBaseSegmentAttrs("dayPeriod", __privateGet(this, _id59).current)
      };
    }));
    __privateSet(this, _id59, props.id);
    __privateSet(this, _ref59, props.ref);
    __privateSet(this, _root26, root17);
    __privateSet(this, _announcer7, __privateGet(this, _root26).announcer);
    __privateSet(this, _updateSegment7, __privateGet(this, _root26).updateSegment);
    useRefById({
      id: __privateGet(this, _id59),
      ref: __privateGet(this, _ref59),
      onRefChange: (node) => {
        __privateGet(this, _root26).dayPeriodNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props85));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props85)), owner, false);
  }
};
_id59 = new WeakMap();
_ref59 = new WeakMap();
_root26 = new WeakMap();
_announcer7 = new WeakMap();
_updateSegment7 = new WeakMap();
_onkeydown24 = new WeakMap();
_props85 = new WeakMap();
var _id60, _ref60, _root27, _props86;
var DateFieldDayLiteralSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id60);
    __privateAdd(this, _ref60);
    __privateAdd(this, _root27);
    __privateAdd(this, _props86, derived(() => ({
      id: __privateGet(this, _id60).current,
      "aria-hidden": getAriaHidden(true),
      ...__privateGet(this, _root27).getBaseSegmentAttrs("literal", __privateGet(this, _id60).current)
    })));
    __privateSet(this, _id60, props.id);
    __privateSet(this, _ref60, props.ref);
    __privateSet(this, _root27, root17);
    useRefById({ id: __privateGet(this, _id60), ref: __privateGet(this, _ref60) });
  }
  get props() {
    return get(__privateGet(this, _props86));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props86)), owner, false);
  }
};
_id60 = new WeakMap();
_ref60 = new WeakMap();
_root27 = new WeakMap();
_props86 = new WeakMap();
var _id61, _ref61, _root28, _onkeydown25, _props87;
var DateFieldTimeZoneSegmentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id61);
    __privateAdd(this, _ref61);
    __privateAdd(this, _root28);
    __privateAdd(this, _onkeydown25, (e) => {
      if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
      if (__privateGet(this, _root28).disabled.current) return;
      if (isSegmentNavigationKey(e.key)) {
        handleSegmentNavigation(e, __privateGet(this, _root28).getFieldNode());
      }
    });
    __privateAdd(this, _props87, derived(() => ({
      role: "textbox",
      id: __privateGet(this, _id61).current,
      "aria-label": "timezone, ",
      style: { caretColor: "transparent" },
      onkeydown: __privateGet(this, _onkeydown25),
      tabindex: 0,
      ...__privateGet(this, _root28).getBaseSegmentAttrs("timeZoneName", __privateGet(this, _id61).current),
      "data-readonly": getDataReadonly(true)
    })));
    __privateSet(this, _id61, props.id);
    __privateSet(this, _ref61, props.ref);
    __privateSet(this, _root28, root17);
    useRefById({ id: __privateGet(this, _id61), ref: __privateGet(this, _ref61) });
  }
  get props() {
    return get(__privateGet(this, _props87));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props87)), owner, false);
  }
};
_id61 = new WeakMap();
_ref61 = new WeakMap();
_root28 = new WeakMap();
_onkeydown25 = new WeakMap();
_props87 = new WeakMap();
function isAcceptableDayPeriodKey(key) {
  return isAcceptableSegmentKey(key) || strict_equals(key, kbd_constants_exports.A) || strict_equals(key, kbd_constants_exports.P) || strict_equals(key, kbd_constants_exports.a) || strict_equals(key, kbd_constants_exports.p);
}
function isArrowUp(key) {
  return strict_equals(key, kbd_constants_exports.ARROW_UP);
}
function isArrowDown(key) {
  return strict_equals(key, kbd_constants_exports.ARROW_DOWN);
}
function isBackspace(key) {
  return strict_equals(key, kbd_constants_exports.BACKSPACE);
}
var [
  setDateFieldRootContext,
  getDateFieldRootContext
] = createContext("DateField.Root");
function useDateFieldRoot(props, rangeRoot) {
  return setDateFieldRootContext(new DateFieldRootState(props, rangeRoot));
}
function useDateFieldInput(props) {
  const root17 = getDateFieldRootContext();
  return new DateFieldInputState(props, root17);
}
function useDateFieldHiddenInput() {
  const root17 = getDateFieldRootContext();
  return new DateFieldHiddenInputState(root17);
}
function useDateFieldSegment(part, props) {
  const root17 = getDateFieldRootContext();
  return segmentPartToInstance({ part, segmentProps: props, root: root17 });
}
function useDateFieldLabel(props) {
  const root17 = getDateFieldRootContext();
  return new DateFieldLabelState(props, root17);
}
function segmentPartToInstance(props) {
  switch (props.part) {
    case "day":
      return new DateFieldDaySegmentState(props.segmentProps, props.root);
    case "month":
      return new DateFieldMonthSegmentState(props.segmentProps, props.root);
    case "year":
      return new DateFieldYearSegmentState(props.segmentProps, props.root);
    case "hour":
      return new DateFieldHourSegmentState(props.segmentProps, props.root);
    case "minute":
      return new DateFieldMinuteSegmentState(props.segmentProps, props.root);
    case "second":
      return new DateFieldSecondSegmentState(props.segmentProps, props.root);
    case "dayPeriod":
      return new DateFieldDayPeriodSegmentState(props.segmentProps, props.root);
    case "literal":
      return new DateFieldDayLiteralSegmentState(props.segmentProps, props.root);
    case "timeZoneName":
      return new DateFieldTimeZoneSegmentState(props.segmentProps, props.root);
  }
}
function prependYearZeros(year) {
  const digits = String(year).length;
  const diff = 4 - digits;
  return `${"0".repeat(diff)}${year}`;
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte
mark_module_start();
Date_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte";
function Date_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_field);
  validate_prop_bindings($$props, ["placeholder", "value"], [], Date_field);
  let disabled = prop($$props, "disabled", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), locale = prop($$props, "locale", 3, "en"), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop2), onValueChange = prop($$props, "onValueChange", 3, noop2), validate = prop($$props, "validate", 3, noop2), onInvalid = prop($$props, "onInvalid", 3, noop2), placeholder = prop($$props, "placeholder", 15), value = prop($$props, "value", 15), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), required = prop($$props, "required", 3, false), controlledPlaceholder = prop($$props, "controlledPlaceholder", 3, false), controlledValue = prop($$props, "controlledValue", 3, false);
  if (strict_equals(placeholder(), void 0)) {
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultPlaceholder: void 0,
      defaultValue: value()
    });
    if (controlledPlaceholder()) {
      onPlaceholderChange()(defaultPlaceholder);
    } else {
      placeholder(defaultPlaceholder);
    }
  }
  useDateFieldRoot({
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      if (controlledPlaceholder()) {
        onPlaceholderChange()(v);
      } else {
        placeholder(v);
        onPlaceholderChange()(v);
      }
    }),
    disabled: box.with(() => disabled()),
    granularity: box.with(() => $$props.granularity),
    hideTimeZone: box.with(() => hideTimeZone()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: box.with(() => locale()),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    validate: box.with(() => validate()),
    readonly: box.with(() => readonly()),
    readonlySegments: box.with(() => readonlySegments()),
    required: box.with(() => required()),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field = hmr(Date_field, () => Date_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field[HMR].source;
    set(Date_field[HMR].source, module.default[HMR].original);
  });
}
var date_field_default = Date_field;
mark_module_end(Date_field);

// node_modules/bits-ui/dist/bits/date-field/components/date-field-hidden-input.svelte
mark_module_start();
Date_field_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-hidden-input.svelte";
var root_257 = add_locations(template(`<input>`), Date_field_hidden_input[FILENAME], [[11, 3]]);
function Date_field_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_field_hidden_input);
  const hiddenInputState = useDateFieldHiddenInput();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => hiddenInputState.shouldRender, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    {
      const child2 = wrap_snippet(Date_field_hidden_input, ($$anchor3, $$arg0) => {
        let props = () => $$arg0 == null ? void 0 : $$arg0().props;
        props();
        var input = root_257();
        remove_input_defaults(input);
        let attributes;
        template_effect(() => attributes = set_attributes(input, attributes, { ...props(), ...hiddenInputState.props }));
        append($$anchor3, input);
      });
      visually_hidden_default(node_1, { child: child2, $$slots: { child: true } });
    }
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_hidden_input = hmr(Date_field_hidden_input, () => Date_field_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_hidden_input[HMR].source;
    set(Date_field_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var date_field_hidden_input_default = Date_field_hidden_input;
mark_module_end(Date_field_hidden_input);

// node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte
mark_module_start();
Date_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte";
var root_258 = add_locations(template(`<div><!></div>`), Date_field_input[FILENAME], [[32, 1]]);
var root8 = add_locations(template(`<!> <!>`, 1), Date_field_input[FILENAME], []);
function Date_field_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_field_input);
  validate_prop_bindings($$props, ["ref"], [], Date_field_input);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "children",
      "child"
    ],
    "restProps"
  );
  const inputState = useDateFieldInput({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    name: box.with(() => name())
  });
  const mergedProps = derived(() => mergeProps(restProps, inputState.props));
  var fragment = root8();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_258();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  var node_3 = sibling(node, 2);
  date_field_hidden_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_input = hmr(Date_field_input, () => Date_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_input[HMR].source;
    set(Date_field_input[HMR].source, module.default[HMR].original);
  });
}
var date_field_input_default = Date_field_input;
mark_module_end(Date_field_input);

// node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte
mark_module_start();
Date_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte";
var root_259 = add_locations(template(`<div><!></div>`), Date_field_label[FILENAME], [[29, 1]]);
function Date_field_label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_field_label);
  validate_prop_bindings($$props, ["ref"], [], Date_field_label);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = useDateFieldLabel({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, labelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_259();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_label = hmr(Date_field_label, () => Date_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_label[HMR].source;
    set(Date_field_label[HMR].source, module.default[HMR].original);
  });
}
var date_field_label_default = Date_field_label;
mark_module_end(Date_field_label);

// node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte
mark_module_start();
Date_field_segment[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte";
var root_260 = add_locations(template(`<span><!></span>`), Date_field_segment[FILENAME], [[32, 1]]);
function Date_field_segment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_field_segment);
  validate_prop_bindings($$props, ["ref"], [], Date_field_segment);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "part"
    ],
    "restProps"
  );
  const segmentState = useDateFieldSegment($$props.part, {
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, segmentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_260();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_segment = hmr(Date_field_segment, () => Date_field_segment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_segment[HMR].source;
    set(Date_field_segment[HMR].source, module.default[HMR].original);
  });
}
var date_field_segment_default = Date_field_segment;
mark_module_end(Date_field_segment);

// node_modules/bits-ui/dist/bits/date-picker/exports.js
var exports_exports13 = {};
__export(exports_exports13, {
  Arrow: () => popover_arrow_default,
  Calendar: () => date_picker_calendar_default,
  Cell: () => calendar_cell_default,
  Close: () => popover_close_default,
  Content: () => date_picker_content_default,
  ContentStatic: () => date_picker_content_static_default,
  Day: () => calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  Input: () => date_field_input_default,
  Label: () => date_field_label_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => date_picker_default,
  Segment: () => date_field_segment_default,
  Trigger: () => date_picker_trigger_default
});

// node_modules/bits-ui/dist/bits/date-picker/date-picker.svelte.js
var DatePickerRootState = class {
  constructor(props) {
    __publicField(this, "props");
    this.props = props;
  }
};
var [
  setDatePickerRootContext,
  getDatePickerRootContext
] = createContext("DatePicker.Root");
function useDatePickerRoot(props) {
  return setDatePickerRootContext(new DatePickerRootState(props));
}

// node_modules/bits-ui/dist/bits/popover/popover.svelte.js
var _contentNode5, _contentId3, _triggerNode4;
var PopoverRootState = class {
  constructor(props) {
    __publicField(this, "open");
    __privateAdd(this, _contentNode5, state(null));
    __privateAdd(this, _contentId3, state(void 0));
    __privateAdd(this, _triggerNode4, state(null));
    __publicField(this, "toggleOpen", () => {
      this.open.current = !this.open.current;
    });
    __publicField(this, "close", () => {
      if (!this.open.current) return;
      this.open.current = false;
    });
    this.open = props.open;
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode5));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode5), proxy(value, null, __privateGet(this, _contentNode5)));
  }
  get contentId() {
    return get(__privateGet(this, _contentId3));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId3), proxy(value, null, __privateGet(this, _contentId3)));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode4));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode4), proxy(value, null, __privateGet(this, _triggerNode4)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _contentNode5)), owner, false);
    add_owner(get(__privateGet(this, _contentId3)), owner, false);
    add_owner(get(__privateGet(this, _triggerNode4)), owner, false);
  }
};
_contentNode5 = new WeakMap();
_contentId3 = new WeakMap();
_triggerNode4 = new WeakMap();
var _id62, _ref62, _disabled10, _root29, _onpointerdown13, _onpointerup8, _onkeydown26, _getAriaControls, _props88;
var PopoverTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _id62);
    __privateAdd(this, _ref62);
    __privateAdd(this, _disabled10);
    __privateAdd(this, _root29);
    __privateAdd(this, _onpointerdown13, (e) => {
      if (__privateGet(this, _disabled10).current) return;
      if (strict_equals(e.pointerType, "touch") || strict_equals(e.button, 0, false)) return e.preventDefault();
      __privateGet(this, _root29).toggleOpen();
    });
    __privateAdd(this, _onpointerup8, (e) => {
      if (__privateGet(this, _disabled10).current) return;
      if (strict_equals(e.pointerType, "touch")) {
        e.preventDefault();
        __privateGet(this, _root29).toggleOpen();
      }
    });
    __privateAdd(this, _onkeydown26, (e) => {
      if (__privateGet(this, _disabled10).current) return;
      if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE))) return;
      e.preventDefault();
      __privateGet(this, _root29).toggleOpen();
    });
    __privateAdd(this, _getAriaControls, () => {
      if (__privateGet(this, _root29).open.current && __privateGet(this, _root29).contentId) {
        return __privateGet(this, _root29).contentId;
      }
      return void 0;
    });
    __privateAdd(this, _props88, derived(() => ({
      id: __privateGet(this, _id62).current,
      "aria-haspopup": "dialog",
      "aria-expanded": getAriaExpanded(__privateGet(this, _root29).open.current),
      "data-state": getDataOpenClosed(__privateGet(this, _root29).open.current),
      "aria-controls": __privateGet(this, _getAriaControls).call(this),
      "data-popover-trigger": "",
      disabled: __privateGet(this, _disabled10).current,
      //
      onpointerdown: __privateGet(this, _onpointerdown13),
      onkeydown: __privateGet(this, _onkeydown26),
      onpointerup: __privateGet(this, _onpointerup8)
    })));
    __privateSet(this, _id62, props.id);
    __privateSet(this, _root29, root17);
    __privateSet(this, _ref62, props.ref);
    __privateSet(this, _disabled10, props.disabled);
    useRefById({
      id: __privateGet(this, _id62),
      ref: __privateGet(this, _ref62),
      onRefChange: (node) => {
        __privateGet(this, _root29).triggerNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props88));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props88)), owner, false);
  }
};
_id62 = new WeakMap();
_ref62 = new WeakMap();
_disabled10 = new WeakMap();
_root29 = new WeakMap();
_onpointerdown13 = new WeakMap();
_onpointerup8 = new WeakMap();
_onkeydown26 = new WeakMap();
_getAriaControls = new WeakMap();
_props88 = new WeakMap();
var _id63, _ref63, _snippetProps13, _props89;
var PopoverContentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id63);
    __privateAdd(this, _ref63);
    __publicField(this, "root");
    __privateAdd(this, _snippetProps13, derived(() => ({ open: this.root.open.current })));
    __privateAdd(this, _props89, derived(() => ({
      id: __privateGet(this, _id63).current,
      tabindex: -1,
      "data-state": getDataOpenClosed(this.root.open.current),
      "data-popover-content": "",
      style: { pointerEvents: "auto" }
    })));
    __privateSet(this, _id63, props.id);
    this.root = root17;
    __privateSet(this, _ref63, props.ref);
    useRefById({
      id: __privateGet(this, _id63),
      ref: __privateGet(this, _ref63),
      deps: () => this.root.open.current,
      onRefChange: (node) => {
        this.root.contentNode = node;
        this.root.contentId = node == null ? void 0 : node.id;
      }
    });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps13));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props89));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps13)), owner, false);
    add_owner(get(__privateGet(this, _props89)), owner, false);
  }
};
_id63 = new WeakMap();
_ref63 = new WeakMap();
_snippetProps13 = new WeakMap();
_props89 = new WeakMap();
var _id64, _ref64, _root30, _onpointerdown14, _onpointerup9, _onkeydown27, _props90;
var PopoverCloseState = class {
  constructor(props, root17) {
    __privateAdd(this, _id64);
    __privateAdd(this, _ref64);
    __privateAdd(this, _root30);
    __privateAdd(this, _onpointerdown14, (e) => {
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      __privateGet(this, _root30).close();
    });
    __privateAdd(this, _onpointerup9, (e) => {
      e.preventDefault();
      if (strict_equals(e.pointerType, "touch")) {
        __privateGet(this, _root30).close();
      }
    });
    __privateAdd(this, _onkeydown27, (e) => {
      if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE))) return;
      e.preventDefault();
      __privateGet(this, _root30).close();
    });
    __privateAdd(this, _props90, derived(() => ({
      id: __privateGet(this, _id64).current,
      onclick: __privateGet(this, _onpointerdown14),
      onkeydown: __privateGet(this, _onkeydown27),
      type: "button",
      "data-popover-close": ""
    })));
    __privateSet(this, _root30, root17);
    __privateSet(this, _id64, props.id);
    __privateSet(this, _ref64, props.ref);
    useRefById({
      id: __privateGet(this, _id64),
      ref: __privateGet(this, _ref64),
      deps: () => __privateGet(this, _root30).open.current
    });
  }
  get props() {
    return get(__privateGet(this, _props90));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props90)), owner, false);
  }
};
_id64 = new WeakMap();
_ref64 = new WeakMap();
_root30 = new WeakMap();
_onpointerdown14 = new WeakMap();
_onpointerup9 = new WeakMap();
_onkeydown27 = new WeakMap();
_props90 = new WeakMap();
var [setPopoverRootContext, getPopoverRootContext] = createContext("Popover.Root");
function usePopoverRoot(props) {
  return setPopoverRootContext(new PopoverRootState(props));
}
function usePopoverTrigger(props) {
  return new PopoverTriggerState(props, getPopoverRootContext());
}
function usePopoverContent(props) {
  return new PopoverContentState(props, getPopoverRootContext());
}
function usePopoverClose(props) {
  return new PopoverCloseState(props, getPopoverRootContext());
}

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte
mark_module_start();
Date_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte";
function Date_picker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker);
  validate_prop_bindings($$props, ["open", "value", "placeholder"], [], Date_picker);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop2), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), validate = prop($$props, "validate", 3, noop2), onInvalid = prop($$props, "onInvalid", 3, noop2), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), locale = prop($$props, "locale", 3, "en"), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekStartsOn = prop($$props, "weekStartsOn", 3, 0), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnDateSelect = prop($$props, "closeOnDateSelect", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), controlledPlaceholder = prop($$props, "controlledPlaceholder", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), controlledOpen = prop($$props, "controlledOpen", 3, false);
  if (strict_equals(placeholder(), void 0)) {
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultPlaceholder: void 0,
      defaultValue: value()
    });
    if (controlledPlaceholder()) {
      onPlaceholderChange()(defaultPlaceholder);
    } else {
      placeholder(defaultPlaceholder);
    }
  }
  function onDateSelect() {
    if (closeOnDateSelect()) {
      if (controlledOpen()) {
        onOpenChange()(false);
      } else {
        open(false);
      }
    }
  }
  const pickerRootState = useDatePickerRoot({
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    }),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      if (controlledPlaceholder()) {
        onPlaceholderChange()(v);
      } else {
        placeholder(v);
        onPlaceholderChange()(v);
      }
    }),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    minValue: box.with(() => $$props.minValue),
    maxValue: box.with(() => $$props.maxValue),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    granularity: box.with(() => $$props.granularity),
    readonlySegments: box.with(() => readonlySegments()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: box.with(() => locale()),
    hideTimeZone: box.with(() => hideTimeZone()),
    required: box.with(() => required()),
    calendarLabel: box.with(() => calendarLabel()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    preventDeselect: box.with(() => preventDeselect()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => weekStartsOn()),
    weekdayFormat: box.with(() => weekdayFormat()),
    isDateDisabled: box.with(() => isDateDisabled()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    initialFocus: box.with(() => initialFocus()),
    onDateSelect: box.with(() => onDateSelect)
  });
  usePopoverRoot({ open: pickerRootState.props.open });
  useDateFieldRoot({
    value: pickerRootState.props.value,
    disabled: pickerRootState.props.disabled,
    readonly: pickerRootState.props.readonly,
    readonlySegments: pickerRootState.props.readonlySegments,
    validate: box.with(() => validate()),
    onInvalid: box.with(() => onInvalid()),
    minValue: pickerRootState.props.minValue,
    maxValue: pickerRootState.props.maxValue,
    granularity: pickerRootState.props.granularity,
    hideTimeZone: pickerRootState.props.hideTimeZone,
    hourCycle: pickerRootState.props.hourCycle,
    locale: pickerRootState.props.locale,
    required: pickerRootState.props.required,
    placeholder: pickerRootState.props.placeholder,
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Root, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      children: wrap_snippet(Date_picker, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop);
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker = hmr(Date_picker, () => Date_picker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker[HMR].source;
    set(Date_picker[HMR].source, module.default[HMR].original);
  });
}
var date_picker_default = Date_picker;
mark_module_end(Date_picker);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte
mark_module_start();
Date_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte";
var root_261 = add_locations(template(`<div><!></div>`), Date_picker_calendar[FILENAME], [[52, 1]]);
function Date_picker_calendar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_calendar);
  validate_prop_bindings($$props, ["ref"], [], Date_picker_calendar);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const datePickerRootState = getDatePickerRootContext();
  const calendarState = useCalendarRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    calendarLabel: datePickerRootState.props.calendarLabel,
    fixedWeeks: datePickerRootState.props.fixedWeeks,
    isDateDisabled: datePickerRootState.props.isDateDisabled,
    isDateUnavailable: datePickerRootState.props.isDateUnavailable,
    locale: datePickerRootState.props.locale,
    numberOfMonths: datePickerRootState.props.numberOfMonths,
    pagedNavigation: datePickerRootState.props.pagedNavigation,
    preventDeselect: datePickerRootState.props.preventDeselect,
    readonly: datePickerRootState.props.readonly,
    type: box.with(() => "single"),
    weekStartsOn: datePickerRootState.props.weekStartsOn,
    weekdayFormat: datePickerRootState.props.weekdayFormat,
    disabled: datePickerRootState.props.disabled,
    disableDaysOutsideMonth: datePickerRootState.props.disableDaysOutsideMonth,
    maxValue: datePickerRootState.props.maxValue,
    minValue: datePickerRootState.props.minValue,
    placeholder: datePickerRootState.props.placeholder,
    value: datePickerRootState.props.value,
    onDateSelect: datePickerRootState.props.onDateSelect,
    initialFocus: datePickerRootState.props.initialFocus
  });
  const mergedProps = derived(() => mergeProps(restProps, calendarState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...calendarState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_261();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => calendarState.snippetProps);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_calendar = hmr(Date_picker_calendar, () => Date_picker_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_calendar[HMR].source;
    set(Date_picker_calendar[HMR].source, module.default[HMR].original);
  });
}
var date_picker_calendar_default = Date_picker_calendar;
mark_module_end(Date_picker_calendar);

// node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte
mark_module_start();
Popover_content[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte";
var root_411 = add_locations(template(`<div><!></div>`), Popover_content[FILENAME], [[75, 4]]);
var root_97 = add_locations(template(`<div><!></div>`), Popover_content[FILENAME], [[101, 4]]);
function Popover_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover_content);
  validate_prop_bindings($$props, ["ref"], [], Popover_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = usePopoverContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.root.close();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.root.close();
  }
  function handleCloseAutoFocus(e) {
    var _a;
    onCloseAutoFocus()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
    (_a = contentState.root.triggerNode) == null ? void 0 : _a.focus();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Popover_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("popover")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_411();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.root.open.current;
          },
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onCloseAutoFocus: handleCloseAutoFocus,
          get trapFocus() {
            return trapFocus();
          },
          get preventScroll() {
            return preventScroll();
          },
          loop: true,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Popover_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = comment();
              const finalProps = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("popover")
              }));
              get(finalProps);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_97();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.root.open.current;
              },
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onCloseAutoFocus: handleCloseAutoFocus,
              get trapFocus() {
                return trapFocus();
              },
              get preventScroll() {
                return preventScroll();
              },
              loop: true,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_content = hmr(Popover_content, () => Popover_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_content[HMR].source;
    set(Popover_content[HMR].source, module.default[HMR].original);
  });
}
var popover_content_default = Popover_content;
mark_module_end(Popover_content);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte
mark_module_start();
Date_picker_content[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte";
function Date_picker_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_content);
  validate_prop_bindings($$props, ["ref"], [], Date_picker_content);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const mergedProps = derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, popover_content_default);
    popover_content_default(node, spread_props(
      () => get(mergedProps),
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      },
      () => restProps
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_content = hmr(Date_picker_content, () => Date_picker_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_content[HMR].source;
    set(Date_picker_content[HMR].source, module.default[HMR].original);
  });
}
var date_picker_content_default = Date_picker_content;
mark_module_end(Date_picker_content);

// node_modules/bits-ui/dist/bits/popover/components/popover-content-static.svelte
mark_module_start();
Popover_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-content-static.svelte";
var root_412 = add_locations(template(`<div><!></div>`), Popover_content_static[FILENAME], [[76, 4]]);
var root_98 = add_locations(template(`<div><!></div>`), Popover_content_static[FILENAME], [[103, 4]]);
function Popover_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover_content_static);
  validate_prop_bindings($$props, ["ref"], [], Popover_content_static);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = usePopoverContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.root.close();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.root.close();
  }
  function handleCloseAutoFocus(e) {
    var _a;
    onCloseAutoFocus()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
    (_a = contentState.root.triggerNode) == null ? void 0 : _a.focus();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Popover_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("popover")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_412();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          isStatic: true,
          get enabled() {
            return contentState.root.open.current;
          },
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onCloseAutoFocus: handleCloseAutoFocus,
          get trapFocus() {
            return trapFocus();
          },
          get preventScroll() {
            return preventScroll();
          },
          loop: true,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Popover_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = comment();
              const finalProps = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("popover")
              }));
              get(finalProps);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_98();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              isStatic: true,
              get present() {
                return contentState.root.open.current;
              },
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onCloseAutoFocus: handleCloseAutoFocus,
              get trapFocus() {
                return trapFocus();
              },
              get preventScroll() {
                return preventScroll();
              },
              loop: true,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_content_static = hmr(Popover_content_static, () => Popover_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_content_static[HMR].source;
    set(Popover_content_static[HMR].source, module.default[HMR].original);
  });
}
var popover_content_static_default = Popover_content_static;
mark_module_end(Popover_content_static);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content-static.svelte
mark_module_start();
Date_picker_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content-static.svelte";
function Date_picker_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_content_static);
  validate_prop_bindings($$props, ["ref"], [], Date_picker_content_static);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const mergedProps = derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, popover_content_static_default);
    popover_content_static_default(node, spread_props(
      () => get(mergedProps),
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      },
      () => restProps
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_content_static = hmr(Date_picker_content_static, () => Date_picker_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_content_static[HMR].source;
    set(Date_picker_content_static[HMR].source, module.default[HMR].original);
  });
}
var date_picker_content_static_default = Date_picker_content_static;
mark_module_end(Date_picker_content_static);

// node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte
mark_module_start();
Popover_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte";
var root_312 = add_locations(template(`<button><!></button>`), Popover_trigger[FILENAME], [[34, 2]]);
function Popover_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover_trigger);
  validate_prop_bindings($$props, ["ref"], [], Popover_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = usePopoverTrigger({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    children: wrap_snippet(Popover_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var button = root_312();
          let attributes;
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
          append($$anchor3, button);
        }
      );
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_trigger = hmr(Popover_trigger, () => Popover_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_trigger[HMR].source;
    set(Popover_trigger[HMR].source, module.default[HMR].original);
  });
}
var popover_trigger_default = Popover_trigger;
mark_module_end(Popover_trigger);

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte
mark_module_start();
Date_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte";
function Date_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_trigger);
  validate_prop_bindings($$props, ["ref"], [], Date_picker_trigger);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onkeydown"
    ],
    "restProps"
  );
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(`[${DATE_FIELD_INPUT_ATTR}]`);
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, popover_trigger_default);
    popover_trigger_default(node, spread_props(
      () => restProps,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        "data-segment": "trigger"
      },
      () => get(mergedProps)
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_trigger = hmr(Date_picker_trigger, () => Date_picker_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_trigger[HMR].source;
    set(Date_picker_trigger[HMR].source, module.default[HMR].original);
  });
}
var date_picker_trigger_default = Date_picker_trigger;
mark_module_end(Date_picker_trigger);

// node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte
mark_module_start();
Popover_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte";
function Popover_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover_arrow);
  validate_prop_bindings($$props, ["ref"], [], Popover_arrow);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, floating_layer_arrow_default);
    floating_layer_arrow_default(node, spread_props(
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      },
      () => restProps,
      { "data-popover-arrow": "" }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_arrow = hmr(Popover_arrow, () => Popover_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_arrow[HMR].source;
    set(Popover_arrow[HMR].source, module.default[HMR].original);
  });
}
var popover_arrow_default = Popover_arrow;
mark_module_end(Popover_arrow);

// node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte
mark_module_start();
Popover_close[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte";
var root_262 = add_locations(template(`<button><!></button>`), Popover_close[FILENAME], [[28, 1]]);
function Popover_close($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover_close);
  validate_prop_bindings($$props, ["ref"], [], Popover_close);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const closeState = usePopoverClose({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, closeState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_262();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_close = hmr(Popover_close, () => Popover_close[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_close[HMR].source;
    set(Popover_close[HMR].source, module.default[HMR].original);
  });
}
var popover_close_default = Popover_close;
mark_module_end(Popover_close);

// node_modules/bits-ui/dist/bits/date-range-field/exports.js
var exports_exports14 = {};
__export(exports_exports14, {
  Input: () => date_range_field_input_default,
  Label: () => date_range_field_label_default,
  Root: () => date_range_field_default,
  Segment: () => date_field_segment_default
});

// node_modules/bits-ui/dist/bits/date-range-field/date-range-field.svelte.js
var DATE_RANGE_FIELD_ROOT_ATTR = "data-date-range-field-root";
var DATE_RANGE_FIELD_LABEL_ATTR = "data-date-range-field-label";
var _fieldNode2, _labelNode4, _descriptionNode3, _startValueComplete, _endValueComplete, _rangeComplete, _mergedValues, _validationStatus2, _isInvalid3, _props91;
var DateRangeFieldRootState = class {
  constructor(props) {
    __publicField(this, "ref");
    __publicField(this, "id");
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "readonlySegments");
    __publicField(this, "validate");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "readonly");
    __publicField(this, "granularity");
    __publicField(this, "hourCycle");
    __publicField(this, "locale");
    __publicField(this, "hideTimeZone");
    __publicField(this, "required");
    __publicField(this, "startValue");
    __publicField(this, "endValue");
    __publicField(this, "onInvalid");
    __publicField(this, "errorMessageId");
    __publicField(this, "startFieldState");
    __publicField(this, "endFieldState");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __privateAdd(this, _fieldNode2, state(null));
    __privateAdd(this, _labelNode4, state(null));
    __privateAdd(this, _descriptionNode3, state(null));
    __privateAdd(this, _startValueComplete, derived(() => strict_equals(this.startValue.current, void 0, false)));
    __privateAdd(this, _endValueComplete, derived(() => strict_equals(this.endValue.current, void 0, false)));
    __privateAdd(this, _rangeComplete, derived(() => this.startValueComplete && this.endValueComplete));
    __privateAdd(this, _mergedValues, derived(() => {
      if (strict_equals(this.startValue.current, void 0) || strict_equals(this.endValue.current, void 0)) {
        return { start: void 0, end: void 0 };
      } else {
        return {
          start: this.startValue.current,
          end: this.endValue.current
        };
      }
    }));
    __privateAdd(this, _validationStatus2, derived(() => {
      var _a, _b;
      const value = this.value.current;
      if (strict_equals(value, void 0)) return false;
      if (strict_equals(value.start, void 0) || strict_equals(value.end, void 0)) return false;
      const msg = (_b = (_a = this.validate).current) == null ? void 0 : _b.call(_a, { start: value.start, end: value.end });
      if (msg) {
        return { reason: "custom", message: msg };
      }
      const minValue = this.minValue.current;
      if (minValue && value.start && isBefore(value.start, minValue)) {
        return { reason: "min" };
      }
      const maxValue = this.maxValue.current;
      if (maxValue && value.end && isBefore(maxValue, value.end) || maxValue && value.start && isBefore(maxValue, value.start)) {
        return { reason: "max" };
      }
      return false;
    }));
    __privateAdd(this, _isInvalid3, derived(() => {
      if (strict_equals(this.validationStatus, false)) return false;
      return true;
    }));
    __publicField(this, "setStartValue", (value) => {
      this.startValue.current = value;
    });
    __publicField(this, "setEndValue", (value) => {
      this.endValue.current = value;
    });
    /**
     * These props are used to override those of the child fields.
     * TODO:
     */
    __publicField(this, "childFieldPropOverrides", {});
    __privateAdd(this, _props91, derived(() => ({
      id: this.id.current,
      role: "group",
      [DATE_RANGE_FIELD_ROOT_ATTR]: "",
      "data-invalid": getDataInvalid(this.isInvalid)
    })));
    this.value = props.value;
    this.startValue = props.startValue;
    this.endValue = props.endValue;
    this.placeholder = props.placeholder;
    this.validate = props.validate;
    this.onInvalid = props.onInvalid;
    this.minValue = props.minValue;
    this.maxValue = props.maxValue;
    this.disabled = props.disabled;
    this.readonly = props.readonly;
    this.granularity = props.granularity;
    this.readonlySegments = props.readonlySegments;
    this.hourCycle = props.hourCycle;
    this.locale = props.locale;
    this.hideTimeZone = props.hideTimeZone;
    this.required = props.required;
    this.errorMessageId = props.errorMessageId;
    this.formatter = createFormatter(this.locale.current);
    this.id = props.id;
    this.ref = props.ref;
    useRefById({
      id: this.id,
      ref: this.ref,
      onRefChange: (node) => {
        this.fieldNode = node;
      }
    });
    onDestroyEffect(() => {
      removeDescriptionElement(this.descriptionId);
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      const startValue = this.value.current.start;
      untrack(() => {
        if (startValue) this.placeholder.current = startValue;
      });
    });
    user_effect(() => {
      const endValue = this.value.current.end;
      untrack(() => {
        if (endValue) this.placeholder.current = endValue;
      });
    });
    user_effect(() => {
      const value = this.value.current;
      untrack(() => {
        if (strict_equals(value.start, void 0, false) && strict_equals(value.start, this.startValue.current, false)) {
          this.setStartValue(value.start);
        }
        if (strict_equals(value.end, void 0, false) && strict_equals(value.end, this.endValue.current, false)) {
          this.setEndValue(value.end);
        }
      });
    });
    user_effect(() => {
      const placeholder = untrack(() => this.placeholder.current);
      const startValue = untrack(() => this.startValue.current);
      if (this.startValueComplete && strict_equals(placeholder, startValue, false)) {
        untrack(() => {
          if (startValue) {
            this.placeholder.current = startValue;
          }
        });
      }
    });
    user_effect(() => {
      this.value.current = this.mergedValues;
    });
  }
  get fieldNode() {
    return get(__privateGet(this, _fieldNode2));
  }
  set fieldNode(value) {
    set(__privateGet(this, _fieldNode2), proxy(value, null, __privateGet(this, _fieldNode2)));
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode4));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode4), proxy(value, null, __privateGet(this, _labelNode4)));
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode3));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode3), proxy(value, null, __privateGet(this, _descriptionNode3)));
  }
  get startValueComplete() {
    return get(__privateGet(this, _startValueComplete));
  }
  set startValueComplete(_) {
    throw new Error("Cannot update a derived property ('startValueComplete')");
  }
  get endValueComplete() {
    return get(__privateGet(this, _endValueComplete));
  }
  set endValueComplete(_) {
    throw new Error("Cannot update a derived property ('endValueComplete')");
  }
  get rangeComplete() {
    return get(__privateGet(this, _rangeComplete));
  }
  set rangeComplete(_) {
    throw new Error("Cannot update a derived property ('rangeComplete')");
  }
  get mergedValues() {
    return get(__privateGet(this, _mergedValues));
  }
  set mergedValues(_) {
    throw new Error("Cannot update a derived property ('mergedValues')");
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus2));
  }
  set validationStatus(_) {
    throw new Error("Cannot update a derived property ('validationStatus')");
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid3));
  }
  set isInvalid(_) {
    throw new Error("Cannot update a derived property ('isInvalid')");
  }
  get props() {
    return get(__privateGet(this, _props91));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _fieldNode2)), owner, false);
    add_owner(get(__privateGet(this, _labelNode4)), owner, false);
    add_owner(get(__privateGet(this, _descriptionNode3)), owner, false);
    add_owner(get(__privateGet(this, _startValueComplete)), owner, false);
    add_owner(get(__privateGet(this, _endValueComplete)), owner, false);
    add_owner(get(__privateGet(this, _rangeComplete)), owner, false);
    add_owner(get(__privateGet(this, _mergedValues)), owner, false);
    add_owner(get(__privateGet(this, _validationStatus2)), owner, false);
    add_owner(get(__privateGet(this, _isInvalid3)), owner, false);
    add_owner(get(__privateGet(this, _props91)), owner, false);
  }
};
_fieldNode2 = new WeakMap();
_labelNode4 = new WeakMap();
_descriptionNode3 = new WeakMap();
_startValueComplete = new WeakMap();
_endValueComplete = new WeakMap();
_rangeComplete = new WeakMap();
_mergedValues = new WeakMap();
_validationStatus2 = new WeakMap();
_isInvalid3 = new WeakMap();
_props91 = new WeakMap();
var _id65, _ref65, _root31, _onclick13, _props92;
var DateRangeFieldLabelState = class {
  constructor(props, root17) {
    __privateAdd(this, _id65);
    __privateAdd(this, _ref65);
    __privateAdd(this, _root31);
    __privateAdd(this, _onclick13, () => {
      if (__privateGet(this, _root31).disabled.current) return;
      const firstSegment = getFirstSegment(__privateGet(this, _root31).fieldNode);
      if (!firstSegment) return;
      firstSegment.focus();
    });
    __privateAdd(this, _props92, derived(() => ({
      id: __privateGet(this, _id65).current,
      // TODO: invalid state for field
      "data-invalid": getDataInvalid(__privateGet(this, _root31).isInvalid),
      "data-disabled": getDataDisabled(__privateGet(this, _root31).disabled.current),
      [DATE_RANGE_FIELD_LABEL_ATTR]: "",
      onclick: __privateGet(this, _onclick13)
    })));
    __privateSet(this, _id65, props.id);
    __privateSet(this, _ref65, props.ref);
    __privateSet(this, _root31, root17);
    useRefById({
      id: __privateGet(this, _id65),
      ref: __privateGet(this, _ref65),
      onRefChange: (node) => {
        __privateGet(this, _root31).labelNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props92));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props92)), owner, false);
  }
};
_id65 = new WeakMap();
_ref65 = new WeakMap();
_root31 = new WeakMap();
_onclick13 = new WeakMap();
_props92 = new WeakMap();
var [
  setDateRangeFieldRootContext,
  getDateRangeFieldRootContext
] = createContext("DateRangeField.Root");
function useDateRangeFieldRoot(props) {
  return setDateRangeFieldRootContext(new DateRangeFieldRootState(props));
}
function useDateRangeFieldLabel(props) {
  const root17 = getDateRangeFieldRootContext();
  return new DateRangeFieldLabelState(props, root17);
}
function useDateRangeFieldInput(props, type) {
  const root17 = getDateRangeFieldRootContext();
  const fieldState = useDateFieldRoot(
    {
      value: strict_equals(type, "start") ? root17.startValue : root17.endValue,
      disabled: root17.disabled,
      readonly: root17.readonly,
      readonlySegments: root17.readonlySegments,
      validate: box.with(() => void 0),
      minValue: root17.minValue,
      maxValue: root17.maxValue,
      hourCycle: root17.hourCycle,
      locale: root17.locale,
      hideTimeZone: root17.hideTimeZone,
      required: root17.required,
      granularity: root17.granularity,
      placeholder: root17.placeholder,
      onInvalid: root17.onInvalid,
      errorMessageId: root17.errorMessageId,
      isInvalidProp: box.with(() => root17.isInvalid)
    },
    root17
  );
  return new DateFieldInputState(
    {
      name: props.name,
      id: props.id,
      ref: props.ref
    },
    fieldState
  );
}

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte
mark_module_start();
Date_range_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte";
var root_263 = add_locations(template(`<div><!></div>`), Date_range_field[FILENAME], [[129, 1]]);
function Date_range_field($$anchor, $$props) {
  var _a, _b, _c;
  check_target(new.target);
  push($$props, true, Date_range_field);
  validate_prop_bindings($$props, ["ref", "value", "placeholder"], [], Date_range_field);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop2), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), required = prop($$props, "required", 3, false), locale = prop($$props, "locale", 3, "en-US"), hideTimeZone = prop($$props, "hideTimeZone", 3, false), validate = prop($$props, "validate", 3, noop2), onInvalid = prop($$props, "onInvalid", 3, noop2), readonlySegments = prop($$props, "readonlySegments", 19, () => []), onStartValueChange = prop($$props, "onStartValueChange", 3, noop2), onEndValueChange = prop($$props, "onEndValueChange", 3, noop2), controlledPlaceholder = prop($$props, "controlledPlaceholder", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "disabled",
      "readonly",
      "required",
      "hourCycle",
      "granularity",
      "locale",
      "hideTimeZone",
      "validate",
      "onInvalid",
      "maxValue",
      "minValue",
      "readonlySegments",
      "children",
      "child",
      "onStartValueChange",
      "onEndValueChange",
      "controlledPlaceholder",
      "controlledValue",
      "errorMessageId"
    ],
    "restProps"
  );
  let startValue = state(proxy((_a = value()) == null ? void 0 : _a.start));
  let endValue = state(proxy((_b = value()) == null ? void 0 : _b.end));
  if (strict_equals(placeholder(), void 0)) {
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultPlaceholder: void 0,
      defaultValue: (_c = value()) == null ? void 0 : _c.start
    });
    if (controlledPlaceholder()) {
      onPlaceholderChange()(defaultPlaceholder);
    } else {
      placeholder(defaultPlaceholder);
    }
  }
  if (strict_equals(value(), void 0)) {
    const defaultValue = { start: void 0, end: void 0 };
    if (controlledValue()) {
      onValueChange()(defaultValue);
    } else {
      value(defaultValue);
    }
  }
  const rootState = useDateRangeFieldRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    required: box.with(() => required()),
    hourCycle: box.with(() => $$props.hourCycle),
    granularity: box.with(() => $$props.granularity),
    locale: box.with(() => locale()),
    hideTimeZone: box.with(() => hideTimeZone()),
    validate: box.with(() => validate()),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    placeholder: box.with(() => placeholder(), (v) => {
      if (controlledPlaceholder()) {
        onPlaceholderChange()(v);
      } else {
        placeholder(v);
        onPlaceholderChange()(v);
      }
    }),
    readonlySegments: box.with(() => readonlySegments()),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, proxy(v, null, startValue));
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, proxy(v, null, endValue));
      onEndValueChange()(v);
    }),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_263();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field = hmr(Date_range_field, () => Date_range_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field[HMR].source;
    set(Date_range_field[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_default = Date_range_field;
mark_module_end(Date_range_field);

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte
mark_module_start();
Date_range_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte";
var root_264 = add_locations(template(`<div><!></div>`), Date_range_field_input[FILENAME], [[36, 1]]);
var root9 = add_locations(template(`<!> <!>`, 1), Date_range_field_input[FILENAME], []);
function Date_range_field_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_range_field_input);
  validate_prop_bindings($$props, ["ref"], [], Date_range_field_input);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const inputState = useDateRangeFieldInput(
    {
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => ref(v)),
      name: box.with(() => name())
    },
    $$props.type
  );
  const mergedProps = derived(() => mergeProps(restProps, inputState.props, { role: "presentation" }));
  var fragment = root9();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_264();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  var node_3 = sibling(node, 2);
  date_field_hidden_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field_input = hmr(Date_range_field_input, () => Date_range_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field_input[HMR].source;
    set(Date_range_field_input[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_input_default = Date_range_field_input;
mark_module_end(Date_range_field_input);

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte
mark_module_start();
Date_range_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte";
var root_265 = add_locations(template(`<span><!></span>`), Date_range_field_label[FILENAME], [[29, 1]]);
function Date_range_field_label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_range_field_label);
  validate_prop_bindings($$props, ["ref"], [], Date_range_field_label);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = useDateRangeFieldLabel({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, labelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_265();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field_label = hmr(Date_range_field_label, () => Date_range_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field_label[HMR].source;
    set(Date_range_field_label[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_label_default = Date_range_field_label;
mark_module_end(Date_range_field_label);

// node_modules/bits-ui/dist/bits/date-range-picker/exports.js
var exports_exports15 = {};
__export(exports_exports15, {
  Arrow: () => popover_arrow_default,
  Calendar: () => date_range_picker_calendar_default,
  Cell: () => range_calendar_cell_default,
  Close: () => popover_close_default,
  Content: () => date_picker_content_default,
  Day: () => range_calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  Input: () => date_range_field_input_default,
  Label: () => date_range_field_label_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => date_range_picker_default,
  Segment: () => date_field_segment_default,
  Trigger: () => date_range_picker_trigger_default
});

// node_modules/bits-ui/dist/bits/date-range-picker/date-range-picker.svelte.js
var DateRangePickerRootState = class {
  constructor(props) {
    __publicField(this, "props");
    this.props = props;
  }
};
var [
  setDateRangePickerRootContext,
  getDateRangePickerRootContext
] = createContext("DateRangePicker.Root");
function useDateRangePickerRoot(props) {
  return setDateRangePickerRootContext(new DateRangePickerRootState(props));
}

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte
mark_module_start();
Date_range_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte";
var root_313 = add_locations(template(`<div><!></div>`), Date_range_picker[FILENAME], [[198, 2]]);
function Date_range_picker($$anchor, $$props) {
  var _a, _b, _c;
  check_target(new.target);
  push($$props, true, Date_range_picker);
  validate_prop_bindings($$props, ["open", "value", "ref", "placeholder"], [], Date_range_picker);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), value = prop($$props, "value", 15), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), onValueChange = prop($$props, "onValueChange", 3, noop2), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop2), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), onInvalid = prop($$props, "onInvalid", 3, noop2), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), locale = prop($$props, "locale", 3, "en"), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekStartsOn = prop($$props, "weekStartsOn", 3, 0), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnRangeSelect = prop($$props, "closeOnRangeSelect", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop2), onEndValueChange = prop($$props, "onEndValueChange", 3, noop2), controlledValue = prop($$props, "controlledValue", 3, false), controlledPlaceholder = prop($$props, "controlledPlaceholder", 3, false), controlledOpen = prop($$props, "controlledOpen", 3, false), validate = prop($$props, "validate", 3, noop2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "open",
      "onOpenChange",
      "value",
      "id",
      "ref",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "isDateUnavailable",
      "onInvalid",
      "minValue",
      "maxValue",
      "disabled",
      "readonly",
      "granularity",
      "readonlySegments",
      "hourCycle",
      "locale",
      "hideTimeZone",
      "required",
      "calendarLabel",
      "disableDaysOutsideMonth",
      "preventDeselect",
      "pagedNavigation",
      "weekStartsOn",
      "weekdayFormat",
      "isDateDisabled",
      "fixedWeeks",
      "numberOfMonths",
      "closeOnRangeSelect",
      "onStartValueChange",
      "onEndValueChange",
      "controlledValue",
      "controlledPlaceholder",
      "controlledOpen",
      "validate",
      "errorMessageId",
      "child",
      "children"
    ],
    "restProps"
  );
  let startValue = state(proxy((_a = value()) == null ? void 0 : _a.start));
  let endValue = state(proxy((_b = value()) == null ? void 0 : _b.end));
  if (strict_equals(value(), void 0)) {
    if (controlledValue()) {
      onValueChange()({ start: void 0, end: void 0 });
    } else {
      value({ start: void 0, end: void 0 });
    }
  }
  if (strict_equals(placeholder(), void 0)) {
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultPlaceholder: void 0,
      defaultValue: (_c = value()) == null ? void 0 : _c.start
    });
    if (controlledPlaceholder()) {
      onPlaceholderChange()(defaultPlaceholder);
    } else {
      placeholder(defaultPlaceholder);
    }
  }
  function onRangeSelect() {
    if (closeOnRangeSelect()) {
      if (controlledOpen()) {
        onOpenChange()(false);
      } else {
        open(false);
      }
    }
  }
  const pickerRootState = useDateRangePickerRoot({
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    }),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      if (controlledPlaceholder()) {
        onPlaceholderChange()(v);
      } else {
        placeholder(v);
        onPlaceholderChange()(v);
      }
    }),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    minValue: box.with(() => $$props.minValue),
    maxValue: box.with(() => $$props.maxValue),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    granularity: box.with(() => $$props.granularity),
    readonlySegments: box.with(() => readonlySegments()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: box.with(() => locale()),
    hideTimeZone: box.with(() => hideTimeZone()),
    required: box.with(() => required()),
    calendarLabel: box.with(() => calendarLabel()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    preventDeselect: box.with(() => preventDeselect()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => weekStartsOn()),
    weekdayFormat: box.with(() => weekdayFormat()),
    isDateDisabled: box.with(() => isDateDisabled()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    onRangeSelect: box.with(() => onRangeSelect),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, proxy(v, null, startValue));
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, proxy(v, null, endValue));
      onEndValueChange()(v);
    })
  });
  usePopoverRoot({ open: pickerRootState.props.open });
  const fieldRootState = useDateRangeFieldRoot({
    value: pickerRootState.props.value,
    disabled: pickerRootState.props.disabled,
    readonly: pickerRootState.props.readonly,
    readonlySegments: pickerRootState.props.readonlySegments,
    validate: box.with(() => validate()),
    minValue: pickerRootState.props.minValue,
    maxValue: pickerRootState.props.maxValue,
    granularity: pickerRootState.props.granularity,
    hideTimeZone: pickerRootState.props.hideTimeZone,
    hourCycle: pickerRootState.props.hourCycle,
    locale: pickerRootState.props.locale,
    required: pickerRootState.props.required,
    placeholder: pickerRootState.props.placeholder,
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    startValue: pickerRootState.props.startValue,
    endValue: pickerRootState.props.endValue,
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = derived(() => mergeProps(restProps, fieldRootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Date_range_picker, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var div = root_313();
          let attributes;
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
          append($$anchor3, div);
        }
      );
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker = hmr(Date_range_picker, () => Date_range_picker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker[HMR].source;
    set(Date_range_picker[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_default = Date_range_picker;
mark_module_end(Date_range_picker);

// node_modules/bits-ui/dist/bits/range-calendar/range-calendar.svelte.js
var _months2, _visibleMonths2, _focusedValue, _lastPressedDateValue, _updateValue, _setMonths2, _weekdays2, _isStartInvalid, _isEndInvalid, _isInvalid4, _isNextButtonDisabled2, _isPrevButtonDisabled2, _headingValue3, _fullCalendarLabel2, _highlightedRange, _shiftFocus2, _announceEmpty, _announceSelectedDate, _announceSelectedRange, _onkeydown28, _snippetProps14, _props93;
var RangeCalendarRootState = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "preventDeselect");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "pagedNavigation");
    __publicField(this, "weekStartsOn");
    __publicField(this, "weekdayFormat");
    __publicField(this, "isDateDisabledProp");
    __publicField(this, "isDateUnavailableProp");
    __publicField(this, "fixedWeeks");
    __publicField(this, "numberOfMonths");
    __publicField(this, "locale");
    __publicField(this, "calendarLabel");
    __publicField(this, "readonly");
    __publicField(this, "disableDaysOutsideMonth");
    __publicField(this, "onRangeSelect");
    __publicField(this, "startValue");
    __publicField(this, "endValue");
    __privateAdd(this, _months2, state(proxy([])));
    __privateAdd(this, _visibleMonths2, derived(() => this.months.map((month) => month.value)));
    __publicField(this, "announcer");
    __publicField(this, "formatter");
    __publicField(this, "accessibleHeadingId", useId());
    __privateAdd(this, _focusedValue, state(void 0));
    __privateAdd(this, _lastPressedDateValue, state(void 0));
    __privateAdd(this, _updateValue, (cb) => {
      var _a, _b;
      const value = this.value.current;
      const newValue = cb(value);
      this.value.current = newValue;
      if (newValue.start && newValue.end) {
        (_b = (_a = this.onRangeSelect) == null ? void 0 : _a.current) == null ? void 0 : _b.call(_a);
      }
    });
    __publicField(this, "setStartValue", (value) => {
      this.startValue.current = value;
    });
    __publicField(this, "setEndValue", (value) => {
      this.endValue.current = value;
    });
    __privateAdd(this, _setMonths2, (months) => this.months = months);
    __privateAdd(this, _weekdays2, derived(() => {
      return getWeekdays({
        months: this.months,
        formatter: this.formatter,
        weekdayFormat: this.weekdayFormat.current
      });
    }));
    __publicField(this, "isOutsideVisibleMonths", (date) => {
      return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
    });
    __publicField(this, "isDateDisabled", (date) => {
      if (this.isDateDisabledProp.current(date) || this.disabled.current) return true;
      const minValue = this.minValue.current;
      const maxValue = this.maxValue.current;
      if (minValue && isBefore(date, minValue)) return true;
      if (maxValue && isAfter(date, maxValue)) return true;
      return false;
    });
    __publicField(this, "isDateUnavailable", (date) => {
      if (this.isDateUnavailableProp.current(date)) return true;
      return false;
    });
    __privateAdd(this, _isStartInvalid, derived(() => {
      if (!this.startValue.current) return false;
      return this.isDateUnavailable(this.startValue.current) || this.isDateDisabled(this.startValue.current);
    }));
    __privateAdd(this, _isEndInvalid, derived(() => {
      if (!this.endValue.current) return false;
      return this.isDateUnavailable(this.endValue.current) || this.isDateDisabled(this.endValue.current);
    }));
    __privateAdd(this, _isInvalid4, derived(() => {
      if (this.isStartInvalid || this.isEndInvalid) return true;
      if (this.endValue.current && this.startValue.current && isBefore(this.endValue.current, this.startValue.current)) return true;
      return false;
    }));
    __privateAdd(this, _isNextButtonDisabled2, derived(() => {
      return getIsNextButtonDisabled({
        maxValue: this.maxValue.current,
        months: this.months,
        disabled: this.disabled.current
      });
    }));
    __privateAdd(this, _isPrevButtonDisabled2, derived(() => {
      return getIsPrevButtonDisabled({
        minValue: this.minValue.current,
        months: this.months,
        disabled: this.disabled.current
      });
    }));
    __privateAdd(this, _headingValue3, derived(() => {
      return getCalendarHeadingValue({
        months: this.months,
        formatter: this.formatter,
        locale: this.locale.current
      });
    }));
    __privateAdd(this, _fullCalendarLabel2, derived(() => `${this.calendarLabel.current} ${this.headingValue}`));
    __publicField(this, "isSelectionStart", (date) => {
      if (!this.startValue.current) return false;
      return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.startValue.current);
    });
    __publicField(this, "isSelectionEnd", (date) => {
      if (!this.endValue.current) return false;
      return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.endValue.current);
    });
    __publicField(this, "isSelected", (date) => {
      if (this.startValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.startValue.current, date)) return true;
      if (this.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.endValue.current, date)) return true;
      if (this.startValue.current && this.endValue.current) {
        return isBetweenInclusive(date, this.startValue.current, this.endValue.current);
      }
      return false;
    });
    __privateAdd(this, _highlightedRange, derived(() => {
      if (this.startValue.current && this.endValue.current) return null;
      if (!this.startValue.current || !this.focusedValue) return null;
      const isStartBeforeFocused = isBefore(this.startValue.current, this.focusedValue);
      const start = isStartBeforeFocused ? this.startValue.current : this.focusedValue;
      const end = isStartBeforeFocused ? this.focusedValue : this.startValue.current;
      if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start.add({ days: 1 }), end)) {
        return { start, end };
      }
      const isValid = areAllDaysBetweenValid(start, end, this.isDateUnavailable, this.isDateDisabled);
      if (isValid) {
        return { start, end };
      }
      return null;
    }));
    __privateAdd(this, _shiftFocus2, (node, add) => {
      return shiftCalendarFocus({
        node,
        add,
        placeholder: this.placeholder,
        calendarNode: this.ref.current,
        isPrevButtonDisabled: this.isPrevButtonDisabled,
        isNextButtonDisabled: this.isNextButtonDisabled,
        months: this.months,
        numberOfMonths: this.numberOfMonths.current
      });
    });
    __privateAdd(this, _announceEmpty, () => {
      this.announcer.announce("Selected date is now empty.", "polite");
    });
    __privateAdd(this, _announceSelectedDate, (date) => {
      this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(date, false)}`, "polite");
    });
    __privateAdd(this, _announceSelectedRange, (start, end) => {
      this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(start, false)} to ${this.formatter.selectedDate(end, false)}`, "polite");
    });
    __publicField(this, "handleCellClick", (e, date) => {
      if (this.isDateDisabled(date) || this.isDateUnavailable(date)) return;
      const prevLastPressedDate = this.lastPressedDateValue;
      this.lastPressedDateValue = date;
      if (this.startValue.current && strict_equals(this.highlightedRange, null)) {
        if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(this.startValue.current, date) && !this.preventDeselect.current && !this.endValue.current) {
          this.setStartValue(void 0);
          this.placeholder.current = date;
          __privateGet(this, _announceEmpty).call(this);
          return;
        } else if (!this.endValue.current) {
          e.preventDefault();
          if (prevLastPressedDate && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevLastPressedDate, date)) {
            this.setStartValue(date);
            __privateGet(this, _announceSelectedDate).call(this, date);
          }
        }
      }
      if (this.startValue.current && this.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.endValue.current, date) && !this.preventDeselect.current) {
        this.setStartValue(void 0);
        this.setEndValue(void 0);
        this.placeholder.current = date;
        __privateGet(this, _announceEmpty).call(this);
        return;
      }
      if (!this.startValue.current) {
        __privateGet(this, _announceSelectedDate).call(this, date);
        this.setStartValue(date);
      } else if (!this.endValue.current) {
        __privateGet(this, _announceSelectedRange).call(this, this.startValue.current, date);
        this.setEndValue(date);
      } else if (this.endValue.current && this.startValue.current) {
        this.setEndValue(void 0);
        __privateGet(this, _announceSelectedDate).call(this, date);
        this.setStartValue(date);
      }
    });
    __privateAdd(this, _onkeydown28, (event) => {
      return handleCalendarKeydown({
        event,
        handleCellClick: this.handleCellClick,
        placeholderValue: this.placeholder.current,
        shiftFocus: __privateGet(this, _shiftFocus2)
      });
    });
    /**
     * Navigates to the next page of the calendar.
     */
    __publicField(this, "nextPage", () => {
      handleCalendarNextPage({
        fixedWeeks: this.fixedWeeks.current,
        locale: this.locale.current,
        numberOfMonths: this.numberOfMonths.current,
        pagedNavigation: this.pagedNavigation.current,
        setMonths: __privateGet(this, _setMonths2),
        setPlaceholder: (date) => this.placeholder.current = date,
        weekStartsOn: this.weekStartsOn.current,
        months: this.months
      });
    });
    /**
     * Navigates to the previous page of the calendar.
     */
    __publicField(this, "prevPage", () => {
      handleCalendarPrevPage({
        fixedWeeks: this.fixedWeeks.current,
        locale: this.locale.current,
        numberOfMonths: this.numberOfMonths.current,
        pagedNavigation: this.pagedNavigation.current,
        setMonths: __privateGet(this, _setMonths2),
        setPlaceholder: (date) => this.placeholder.current = date,
        weekStartsOn: this.weekStartsOn.current,
        months: this.months
      });
    });
    __publicField(this, "nextYear", () => {
      this.placeholder.current = this.placeholder.current.add({ years: 1 });
    });
    __publicField(this, "prevYear", () => {
      this.placeholder.current = this.placeholder.current.subtract({ years: 1 });
    });
    __publicField(this, "setYear", (year) => {
      this.placeholder.current = this.placeholder.current.set({ year });
    });
    __publicField(this, "setMonth", (month) => {
      this.placeholder.current = this.placeholder.current.set({ month });
    });
    __publicField(this, "getBitsAttr", (part) => {
      return `data-range-calendar-${part}`;
    });
    __privateAdd(this, _snippetProps14, derived(() => ({ months: this.months, weekdays: this.weekdays })));
    __privateAdd(this, _props93, derived(() => ({
      ...getCalendarElementProps({
        fullCalendarLabel: this.fullCalendarLabel,
        id: this.id.current,
        isInvalid: this.isInvalid,
        disabled: this.disabled.current,
        readonly: this.readonly.current
      }),
      [this.getBitsAttr("root")]: "",
      //
      onkeydown: __privateGet(this, _onkeydown28)
    })));
    this.value = props.value;
    this.placeholder = props.placeholder;
    this.preventDeselect = props.preventDeselect;
    this.minValue = props.minValue;
    this.maxValue = props.maxValue;
    this.disabled = props.disabled;
    this.pagedNavigation = props.pagedNavigation;
    this.weekStartsOn = props.weekStartsOn;
    this.weekdayFormat = props.weekdayFormat;
    this.isDateDisabledProp = props.isDateDisabled;
    this.isDateUnavailableProp = props.isDateUnavailable;
    this.fixedWeeks = props.fixedWeeks;
    this.numberOfMonths = props.numberOfMonths;
    this.locale = props.locale;
    this.calendarLabel = props.calendarLabel;
    this.readonly = props.readonly;
    this.disableDaysOutsideMonth = props.disableDaysOutsideMonth;
    this.id = props.id;
    this.ref = props.ref;
    this.onRangeSelect = props.onRangeSelect;
    this.startValue = props.startValue;
    this.endValue = props.endValue;
    this.announcer = getAnnouncer();
    this.formatter = createFormatter(this.locale.current);
    useRefById({ id: this.id, ref: this.ref });
    this.months = createMonths({
      dateObj: this.placeholder.current,
      weekStartsOn: this.weekStartsOn.current,
      locale: this.locale.current,
      fixedWeeks: this.fixedWeeks.current,
      numberOfMonths: this.numberOfMonths.current
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    useMonthViewPlaceholderSync({
      placeholder: this.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.weekStartsOn,
      locale: this.locale,
      fixedWeeks: this.fixedWeeks,
      numberOfMonths: this.numberOfMonths,
      setMonths: __privateGet(this, _setMonths2)
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.fixedWeeks,
      locale: this.locale,
      numberOfMonths: this.numberOfMonths,
      placeholder: this.placeholder,
      setMonths: __privateGet(this, _setMonths2),
      weekStartsOn: this.weekStartsOn
    });
    user_effect(() => {
      const node = document.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = this.fullCalendarLabel;
    });
    user_effect(() => {
      const value = this.value.current;
      untrack(() => {
        if (value.start && value.end) {
          this.startValue.current = value.start;
          this.endValue.current = value.end;
        } else if (value.start) {
          this.startValue.current = value.start;
          this.endValue.current = void 0;
        }
      });
    });
    user_effect(() => {
      this.value.current;
      untrack(() => {
        const startValue = this.value.current.start;
        if (startValue && strict_equals(this.placeholder.current, startValue, false)) {
          this.placeholder.current = startValue;
        }
      });
    });
    user_effect(() => {
      const startValue = this.startValue.current;
      const endValue = this.endValue.current;
      untrack(() => {
        const value = this.value.current;
        if (value && strict_equals(value.start, startValue) && strict_equals(value.end, endValue)) {
          return;
        }
        if (startValue && endValue) {
          __privateGet(this, _updateValue).call(this, (prev2) => {
            if (strict_equals(prev2.start, startValue) && strict_equals(prev2.end, endValue)) return prev2;
            if (isBefore(endValue, startValue)) {
              const start = startValue;
              const end = endValue;
              this.setStartValue(end);
              this.setEndValue(start);
              return { start: endValue, end: startValue };
            } else {
              return { start: startValue, end: endValue };
            }
          });
        } else if (value && value.start && value.end) {
          this.value.current = { start: void 0, end: void 0 };
        }
      });
    });
  }
  get months() {
    return get(__privateGet(this, _months2));
  }
  set months(value) {
    set(__privateGet(this, _months2), proxy(value, null, __privateGet(this, _months2)));
  }
  get visibleMonths() {
    return get(__privateGet(this, _visibleMonths2));
  }
  set visibleMonths(_) {
    throw new Error("Cannot update a derived property ('visibleMonths')");
  }
  get focusedValue() {
    return get(__privateGet(this, _focusedValue));
  }
  set focusedValue(value) {
    set(__privateGet(this, _focusedValue), proxy(value, null, __privateGet(this, _focusedValue)));
  }
  get lastPressedDateValue() {
    return get(__privateGet(this, _lastPressedDateValue));
  }
  set lastPressedDateValue(value) {
    set(__privateGet(this, _lastPressedDateValue), proxy(value, null, __privateGet(this, _lastPressedDateValue)));
  }
  get weekdays() {
    return get(__privateGet(this, _weekdays2));
  }
  set weekdays(_) {
    throw new Error("Cannot update a derived property ('weekdays')");
  }
  get isStartInvalid() {
    return get(__privateGet(this, _isStartInvalid));
  }
  set isStartInvalid(_) {
    throw new Error("Cannot update a derived property ('isStartInvalid')");
  }
  get isEndInvalid() {
    return get(__privateGet(this, _isEndInvalid));
  }
  set isEndInvalid(_) {
    throw new Error("Cannot update a derived property ('isEndInvalid')");
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid4));
  }
  set isInvalid(_) {
    throw new Error("Cannot update a derived property ('isInvalid')");
  }
  get isNextButtonDisabled() {
    return get(__privateGet(this, _isNextButtonDisabled2));
  }
  set isNextButtonDisabled(_) {
    throw new Error("Cannot update a derived property ('isNextButtonDisabled')");
  }
  get isPrevButtonDisabled() {
    return get(__privateGet(this, _isPrevButtonDisabled2));
  }
  set isPrevButtonDisabled(_) {
    throw new Error("Cannot update a derived property ('isPrevButtonDisabled')");
  }
  get headingValue() {
    return get(__privateGet(this, _headingValue3));
  }
  set headingValue(_) {
    throw new Error("Cannot update a derived property ('headingValue')");
  }
  get fullCalendarLabel() {
    return get(__privateGet(this, _fullCalendarLabel2));
  }
  set fullCalendarLabel(_) {
    throw new Error("Cannot update a derived property ('fullCalendarLabel')");
  }
  get highlightedRange() {
    return get(__privateGet(this, _highlightedRange));
  }
  set highlightedRange(_) {
    throw new Error("Cannot update a derived property ('highlightedRange')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps14));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props93));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _months2)), owner, false);
    add_owner(get(__privateGet(this, _visibleMonths2)), owner, false);
    add_owner(get(__privateGet(this, _focusedValue)), owner, false);
    add_owner(get(__privateGet(this, _lastPressedDateValue)), owner, false);
    add_owner(get(__privateGet(this, _weekdays2)), owner, false);
    add_owner(get(__privateGet(this, _isStartInvalid)), owner, false);
    add_owner(get(__privateGet(this, _isEndInvalid)), owner, false);
    add_owner(get(__privateGet(this, _isInvalid4)), owner, false);
    add_owner(get(__privateGet(this, _isNextButtonDisabled2)), owner, false);
    add_owner(get(__privateGet(this, _isPrevButtonDisabled2)), owner, false);
    add_owner(get(__privateGet(this, _headingValue3)), owner, false);
    add_owner(get(__privateGet(this, _fullCalendarLabel2)), owner, false);
    add_owner(get(__privateGet(this, _highlightedRange)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps14)), owner, false);
    add_owner(get(__privateGet(this, _props93)), owner, false);
  }
};
_months2 = new WeakMap();
_visibleMonths2 = new WeakMap();
_focusedValue = new WeakMap();
_lastPressedDateValue = new WeakMap();
_updateValue = new WeakMap();
_setMonths2 = new WeakMap();
_weekdays2 = new WeakMap();
_isStartInvalid = new WeakMap();
_isEndInvalid = new WeakMap();
_isInvalid4 = new WeakMap();
_isNextButtonDisabled2 = new WeakMap();
_isPrevButtonDisabled2 = new WeakMap();
_headingValue3 = new WeakMap();
_fullCalendarLabel2 = new WeakMap();
_highlightedRange = new WeakMap();
_shiftFocus2 = new WeakMap();
_announceEmpty = new WeakMap();
_announceSelectedDate = new WeakMap();
_announceSelectedRange = new WeakMap();
_onkeydown28 = new WeakMap();
_snippetProps14 = new WeakMap();
_props93 = new WeakMap();
var _cellDate2, _isDisabled7, _isUnavailable2, _isDateToday2, _isOutsideMonth2, _isOutsideVisibleMonths2, _isFocusedDate2, _isSelectedDate2, _isSelectionStart, _isSelectionEnd, _isHighlighted2, _labelText2, _snippetProps15, _ariaDisabled2, _sharedDataAttrs2, _props94;
var RangeCalendarCellState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "date");
    __publicField(this, "month");
    __privateAdd(this, _cellDate2, derived(() => toDate(this.date.current)));
    __privateAdd(this, _isDisabled7, derived(() => this.root.isDateDisabled(this.date.current)));
    __privateAdd(this, _isUnavailable2, derived(() => this.root.isDateUnavailableProp.current(this.date.current)));
    __privateAdd(this, _isDateToday2, derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())));
    __privateAdd(this, _isOutsideMonth2, derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.date.current, this.month.current)));
    __privateAdd(this, _isOutsideVisibleMonths2, derived(() => this.root.isOutsideVisibleMonths(this.date.current)));
    __privateAdd(this, _isFocusedDate2, derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.date.current, this.root.placeholder.current)));
    __privateAdd(this, _isSelectedDate2, derived(() => this.root.isSelected(this.date.current)));
    __privateAdd(this, _isSelectionStart, derived(() => this.root.isSelectionStart(this.date.current)));
    __privateAdd(this, _isSelectionEnd, derived(() => this.root.isSelectionEnd(this.date.current)));
    __privateAdd(this, _isHighlighted2, derived(() => this.root.highlightedRange ? isBetweenInclusive(this.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : false));
    __privateAdd(this, _labelText2, derived(() => this.root.formatter.custom(this.cellDate, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })));
    __privateAdd(this, _snippetProps15, derived(() => ({
      disabled: this.isDisabled,
      unavailable: this.isUnavailable,
      selected: this.isSelectedDate
    })));
    __privateAdd(this, _ariaDisabled2, derived(() => {
      return this.isDisabled || this.isOutsideMonth && this.root.disableDaysOutsideMonth.current || this.isUnavailable;
    }));
    __privateAdd(this, _sharedDataAttrs2, derived(() => ({
      "data-unavailable": getDataUnavailable(this.isUnavailable),
      "data-today": this.isDateToday ? "" : void 0,
      "data-outside-month": this.isOutsideMonth ? "" : void 0,
      "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
      "data-focused": this.isFocusedDate ? "" : void 0,
      "data-selection-start": this.isSelectionStart ? "" : void 0,
      "data-selection-end": this.isSelectionEnd ? "" : void 0,
      "data-highlighted": this.isHighlighted ? "" : void 0,
      "data-selected": getDataSelected(this.isSelectedDate),
      "data-value": this.date.current.toString(),
      "data-disabled": getDataDisabled(this.isDisabled || this.isOutsideMonth && this.root.disableDaysOutsideMonth.current)
    })));
    __privateAdd(this, _props94, derived(() => ({
      id: this.id.current,
      role: "gridcell",
      "aria-selected": getAriaSelected(this.isSelectedDate),
      "aria-disabled": getAriaDisabled(this.ariaDisabled),
      ...this.sharedDataAttrs,
      [this.root.getBitsAttr("cell")]: ""
    })));
    this.root = root17;
    this.id = props.id;
    this.ref = props.ref;
    this.date = props.date;
    this.month = props.month;
    useRefById({ id: this.id, ref: this.ref });
  }
  get cellDate() {
    return get(__privateGet(this, _cellDate2));
  }
  set cellDate(_) {
    throw new Error("Cannot update a derived property ('cellDate')");
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled7));
  }
  set isDisabled(_) {
    throw new Error("Cannot update a derived property ('isDisabled')");
  }
  get isUnavailable() {
    return get(__privateGet(this, _isUnavailable2));
  }
  set isUnavailable(_) {
    throw new Error("Cannot update a derived property ('isUnavailable')");
  }
  get isDateToday() {
    return get(__privateGet(this, _isDateToday2));
  }
  set isDateToday(_) {
    throw new Error("Cannot update a derived property ('isDateToday')");
  }
  get isOutsideMonth() {
    return get(__privateGet(this, _isOutsideMonth2));
  }
  set isOutsideMonth(_) {
    throw new Error("Cannot update a derived property ('isOutsideMonth')");
  }
  get isOutsideVisibleMonths() {
    return get(__privateGet(this, _isOutsideVisibleMonths2));
  }
  set isOutsideVisibleMonths(_) {
    throw new Error("Cannot update a derived property ('isOutsideVisibleMonths')");
  }
  get isFocusedDate() {
    return get(__privateGet(this, _isFocusedDate2));
  }
  set isFocusedDate(_) {
    throw new Error("Cannot update a derived property ('isFocusedDate')");
  }
  get isSelectedDate() {
    return get(__privateGet(this, _isSelectedDate2));
  }
  set isSelectedDate(_) {
    throw new Error("Cannot update a derived property ('isSelectedDate')");
  }
  get isSelectionStart() {
    return get(__privateGet(this, _isSelectionStart));
  }
  set isSelectionStart(_) {
    throw new Error("Cannot update a derived property ('isSelectionStart')");
  }
  get isSelectionEnd() {
    return get(__privateGet(this, _isSelectionEnd));
  }
  set isSelectionEnd(_) {
    throw new Error("Cannot update a derived property ('isSelectionEnd')");
  }
  get isHighlighted() {
    return get(__privateGet(this, _isHighlighted2));
  }
  set isHighlighted(_) {
    throw new Error("Cannot update a derived property ('isHighlighted')");
  }
  get labelText() {
    return get(__privateGet(this, _labelText2));
  }
  set labelText(_) {
    throw new Error("Cannot update a derived property ('labelText')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps15));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get ariaDisabled() {
    return get(__privateGet(this, _ariaDisabled2));
  }
  set ariaDisabled(_) {
    throw new Error("Cannot update a derived property ('ariaDisabled')");
  }
  get sharedDataAttrs() {
    return get(__privateGet(this, _sharedDataAttrs2));
  }
  set sharedDataAttrs(_) {
    throw new Error("Cannot update a derived property ('sharedDataAttrs')");
  }
  get props() {
    return get(__privateGet(this, _props94));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _cellDate2)), owner, false);
    add_owner(get(__privateGet(this, _isDisabled7)), owner, false);
    add_owner(get(__privateGet(this, _isUnavailable2)), owner, false);
    add_owner(get(__privateGet(this, _isDateToday2)), owner, false);
    add_owner(get(__privateGet(this, _isOutsideMonth2)), owner, false);
    add_owner(get(__privateGet(this, _isOutsideVisibleMonths2)), owner, false);
    add_owner(get(__privateGet(this, _isFocusedDate2)), owner, false);
    add_owner(get(__privateGet(this, _isSelectedDate2)), owner, false);
    add_owner(get(__privateGet(this, _isSelectionStart)), owner, false);
    add_owner(get(__privateGet(this, _isSelectionEnd)), owner, false);
    add_owner(get(__privateGet(this, _isHighlighted2)), owner, false);
    add_owner(get(__privateGet(this, _labelText2)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps15)), owner, false);
    add_owner(get(__privateGet(this, _ariaDisabled2)), owner, false);
    add_owner(get(__privateGet(this, _sharedDataAttrs2)), owner, false);
    add_owner(get(__privateGet(this, _props94)), owner, false);
  }
};
_cellDate2 = new WeakMap();
_isDisabled7 = new WeakMap();
_isUnavailable2 = new WeakMap();
_isDateToday2 = new WeakMap();
_isOutsideMonth2 = new WeakMap();
_isOutsideVisibleMonths2 = new WeakMap();
_isFocusedDate2 = new WeakMap();
_isSelectedDate2 = new WeakMap();
_isSelectionStart = new WeakMap();
_isSelectionEnd = new WeakMap();
_isHighlighted2 = new WeakMap();
_labelText2 = new WeakMap();
_snippetProps15 = new WeakMap();
_ariaDisabled2 = new WeakMap();
_sharedDataAttrs2 = new WeakMap();
_props94 = new WeakMap();
var _tabindex2, _onclick14, _onmouseenter, _onfocusin, _snippetProps16, _props95;
var RangeCalendarDayState = class {
  constructor(props, cell) {
    __publicField(this, "cell");
    __publicField(this, "id");
    __publicField(this, "ref");
    __privateAdd(this, _tabindex2, derived(() => this.cell.isFocusedDate ? 0 : this.cell.isOutsideMonth && this.cell.root.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : -1));
    __privateAdd(this, _onclick14, (e) => {
      if (this.cell.isDisabled) return;
      this.cell.root.handleCellClick(e, this.cell.date.current);
    });
    __privateAdd(this, _onmouseenter, () => {
      if (this.cell.isDisabled) return;
      this.cell.root.focusedValue = this.cell.date.current;
    });
    __privateAdd(this, _onfocusin, () => {
      if (this.cell.isDisabled) return;
      this.cell.root.focusedValue = this.cell.date.current;
    });
    __privateAdd(this, _snippetProps16, derived(() => ({
      disabled: this.cell.isDisabled,
      unavailable: this.cell.isUnavailable,
      selected: this.cell.isSelectedDate,
      day: `${this.cell.date.current.day}`
    })));
    __privateAdd(this, _props95, derived(() => ({
      id: this.id.current,
      role: "button",
      "aria-label": this.cell.labelText,
      "aria-disabled": getAriaDisabled(this.cell.ariaDisabled),
      ...this.cell.sharedDataAttrs,
      tabindex: get(__privateGet(this, _tabindex2)),
      [this.cell.root.getBitsAttr("day")]: "",
      // Shared logic for range calendar and calendar
      "data-bits-day": "",
      //
      onclick: __privateGet(this, _onclick14),
      onmouseenter: __privateGet(this, _onmouseenter),
      onfocusin: __privateGet(this, _onfocusin)
    })));
    this.cell = cell;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps16));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props95));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps16)), owner, false);
    add_owner(get(__privateGet(this, _props95)), owner, false);
  }
};
_tabindex2 = new WeakMap();
_onclick14 = new WeakMap();
_onmouseenter = new WeakMap();
_onfocusin = new WeakMap();
_snippetProps16 = new WeakMap();
_props95 = new WeakMap();
var [
  setRangeCalendarRootContext,
  getRangeCalendarRootContext
] = createContext(["Calendar.Root", "RangeCalendar.Root"], "Calendar.Root", false);
var [
  setRangeCalendarCellContext,
  getRangeCalendarCellContext
] = createContext("RangeCalendar.Cell");
function useRangeCalendarRoot(props) {
  return setRangeCalendarRootContext(new RangeCalendarRootState(props));
}
function useRangeCalendarCell(props) {
  return setRangeCalendarCellContext(new RangeCalendarCellState(props, getRangeCalendarRootContext()));
}
function useRangeCalendarDay(props) {
  return new RangeCalendarDayState(props, getRangeCalendarCellContext());
}

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte
mark_module_start();
Date_range_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte";
var root_266 = add_locations(template(`<div><!></div>`), Date_range_picker_calendar[FILENAME], [[52, 1]]);
function Date_range_picker_calendar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_range_picker_calendar);
  validate_prop_bindings($$props, ["ref"], [], Date_range_picker_calendar);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const dateRangePickerRootState = getDateRangePickerRootContext();
  const rangeCalendarState = useRangeCalendarRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    calendarLabel: dateRangePickerRootState.props.calendarLabel,
    fixedWeeks: dateRangePickerRootState.props.fixedWeeks,
    isDateDisabled: dateRangePickerRootState.props.isDateDisabled,
    isDateUnavailable: dateRangePickerRootState.props.isDateUnavailable,
    locale: dateRangePickerRootState.props.locale,
    numberOfMonths: dateRangePickerRootState.props.numberOfMonths,
    pagedNavigation: dateRangePickerRootState.props.pagedNavigation,
    preventDeselect: dateRangePickerRootState.props.preventDeselect,
    readonly: dateRangePickerRootState.props.readonly,
    weekStartsOn: dateRangePickerRootState.props.weekStartsOn,
    weekdayFormat: dateRangePickerRootState.props.weekdayFormat,
    disabled: dateRangePickerRootState.props.disabled,
    disableDaysOutsideMonth: dateRangePickerRootState.props.disableDaysOutsideMonth,
    maxValue: dateRangePickerRootState.props.maxValue,
    minValue: dateRangePickerRootState.props.minValue,
    placeholder: dateRangePickerRootState.props.placeholder,
    value: dateRangePickerRootState.props.value,
    onRangeSelect: dateRangePickerRootState.props.onRangeSelect,
    startValue: dateRangePickerRootState.props.startValue,
    endValue: dateRangePickerRootState.props.endValue
  });
  const mergedProps = derived(() => mergeProps(restProps, rangeCalendarState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...rangeCalendarState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_266();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rangeCalendarState.snippetProps);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker_calendar = hmr(Date_range_picker_calendar, () => Date_range_picker_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker_calendar[HMR].source;
    set(Date_range_picker_calendar[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_calendar_default = Date_range_picker_calendar;
mark_module_end(Date_range_picker_calendar);

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte
mark_module_start();
Date_range_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte";
function Date_range_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_range_picker_trigger);
  validate_prop_bindings($$props, ["ref"], [], Date_range_picker_trigger);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onkeydown"
    ],
    "restProps"
  );
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(`[${DATE_RANGE_FIELD_ROOT_ATTR}]`);
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, popover_trigger_default);
    popover_trigger_default(node, spread_props(
      () => restProps,
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        },
        "data-segment": "trigger"
      },
      () => get(mergedProps)
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker_trigger = hmr(Date_range_picker_trigger, () => Date_range_picker_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker_trigger[HMR].source;
    set(Date_range_picker_trigger[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_trigger_default = Date_range_picker_trigger;
mark_module_end(Date_range_picker_trigger);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte
mark_module_start();
Range_calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte";
var root_267 = add_locations(template(`<td><!></td>`), Range_calendar_cell[FILENAME], [[33, 1]]);
function Range_calendar_cell($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Range_calendar_cell);
  validate_prop_bindings($$props, ["ref"], [], Range_calendar_cell);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "date",
      "month"
    ],
    "restProps"
  );
  const cellState = useRangeCalendarCell({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    date: box.with(() => $$props.date),
    month: box.with(() => $$props.month)
  });
  const mergedProps = derived(() => mergeProps(restProps, cellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...cellState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var td = root_267();
      let attributes;
      var node_2 = child(td);
      snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps);
      reset(td);
      template_effect(() => attributes = set_attributes(td, attributes, { ...get(mergedProps) }));
      append($$anchor2, td);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar_cell = hmr(Range_calendar_cell, () => Range_calendar_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar_cell[HMR].source;
    set(Range_calendar_cell[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_cell_default = Range_calendar_cell;
mark_module_end(Range_calendar_cell);

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte
mark_module_start();
Range_calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte";
var root_268 = add_locations(template(`<div><!></div>`), Range_calendar_day[FILENAME], [[29, 1]]);
function Range_calendar_day($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Range_calendar_day);
  validate_prop_bindings($$props, ["ref"], [], Range_calendar_day);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const dayState = useRangeCalendarDay({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, dayState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...dayState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_268();
      let attributes;
      var node_2 = child(div);
      if_block(
        node_2,
        () => $$props.children,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps);
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.date.current.day));
          append($$anchor3, text2);
        }
      );
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar_day = hmr(Range_calendar_day, () => Range_calendar_day[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar_day[HMR].source;
    set(Range_calendar_day[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_day_default = Range_calendar_day;
mark_module_end(Range_calendar_day);

// node_modules/bits-ui/dist/bits/dialog/exports.js
var exports_exports16 = {};
__export(exports_exports16, {
  Close: () => dialog_close_default,
  Content: () => dialog_content_default,
  Description: () => dialog_description_default,
  Overlay: () => dialog_overlay_default,
  Portal: () => portal_default,
  Root: () => dialog_default,
  Title: () => dialog_title_default,
  Trigger: () => dialog_trigger_default
});

// node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte
mark_module_start();
Dialog[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte";
function Dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog);
  validate_prop_bindings($$props, ["open"], [], Dialog);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), controlledOpen = prop($$props, "controlledOpen", 3, false);
  useDialogRoot({
    variant: box.with(() => "dialog"),
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    })
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog = hmr(Dialog, () => Dialog[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog[HMR].source;
    set(Dialog[HMR].source, module.default[HMR].original);
  });
}
var dialog_default = Dialog;
mark_module_end(Dialog);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte
mark_module_start();
Dialog_close[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte";
var root_269 = add_locations(template(`<button><!></button>`), Dialog_close[FILENAME], [[32, 1]]);
function Dialog_close($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog_close);
  validate_prop_bindings($$props, ["ref"], [], Dialog_close);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "disabled"
    ],
    "restProps"
  );
  const closeState = useDialogClose({
    variant: box.with(() => "close"),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = derived(() => mergeProps(restProps, closeState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_269();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_close = hmr(Dialog_close, () => Dialog_close[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_close[HMR].source;
    set(Dialog_close[HMR].source, module.default[HMR].original);
  });
}
var dialog_close_default = Dialog_close;
mark_module_end(Dialog_close);

// node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte
mark_module_start();
Dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte";
var root_62 = add_locations(template(`<!> <!>`, 1), Dialog_content[FILENAME], []);
var root_82 = add_locations(template(`<!> <div><!></div>`, 1), Dialog_content[FILENAME], [[88, 8]]);
function Dialog_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog_content);
  validate_prop_bindings($$props, ["ref"], [], Dialog_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll",
      "restoreScrollDelay"
    ],
    "restProps"
  );
  const contentState = useDialogContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  var present_1 = derived(() => contentState.root.open.current || forceMount());
  {
    const presence = wrap_snippet(Dialog_content, ($$anchor2, $$arg0) => {
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var trapFocus_1 = derived(() => shouldTrapFocus({
        forceMount: forceMount(),
        present: present().current,
        trapFocus: trapFocus(),
        open: contentState.root.open.current
      }));
      {
        const focusScope = wrap_snippet(Dialog_content, ($$anchor3, $$arg02) => {
          let focusScopeProps = () => $$arg02 == null ? void 0 : $$arg02().props;
          focusScopeProps();
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          escape_layer_default(node_2, spread_props(() => get(mergedProps), {
            get enabled() {
              return present().current;
            },
            onEscapeKeydown: (e) => {
              onEscapeKeydown()(e);
              if (e.defaultPrevented) return;
              contentState.root.handleClose();
            },
            children: wrap_snippet(Dialog_content, ($$anchor4, $$slotProps) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              dismissible_layer_default(node_3, spread_props(() => get(mergedProps), {
                get enabled() {
                  return present().current;
                },
                onInteractOutside: (e) => {
                  onInteractOutside()(e);
                  if (e.defaultPrevented) return;
                  contentState.root.handleClose();
                },
                children: wrap_snippet(Dialog_content, ($$anchor5, $$slotProps2) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  text_selection_layer_default(node_4, spread_props(() => get(mergedProps), {
                    get enabled() {
                      return present().current;
                    },
                    children: wrap_snippet(Dialog_content, ($$anchor6, $$slotProps3) => {
                      var fragment_5 = comment();
                      var node_5 = first_child(fragment_5);
                      if_block(
                        node_5,
                        () => $$props.child,
                        ($$anchor7) => {
                          var fragment_6 = root_62();
                          var node_6 = first_child(fragment_6);
                          if_block(node_6, () => contentState.root.open.current, ($$anchor8) => {
                            var fragment_7 = comment();
                            var node_7 = first_child(fragment_7);
                            scroll_lock_default(node_7, {
                              get preventScroll() {
                                return preventScroll();
                              },
                              get restoreScrollDelay() {
                                return restoreScrollDelay();
                              }
                            });
                            append($$anchor8, fragment_7);
                          });
                          var node_8 = sibling(node_6, 2);
                          var render_arg = derived_safe_equal(() => ({
                            props: mergeProps(get(mergedProps), focusScopeProps()),
                            ...contentState.snippetProps
                          }));
                          snippet(node_8, () => $$props.child, () => get(render_arg));
                          append($$anchor7, fragment_6);
                        },
                        ($$anchor7) => {
                          var fragment_8 = root_82();
                          var node_9 = first_child(fragment_8);
                          scroll_lock_default(node_9, {
                            get preventScroll() {
                              return preventScroll();
                            }
                          });
                          var div = sibling(node_9, 2);
                          const spread_with_call = derived(() => mergeProps(get(mergedProps), focusScopeProps()));
                          let attributes;
                          var node_10 = child(div);
                          snippet(node_10, () => $$props.children ?? noop);
                          reset(div);
                          template_effect(() => attributes = set_attributes(div, attributes, { ...get(spread_with_call) }));
                          append($$anchor7, fragment_8);
                        }
                      );
                      append($$anchor6, fragment_5);
                    }),
                    $$slots: { default: true }
                  }));
                  append($$anchor5, fragment_4);
                }),
                $$slots: { default: true }
              }));
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          }));
          append($$anchor3, fragment_2);
        });
        focus_scope_default(node_1, spread_props(
          {
            loop: true,
            get trapFocus() {
              return get(trapFocus_1);
            }
          },
          () => get(mergedProps),
          {
            onCloseAutoFocus: (e) => {
              var _a;
              onCloseAutoFocus()(e);
              if (e.defaultPrevented) return;
              (_a = contentState.root.triggerNode) == null ? void 0 : _a.focus();
            },
            focusScope,
            $$slots: { focusScope: true }
          }
        ));
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(() => get(mergedProps), {
      get forceMount() {
        return forceMount();
      },
      get present() {
        return get(present_1);
      },
      presence,
      $$slots: { presence: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_content = hmr(Dialog_content, () => Dialog_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_content[HMR].source;
    set(Dialog_content[HMR].source, module.default[HMR].original);
  });
}
var dialog_content_default = Dialog_content;
mark_module_end(Dialog_content);

// node_modules/bits-ui/dist/bits/dropdown-menu/exports.js
var exports_exports17 = {};
__export(exports_exports17, {
  Arrow: () => menu_arrow_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => dropdown_menu_content_default,
  ContentStatic: () => dropdown_menu_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menu_trigger_default
});

// node_modules/bits-ui/dist/bits/menu/components/menu.svelte
mark_module_start();
Menu[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu.svelte";
function Menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu);
  validate_prop_bindings($$props, ["open"], [], Menu);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop2), controlledOpen = prop($$props, "controlledOpen", 3, false), variant = prop($$props, "_internal_variant", 3, "dropdown-menu");
  const root17 = useMenuRoot({
    variant: box.with(() => variant()),
    dir: box.with(() => dir()),
    onClose: () => {
      var _a;
      if (controlledOpen()) {
        onOpenChange()(false);
      } else {
        open(false);
        (_a = onOpenChange()) == null ? void 0 : _a(false);
      }
    }
  });
  useMenuMenu(root17, {
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    })
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Menu, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu = hmr(Menu, () => Menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu[HMR].source;
    set(Menu[HMR].source, module.default[HMR].original);
  });
}
var menu_default = Menu;
mark_module_end(Menu);

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte
mark_module_start();
Dropdown_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte";
var root_413 = add_locations(template(`<div><!></div>`), Dropdown_menu_content[FILENAME], [[70, 4]]);
var root_270 = add_locations(template(`<!> <!>`, 1), Dropdown_menu_content[FILENAME], []);
var root_99 = add_locations(template(`<div><!></div>`), Dropdown_menu_content[FILENAME], [[95, 4]]);
var root_75 = add_locations(template(`<!> <!>`, 1), Dropdown_menu_content[FILENAME], []);
function Dropdown_menu_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dropdown_menu_content);
  validate_prop_bindings($$props, ["ref"], [], Dropdown_menu_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const contentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Dropdown_menu_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_270();
          const finalProps = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("dropdown-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_413();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.parentMenu.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Dropdown_menu_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_75();
              const finalProps = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("dropdown-menu")
              }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_99();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.parentMenu.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown_menu_content = hmr(Dropdown_menu_content, () => Dropdown_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown_menu_content[HMR].source;
    set(Dropdown_menu_content[HMR].source, module.default[HMR].original);
  });
}
var dropdown_menu_content_default = Dropdown_menu_content;
mark_module_end(Dropdown_menu_content);

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content-static.svelte
mark_module_start();
Dropdown_menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content-static.svelte";
var root_414 = add_locations(template(`<div><!></div>`), Dropdown_menu_content_static[FILENAME], [[71, 4]]);
var root_271 = add_locations(template(`<!> <!>`, 1), Dropdown_menu_content_static[FILENAME], []);
var root_910 = add_locations(template(`<div><!></div>`), Dropdown_menu_content_static[FILENAME], [[97, 4]]);
var root_76 = add_locations(template(`<!> <!>`, 1), Dropdown_menu_content_static[FILENAME], []);
function Dropdown_menu_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dropdown_menu_content_static);
  validate_prop_bindings($$props, ["ref"], [], Dropdown_menu_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const contentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Dropdown_menu_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_271();
          const finalProps = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("dropdown-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_414();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.parentMenu.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          isStatic: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Dropdown_menu_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_76();
              const finalProps = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("dropdown-menu")
              }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_910();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.parentMenu.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              isStatic: true,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown_menu_content_static = hmr(Dropdown_menu_content_static, () => Dropdown_menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown_menu_content_static[HMR].source;
    set(Dropdown_menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var dropdown_menu_content_static_default = Dropdown_menu_content_static;
mark_module_end(Dropdown_menu_content_static);

// node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte
mark_module_start();
Menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte";
var root_314 = add_locations(template(`<button><!></button>`), Menu_trigger[FILENAME], [[34, 2]]);
function Menu_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_trigger);
  validate_prop_bindings($$props, ["ref"], [], Menu_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "disabled",
      "type"
    ],
    "restProps"
  );
  const triggerState = useMenuDropdownTrigger({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    children: wrap_snippet(Menu_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var button = root_314();
          let attributes;
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
          append($$anchor3, button);
        }
      );
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_trigger = hmr(Menu_trigger, () => Menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_trigger[HMR].source;
    set(Menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var menu_trigger_default = Menu_trigger;
mark_module_end(Menu_trigger);

// node_modules/bits-ui/dist/bits/label/exports.js
var exports_exports18 = {};
__export(exports_exports18, {
  Root: () => label_default
});

// node_modules/bits-ui/dist/bits/label/label.svelte.js
var ROOT_ATTR4 = "data-label-root";
var _id66, _ref66, _onmousedown, _props96;
var LabelRootState = class {
  constructor(props) {
    __privateAdd(this, _id66);
    __privateAdd(this, _ref66);
    __privateAdd(this, _onmousedown, (e) => {
      if (e.detail > 1) e.preventDefault();
    });
    __privateAdd(this, _props96, derived(() => ({
      [ROOT_ATTR4]: "",
      onmousedown: __privateGet(this, _onmousedown)
    })));
    __privateSet(this, _id66, props.id);
    __privateSet(this, _ref66, props.ref);
    useRefById({ id: __privateGet(this, _id66), ref: __privateGet(this, _ref66) });
  }
  get props() {
    return get(__privateGet(this, _props96));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props96)), owner, false);
  }
};
_id66 = new WeakMap();
_ref66 = new WeakMap();
_onmousedown = new WeakMap();
_props96 = new WeakMap();
function setLabelRootState(props) {
  return new LabelRootState(props);
}

// node_modules/bits-ui/dist/bits/label/components/label.svelte
mark_module_start();
Label[FILENAME] = "node_modules/bits-ui/dist/bits/label/components/label.svelte";
var root_272 = add_locations(template(`<label><!></label>`), Label[FILENAME], [[29, 1]]);
function Label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label);
  validate_prop_bindings($$props, ["ref"], [], Label);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "for"
    ],
    "restProps"
  );
  const rootState = setLabelRootState({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props, { for: $$props.for }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var label = root_272();
      let attributes;
      var node_2 = child(label);
      snippet(node_2, () => $$props.children ?? noop);
      reset(label);
      template_effect(() => attributes = set_attributes(label, attributes, { ...get(mergedProps), for: $$props.for }));
      append($$anchor2, label);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Label = hmr(Label, () => Label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Label[HMR].source;
    set(Label[HMR].source, module.default[HMR].original);
  });
}
var label_default = Label;
mark_module_end(Label);

// node_modules/bits-ui/dist/bits/link-preview/exports.js
var exports_exports19 = {};
__export(exports_exports19, {
  Arrow: () => floating_layer_arrow_default,
  Content: () => link_preview_content_default,
  ContentStatic: () => link_preview_content_static_default,
  Portal: () => portal_default,
  Root: () => link_preview_default,
  Trigger: () => link_preview_trigger_default
});

// node_modules/bits-ui/dist/internal/create-event-hook.svelte.js
function createEventHook() {
  const callbacks = /* @__PURE__ */ new Set();
  const callbacksToDispose = [];
  function off(cb) {
    callbacks.delete(cb);
  }
  function on(cb) {
    callbacks.add(cb);
    const offFn = () => off(cb);
    callbacksToDispose.push(offFn);
    return { off: offFn };
  }
  const trigger = (...args) => {
    return Promise.all(Array.from(callbacks).map((cb) => {
      return Promise.resolve(cb(...args));
    }));
  };
  user_effect(() => {
    return () => {
      executeCallbacks(callbacksToDispose);
    };
  });
  return { on, off, trigger };
}

// node_modules/bits-ui/dist/internal/use-grace-area.svelte.js
function useGraceArea(getTriggerNode, getContentNode) {
  const isPointerInTransit = boxAutoReset(false, 300);
  const triggerNode = derived(getTriggerNode);
  const contentNode = derived(getContentNode);
  let pointerGraceArea = state(null);
  const pointerExit = createEventHook();
  function handleRemoveGraceArea() {
    set(pointerGraceArea, null);
    isPointerInTransit.current = false;
  }
  function handleCreateGraceArea(e, hoverTarget) {
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget)) return;
    const exitPoint = { x: e.clientX, y: e.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    set(pointerGraceArea, proxy(graceArea, null, pointerGraceArea));
    isPointerInTransit.current = true;
  }
  user_effect(() => {
    if (!get(triggerNode) || !get(contentNode)) return;
    const handleTriggerLeave = (e) => {
      handleCreateGraceArea(e, get(contentNode));
    };
    const handleContentLeave = (e) => {
      handleCreateGraceArea(e, get(triggerNode));
    };
    const unsub = executeCallbacks(addEventListener2(get(triggerNode), "pointerleave", handleTriggerLeave), addEventListener2(get(contentNode), "pointerleave", handleContentLeave));
    return unsub;
  });
  user_effect(() => {
    if (!get(pointerGraceArea)) return;
    function handleTrackPointerGrace(e) {
      var _a, _b;
      if (!get(pointerGraceArea)) return;
      const target = e.target;
      if (!isElement(target)) return;
      const pointerPosition = { x: e.clientX, y: e.clientY };
      const hasEnteredTarget = ((_a = get(triggerNode)) == null ? void 0 : _a.contains(target)) || ((_b = get(contentNode)) == null ? void 0 : _b.contains(target));
      const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, get(pointerGraceArea));
      if (hasEnteredTarget) {
        handleRemoveGraceArea();
      } else if (isPointerOutsideGraceArea) {
        handleRemoveGraceArea();
        pointerExit.trigger();
      }
    }
    return addEventListener2(document, "pointermove", handleTrackPointerGrace);
  });
  return {
    isPointerInTransit,
    onPointerExit: pointerExit.on
  };
}
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        {
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        {
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        }
      );
      break;
    case "left":
      paddedExitPoints.push(
        {
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        }
      );
      break;
    case "right":
      paddedExitPoints.push(
        {
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        },
        {
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = (i += 1) - 1) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = strict_equals(yi > y, yj > y, false) && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b) => {
    if (a2.x < b.x) return -1;
    else if (a2.x > b.x) return 1;
    else if (a2.y < b.y) return -1;
    else if (a2.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; (i += 1) - 1) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; (i -= 1) + 1) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (strict_equals(upperHull.length, 1) && strict_equals(lowerHull.length, 1) && strict_equals(upperHull[0].x, lowerHull[0].x) && strict_equals(upperHull[0].y, lowerHull[0].y)) return upperHull;
  else return upperHull.concat(lowerHull);
}

// node_modules/bits-ui/dist/bits/link-preview/link-preview.svelte.js
var CONTENT_ATTR = "data-link-preview-content";
var TRIGGER_ATTR = "data-link-preview-trigger";
var _hasSelection, _isPointerDownOnContent, _containsSelection, _contentNode6, _contentId4, _contentMounted, _triggerNode5, _isOpening;
var LinkPreviewRootState = class {
  constructor(props) {
    __publicField(this, "open");
    __publicField(this, "openDelay");
    __publicField(this, "closeDelay");
    __privateAdd(this, _hasSelection, state(false));
    __privateAdd(this, _isPointerDownOnContent, state(false));
    __privateAdd(this, _containsSelection, state(false));
    __publicField(this, "timeout", null);
    __privateAdd(this, _contentNode6, state(null));
    __privateAdd(this, _contentId4, state(void 0));
    __privateAdd(this, _contentMounted, state(false));
    __privateAdd(this, _triggerNode5, state(null));
    __publicField(this, "isPointerInTransit", box(false));
    __privateAdd(this, _isOpening, state(false));
    __publicField(this, "clearTimeout", () => {
      if (this.timeout) {
        window.clearTimeout(this.timeout);
        this.timeout = null;
      }
    });
    __publicField(this, "handleOpen", () => {
      this.clearTimeout();
      if (this.open.current) return;
      this.isOpening = true;
      this.timeout = window.setTimeout(
        () => {
          if (this.isOpening) {
            this.open.current = true;
            this.isOpening = false;
          }
        },
        this.openDelay.current
      );
    });
    __publicField(this, "immediateClose", () => {
      this.clearTimeout();
      this.isOpening = false;
      this.open.current = false;
    });
    __publicField(this, "handleClose", () => {
      this.isOpening = false;
      this.clearTimeout();
      if (!this.isPointerDownOnContent && !this.hasSelection) {
        this.timeout = window.setTimeout(
          () => {
            this.open.current = false;
          },
          this.closeDelay.current
        );
      }
    });
    this.open = props.open;
    this.openDelay = props.openDelay;
    this.closeDelay = props.closeDelay;
    user_effect(() => {
      if (!this.open.current) {
        untrack(() => this.hasSelection = false);
        return;
      }
      const handlePointerUp = () => {
        this.containsSelection = false;
        this.isPointerDownOnContent = false;
        afterSleep(1, () => {
          var _a;
          const isSelection = strict_equals((_a = document.getSelection()) == null ? void 0 : _a.toString(), "", false);
          if (isSelection) {
            this.hasSelection = true;
          } else {
            this.hasSelection = false;
          }
        });
      };
      const unsubListener = addEventListener2(document, "pointerup", handlePointerUp);
      const contentNode = untrack(() => this.contentNode);
      if (!contentNode) return;
      const tabCandidates = getTabbableCandidates(contentNode);
      for (const candidate of tabCandidates) {
        candidate.setAttribute("tabindex", "-1");
      }
      return () => {
        unsubListener();
        this.hasSelection = false;
        this.isPointerDownOnContent = false;
      };
    });
  }
  get hasSelection() {
    return get(__privateGet(this, _hasSelection));
  }
  set hasSelection(value) {
    set(__privateGet(this, _hasSelection), proxy(value, null, __privateGet(this, _hasSelection)));
  }
  get isPointerDownOnContent() {
    return get(__privateGet(this, _isPointerDownOnContent));
  }
  set isPointerDownOnContent(value) {
    set(__privateGet(this, _isPointerDownOnContent), proxy(value, null, __privateGet(this, _isPointerDownOnContent)));
  }
  get containsSelection() {
    return get(__privateGet(this, _containsSelection));
  }
  set containsSelection(value) {
    set(__privateGet(this, _containsSelection), proxy(value, null, __privateGet(this, _containsSelection)));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode6));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode6), proxy(value, null, __privateGet(this, _contentNode6)));
  }
  get contentId() {
    return get(__privateGet(this, _contentId4));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId4), proxy(value, null, __privateGet(this, _contentId4)));
  }
  get contentMounted() {
    return get(__privateGet(this, _contentMounted));
  }
  set contentMounted(value) {
    set(__privateGet(this, _contentMounted), proxy(value, null, __privateGet(this, _contentMounted)));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode5));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode5), proxy(value, null, __privateGet(this, _triggerNode5)));
  }
  get isOpening() {
    return get(__privateGet(this, _isOpening));
  }
  set isOpening(value) {
    set(__privateGet(this, _isOpening), proxy(value, null, __privateGet(this, _isOpening)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _hasSelection)), owner, false);
    add_owner(get(__privateGet(this, _isPointerDownOnContent)), owner, false);
    add_owner(get(__privateGet(this, _containsSelection)), owner, false);
    add_owner(get(__privateGet(this, _contentNode6)), owner, false);
    add_owner(get(__privateGet(this, _contentId4)), owner, false);
    add_owner(get(__privateGet(this, _contentMounted)), owner, false);
    add_owner(get(__privateGet(this, _triggerNode5)), owner, false);
    add_owner(get(__privateGet(this, _isOpening)), owner, false);
  }
};
_hasSelection = new WeakMap();
_isPointerDownOnContent = new WeakMap();
_containsSelection = new WeakMap();
_contentNode6 = new WeakMap();
_contentId4 = new WeakMap();
_contentMounted = new WeakMap();
_triggerNode5 = new WeakMap();
_isOpening = new WeakMap();
var _id67, _ref67, _root32, _onpointerenter, _onpointerleave4, _onfocus5, _onblur4, _props97;
var LinkPreviewTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _id67);
    __privateAdd(this, _ref67);
    __privateAdd(this, _root32);
    __privateAdd(this, _onpointerenter, (e) => {
      if (isTouch(e)) return;
      __privateGet(this, _root32).handleOpen();
    });
    __privateAdd(this, _onpointerleave4, (e) => {
      if (isTouch(e)) return;
      if (!__privateGet(this, _root32).contentMounted) {
        __privateGet(this, _root32).immediateClose();
      }
    });
    __privateAdd(this, _onfocus5, (e) => {
      if (!isFocusVisible(e.currentTarget)) return;
      __privateGet(this, _root32).handleOpen();
    });
    __privateAdd(this, _onblur4, () => {
      __privateGet(this, _root32).handleClose();
    });
    __privateAdd(this, _props97, derived(() => ({
      id: __privateGet(this, _id67).current,
      "aria-haspopup": "dialog",
      "aria-expanded": getAriaExpanded(__privateGet(this, _root32).open.current),
      "data-state": getDataOpenClosed(__privateGet(this, _root32).open.current),
      "aria-controls": __privateGet(this, _root32).contentId,
      role: "button",
      [TRIGGER_ATTR]: "",
      onpointerenter: __privateGet(this, _onpointerenter),
      onfocus: __privateGet(this, _onfocus5),
      onblur: __privateGet(this, _onblur4),
      onpointerleave: __privateGet(this, _onpointerleave4)
    })));
    __privateSet(this, _id67, props.id);
    __privateSet(this, _ref67, props.ref);
    __privateSet(this, _root32, root17);
    useRefById({
      id: __privateGet(this, _id67),
      ref: __privateGet(this, _ref67),
      onRefChange: (node) => {
        __privateGet(this, _root32).triggerNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props97));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props97)), owner, false);
  }
};
_id67 = new WeakMap();
_ref67 = new WeakMap();
_root32 = new WeakMap();
_onpointerenter = new WeakMap();
_onpointerleave4 = new WeakMap();
_onfocus5 = new WeakMap();
_onblur4 = new WeakMap();
_props97 = new WeakMap();
var _id68, _ref68, _onpointerdown15, _onpointerenter2, _onfocusout7, _snippetProps17, _props98;
var LinkPreviewContentState = class {
  constructor(props, root17) {
    __privateAdd(this, _id68);
    __privateAdd(this, _ref68);
    __publicField(this, "root");
    __privateAdd(this, _onpointerdown15, (e) => {
      const target = e.target;
      if (!isElement(target)) return;
      if (e.currentTarget.contains(target)) {
        this.root.containsSelection = true;
      }
      this.root.hasSelection = true;
      this.root.isPointerDownOnContent = true;
    });
    __privateAdd(this, _onpointerenter2, (e) => {
      if (isTouch(e)) return;
      this.root.handleOpen();
    });
    __privateAdd(this, _onfocusout7, (e) => {
      e.preventDefault();
    });
    __privateAdd(this, _snippetProps17, derived(() => ({ open: this.root.open.current })));
    __privateAdd(this, _props98, derived(() => ({
      id: __privateGet(this, _id68).current,
      tabindex: -1,
      "data-state": getDataOpenClosed(this.root.open.current),
      [CONTENT_ATTR]: "",
      onpointerdown: __privateGet(this, _onpointerdown15),
      onpointerenter: __privateGet(this, _onpointerenter2),
      onfocusout: __privateGet(this, _onfocusout7)
    })));
    __privateSet(this, _id68, props.id);
    __privateSet(this, _ref68, props.ref);
    this.root = root17;
    useRefById({
      id: __privateGet(this, _id68),
      ref: __privateGet(this, _ref68),
      onRefChange: (node) => {
        this.root.contentNode = node;
        this.root.contentId = node == null ? void 0 : node.id;
      },
      deps: () => this.root.open.current
    });
    user_effect(() => {
      if (!this.root.open.current) return;
      const { isPointerInTransit, onPointerExit } = useGraceArea(() => this.root.triggerNode, () => __privateGet(this, _ref68).current);
      this.root.isPointerInTransit = isPointerInTransit;
      onPointerExit(() => {
        this.root.handleClose();
      });
    });
    onDestroyEffect(() => {
      this.root.clearTimeout();
    });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps17));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props98));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps17)), owner, false);
    add_owner(get(__privateGet(this, _props98)), owner, false);
  }
};
_id68 = new WeakMap();
_ref68 = new WeakMap();
_onpointerdown15 = new WeakMap();
_onpointerenter2 = new WeakMap();
_onfocusout7 = new WeakMap();
_snippetProps17 = new WeakMap();
_props98 = new WeakMap();
var [
  setLinkPreviewRootContext,
  getLinkPreviewRootContext
] = createContext("LinkPreview.Root");
function useLinkPreviewRoot(props) {
  return setLinkPreviewRootContext(new LinkPreviewRootState(props));
}
function useLinkPreviewTrigger(props) {
  return new LinkPreviewTriggerState(props, getLinkPreviewRootContext());
}
function useLinkPreviewContent(props) {
  return new LinkPreviewContentState(props, getLinkPreviewRootContext());
}

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte
mark_module_start();
Link_preview[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte";
function Link_preview($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link_preview);
  validate_prop_bindings($$props, ["open"], [], Link_preview);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), openDelay = prop($$props, "openDelay", 3, 700), closeDelay = prop($$props, "closeDelay", 3, 300), controlledOpen = prop($$props, "controlledOpen", 3, false);
  useLinkPreviewRoot({
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    }),
    openDelay: box.with(() => openDelay()),
    closeDelay: box.with(() => closeDelay())
  });
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Root, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      children: wrap_snippet(Link_preview, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop);
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview = hmr(Link_preview, () => Link_preview[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview[HMR].source;
    set(Link_preview[HMR].source, module.default[HMR].original);
  });
}
var link_preview_default = Link_preview;
mark_module_end(Link_preview);

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte
mark_module_start();
Link_preview_content[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte";
var root_415 = add_locations(template(`<div><!></div>`), Link_preview_content[FILENAME], [[85, 4]]);
var root_911 = add_locations(template(`<div><!></div>`), Link_preview_content[FILENAME], [[112, 4]]);
var root_77 = add_locations(template(`<!> <!>`, 1), Link_preview_content[FILENAME], []);
function Link_preview_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link_preview_content);
  validate_prop_bindings($$props, ["ref"], [], Link_preview_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = useLinkPreviewContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const floatingProps = derived(() => ({
    side: side(),
    sideOffset: sideOffset(),
    align: align(),
    avoidCollisions: avoidCollisions(),
    arrowPadding: arrowPadding(),
    sticky: sticky(),
    hideWhenDetached: hideWhenDetached(),
    collisionPadding: collisionPadding()
  }));
  const mergedProps = derived(() => mergeProps(restProps, get(floatingProps), contentState.props));
  function handleInteractOutside(e) {
    var _a;
    (_a = $$props.onInteractOutside) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  function handleEscapeKeydown(e) {
    var _a;
    (_a = $$props.onEscapeKeydown) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Link_preview_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("link-preview")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_415();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps2) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.root.open.current;
          },
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onOpenAutoFocus: (e) => e.preventDefault(),
          onCloseAutoFocus: (e) => e.preventDefault(),
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Link_preview_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_77();
              const mergedProps2 = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("link-preview")
              }));
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_911();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(mergedProps2) }));
                  append($$anchor5, div_1);
                }
              );
              var node_10 = sibling(node_7, 2);
              mounted_default(node_10, {
                onMountedChange: (m) => contentState.root.contentMounted = m
              });
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.root.open.current;
              },
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onOpenAutoFocus: (e) => e.preventDefault(),
              onCloseAutoFocus: (e) => e.preventDefault(),
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_content = hmr(Link_preview_content, () => Link_preview_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_content[HMR].source;
    set(Link_preview_content[HMR].source, module.default[HMR].original);
  });
}
var link_preview_content_default = Link_preview_content;
mark_module_end(Link_preview_content);

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte
mark_module_start();
Link_preview_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte";
var root_315 = add_locations(template(`<a><!></a>`), Link_preview_trigger[FILENAME], [[31, 2]]);
function Link_preview_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link_preview_trigger);
  validate_prop_bindings($$props, ["ref"], [], Link_preview_trigger);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const triggerState = useLinkPreviewTrigger({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      children: wrap_snippet(Link_preview_trigger, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        if_block(
          node_1,
          () => $$props.child,
          ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          },
          ($$anchor4) => {
            var a2 = root_315();
            let attributes;
            var node_3 = child(a2);
            snippet(node_3, () => $$props.children ?? noop);
            reset(a2);
            template_effect(() => attributes = set_attributes(a2, attributes, { ...get(mergedProps) }));
            append($$anchor4, a2);
          }
        );
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_trigger = hmr(Link_preview_trigger, () => Link_preview_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_trigger[HMR].source;
    set(Link_preview_trigger[HMR].source, module.default[HMR].original);
  });
}
var link_preview_trigger_default = Link_preview_trigger;
mark_module_end(Link_preview_trigger);

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content-static.svelte
mark_module_start();
Link_preview_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content-static.svelte";
var root_416 = add_locations(template(`<div><!></div>`), Link_preview_content_static[FILENAME], [[85, 4]]);
var root_912 = add_locations(template(`<div><!></div>`), Link_preview_content_static[FILENAME], [[113, 4]]);
function Link_preview_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link_preview_content_static);
  validate_prop_bindings($$props, ["ref"], [], Link_preview_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = useLinkPreviewContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const floatingProps = derived(() => ({
    side: side(),
    sideOffset: sideOffset(),
    align: align(),
    avoidCollisions: avoidCollisions(),
    arrowPadding: arrowPadding(),
    sticky: sticky(),
    hideWhenDetached: hideWhenDetached(),
    collisionPadding: collisionPadding()
  }));
  const mergedProps = derived(() => mergeProps(restProps, get(floatingProps), contentState.props));
  function handleInteractOutside(e) {
    var _a;
    (_a = $$props.onInteractOutside) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  function handleEscapeKeydown(e) {
    var _a;
    (_a = $$props.onEscapeKeydown) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Link_preview_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("link-preview")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_416();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps2) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.root.open.current;
          },
          isStatic: true,
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onOpenAutoFocus: (e) => e.preventDefault(),
          onCloseAutoFocus: (e) => e.preventDefault(),
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Link_preview_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = comment();
              const mergedProps2 = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("link-preview")
              }));
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_912();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(mergedProps2) }));
                  append($$anchor5, div_1);
                }
              );
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.root.open.current;
              },
              isStatic: true,
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onOpenAutoFocus: (e) => e.preventDefault(),
              onCloseAutoFocus: (e) => e.preventDefault(),
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_content_static = hmr(Link_preview_content_static, () => Link_preview_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_content_static[HMR].source;
    set(Link_preview_content_static[HMR].source, module.default[HMR].original);
  });
}
var link_preview_content_static_default = Link_preview_content_static;
mark_module_end(Link_preview_content_static);

// node_modules/bits-ui/dist/bits/menubar/exports.js
var exports_exports20 = {};
__export(exports_exports20, {
  Arrow: () => menu_arrow_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => menubar_content_default,
  ContentStatic: () => menubar_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Menu: () => menubar_menu_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menubar_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menubar_trigger_default
});

// node_modules/bits-ui/dist/bits/menubar/menubar.svelte.js
var ROOT_ATTR5 = "data-menubar-root";
var TRIGGER_ATTR2 = "data-menubar-trigger";
var _wasOpenedByKeyboard, _triggerIds, _props99;
var MenubarRootState = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "value");
    __publicField(this, "dir");
    __publicField(this, "loop");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "currentTabStopId", box(null));
    __privateAdd(this, _wasOpenedByKeyboard, state(false));
    __privateAdd(this, _triggerIds, state(proxy([])));
    __publicField(this, "valueToContentId", /* @__PURE__ */ new Map());
    __publicField(this, "registerTrigger", (id) => {
      this.triggerIds.push(id);
    });
    __publicField(this, "deRegisterTrigger", (id) => {
      this.triggerIds = this.triggerIds.filter((triggerId) => strict_equals(triggerId, id, false));
    });
    __publicField(this, "getTriggers", () => {
      const node = this.ref.current;
      if (!node) return [];
      return Array.from(node.querySelectorAll(`[${TRIGGER_ATTR2}]`));
    });
    __publicField(this, "onMenuOpen", (id) => {
      this.value.current = id;
      this.currentTabStopId.current = id;
    });
    __publicField(this, "onMenuClose", () => {
      this.value.current = "";
    });
    __publicField(this, "onMenuToggle", (id) => {
      this.value.current = this.value.current ? "" : id;
    });
    __privateAdd(this, _props99, derived(() => ({
      id: this.id.current,
      role: "menubar",
      [ROOT_ATTR5]: ""
    })));
    this.value = props.value;
    this.dir = props.dir;
    this.loop = props.loop;
    this.id = props.id;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
    this.rovingFocusGroup = useRovingFocus({
      rootNodeId: this.id,
      candidateAttr: TRIGGER_ATTR2,
      loop: this.loop,
      orientation: box.with(() => "horizontal"),
      currentTabStopId: this.currentTabStopId
    });
  }
  get wasOpenedByKeyboard() {
    return get(__privateGet(this, _wasOpenedByKeyboard));
  }
  set wasOpenedByKeyboard(value) {
    set(__privateGet(this, _wasOpenedByKeyboard), proxy(value, null, __privateGet(this, _wasOpenedByKeyboard)));
  }
  get triggerIds() {
    return get(__privateGet(this, _triggerIds));
  }
  set triggerIds(value) {
    set(__privateGet(this, _triggerIds), proxy(value, null, __privateGet(this, _triggerIds)));
  }
  get props() {
    return get(__privateGet(this, _props99));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _wasOpenedByKeyboard)), owner, false);
    add_owner(get(__privateGet(this, _triggerIds)), owner, false);
    add_owner(get(__privateGet(this, _props99)), owner, false);
  }
};
_wasOpenedByKeyboard = new WeakMap();
_triggerIds = new WeakMap();
_props99 = new WeakMap();
var _open, _wasOpenedByKeyboard2, _triggerNode6, _contentNode7;
var MenubarMenuState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __publicField(this, "value");
    __privateAdd(this, _open, derived(() => strict_equals(this.root.value.current, this.value.current)));
    __privateAdd(this, _wasOpenedByKeyboard2, state(false));
    __privateAdd(this, _triggerNode6, state(null));
    __privateAdd(this, _contentNode7, state(null));
    __publicField(this, "getTriggerNode", () => {
      if (!isBrowser) return null;
      return this.triggerNode;
    });
    __publicField(this, "getContentNode", () => {
      return this.contentNode;
    });
    this.value = props.value;
    this.root = root17;
    user_effect(() => {
      if (!this.open) {
        untrack(() => {
          this.wasOpenedByKeyboard = false;
        });
      }
    });
    user_effect(() => {
      untrack(() => {
        this.root.valueToContentId.set(this.value.current, box.with(() => {
          var _a;
          return ((_a = this.contentNode) == null ? void 0 : _a.id) ?? "";
        }));
      });
      return () => {
        this.root.valueToContentId.delete(this.value.current);
      };
    });
  }
  get open() {
    return get(__privateGet(this, _open));
  }
  set open(_) {
    throw new Error("Cannot update a derived property ('open')");
  }
  get wasOpenedByKeyboard() {
    return get(__privateGet(this, _wasOpenedByKeyboard2));
  }
  set wasOpenedByKeyboard(value) {
    set(__privateGet(this, _wasOpenedByKeyboard2), proxy(value, null, __privateGet(this, _wasOpenedByKeyboard2)));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode6));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode6), proxy(value, null, __privateGet(this, _triggerNode6)));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode7));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode7), proxy(value, null, __privateGet(this, _contentNode7)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _open)), owner, false);
    add_owner(get(__privateGet(this, _wasOpenedByKeyboard2)), owner, false);
    add_owner(get(__privateGet(this, _triggerNode6)), owner, false);
    add_owner(get(__privateGet(this, _contentNode7)), owner, false);
  }
};
_open = new WeakMap();
_wasOpenedByKeyboard2 = new WeakMap();
_triggerNode6 = new WeakMap();
_contentNode7 = new WeakMap();
var _isFocused3, _tabIndex, _onpointerdown16, _onpointerenter3, _onkeydown29, _onfocus6, _onblur5, _props100;
var MenubarTriggerState = class {
  constructor(props, menu) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "disabled");
    __publicField(this, "menu");
    __publicField(this, "root");
    __privateAdd(this, _isFocused3, state(false));
    __privateAdd(this, _tabIndex, state(0));
    __privateAdd(this, _onpointerdown16, (e) => {
      if (!this.disabled.current && strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
        if (!this.menu.open) {
          e.preventDefault();
        }
        this.root.onMenuOpen(this.menu.value.current);
      }
    });
    __privateAdd(this, _onpointerenter3, () => {
      var _a;
      const isMenubarOpen = Boolean(this.root.value.current);
      if (isMenubarOpen && !this.menu.open) {
        this.root.onMenuOpen(this.menu.value.current);
        (_a = this.menu.getTriggerNode()) == null ? void 0 : _a.focus();
      }
    });
    __privateAdd(this, _onkeydown29, (e) => {
      if (this.disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
        this.root.onMenuToggle(this.menu.value.current);
      }
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        this.root.onMenuOpen(this.menu.value.current);
      }
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        this.menu.wasOpenedByKeyboard = true;
        e.preventDefault();
      }
      this.root.rovingFocusGroup.handleKeydown(this.menu.getTriggerNode(), e);
    });
    __privateAdd(this, _onfocus6, () => {
      this.isFocused = true;
    });
    __privateAdd(this, _onblur5, () => {
      this.isFocused = false;
    });
    __privateAdd(this, _props100, derived(() => {
      var _a;
      return {
        type: "button",
        role: "menuitem",
        id: this.id.current,
        "aria-haspopup": "menu",
        "aria-expanded": getAriaExpanded(this.menu.open),
        "aria-controls": this.menu.open ? (_a = this.menu.contentNode) == null ? void 0 : _a.id : void 0,
        "data-highlighted": this.isFocused ? "" : void 0,
        "data-state": getDataOpenClosed(this.menu.open),
        "data-disabled": getDataDisabled(this.disabled.current),
        "data-menu-value": this.menu.value.current,
        disabled: this.disabled.current ? true : void 0,
        tabIndex: get(__privateGet(this, _tabIndex)),
        [TRIGGER_ATTR2]: "",
        onpointerdown: __privateGet(this, _onpointerdown16),
        onpointerenter: __privateGet(this, _onpointerenter3),
        onkeydown: __privateGet(this, _onkeydown29),
        onfocus: __privateGet(this, _onfocus6),
        onblur: __privateGet(this, _onblur5)
      };
    }));
    this.disabled = props.disabled;
    this.menu = menu;
    this.id = props.id;
    this.ref = props.ref;
    this.root = menu.root;
    useRefById({
      id: this.id,
      ref: this.ref,
      onRefChange: (node) => {
        this.menu.triggerNode = node;
      }
    });
    user_effect(() => {
      untrack(() => {
        this.root.registerTrigger(props.id.current);
      });
      return () => {
        this.root.deRegisterTrigger(props.id.current);
      };
    });
    user_effect(() => {
      if (this.root.triggerIds.length) {
        set(__privateGet(this, _tabIndex), proxy(this.root.rovingFocusGroup.getTabIndex(this.menu.getTriggerNode()), null, __privateGet(this, _tabIndex)));
      }
    });
  }
  get isFocused() {
    return get(__privateGet(this, _isFocused3));
  }
  set isFocused(value) {
    set(__privateGet(this, _isFocused3), proxy(value, null, __privateGet(this, _isFocused3)));
  }
  get props() {
    return get(__privateGet(this, _props100));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isFocused3)), owner, false);
    add_owner(get(__privateGet(this, _props100)), owner, false);
  }
};
_isFocused3 = new WeakMap();
_tabIndex = new WeakMap();
_onpointerdown16 = new WeakMap();
_onpointerenter3 = new WeakMap();
_onkeydown29 = new WeakMap();
_onfocus6 = new WeakMap();
_onblur5 = new WeakMap();
_props100 = new WeakMap();
var _hasInteractedOutside, _onkeydown30, _props101;
var MenubarContentState = class {
  constructor(props, menu) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "menu");
    __publicField(this, "root");
    __privateAdd(this, _hasInteractedOutside, state(false));
    __publicField(this, "interactOutsideBehavior");
    __publicField(this, "onCloseAutoFocus", (e) => {
      var _a;
      const menubarOpen = Boolean(this.root.value.current);
      if (!menubarOpen && !this.hasInteractedOutside) {
        (_a = this.menu.getTriggerNode()) == null ? void 0 : _a.focus();
      }
      this.hasInteractedOutside = false;
      e.preventDefault();
    });
    __publicField(this, "onFocusOutside", (e) => {
      const target = e.target;
      const isMenubarTrigger = this.root.getTriggers().some((trigger) => trigger.contains(target));
      if (isMenubarTrigger) e.preventDefault();
    });
    __publicField(this, "onInteractOutside", () => {
      this.hasInteractedOutside = true;
    });
    __publicField(this, "onOpenAutoFocus", () => {
      afterTick(() => {
        var _a;
        return (_a = this.ref.current) == null ? void 0 : _a.focus();
      });
    });
    __privateAdd(this, _onkeydown30, (e) => {
      if (strict_equals(e.key, kbd_constants_exports.ARROW_LEFT, false) && strict_equals(e.key, kbd_constants_exports.ARROW_RIGHT, false)) return;
      const target = e.target;
      const targetIsSubTrigger = target.hasAttribute("data-menu-sub-trigger");
      const isKeydownInsideSubMenu = strict_equals(target.closest("[data-menu-content]"), e.currentTarget, false);
      const prevMenuKey = strict_equals(this.root.dir.current, "rtl") ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT;
      const isPrevKey = strict_equals(prevMenuKey, e.key);
      const isNextKey = !isPrevKey;
      if (isNextKey && targetIsSubTrigger) return;
      if (isKeydownInsideSubMenu && isPrevKey) return;
      const items = this.root.getTriggers().filter((trigger) => !trigger.disabled);
      let candidateValues = items.map((item) => item.getAttribute("data-menu-value"));
      if (isPrevKey) candidateValues.reverse();
      const currentIndex = candidateValues.indexOf(this.menu.value.current);
      candidateValues = this.root.loop.current ? wrapArray(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
      const [nextValue] = candidateValues;
      if (nextValue) this.root.onMenuOpen(nextValue);
    });
    __privateAdd(this, _props101, derived(() => {
      var _a;
      return {
        id: this.id.current,
        "aria-labelledby": (_a = this.menu.triggerNode) == null ? void 0 : _a.id,
        style: {
          "--bits-menubar-content-transform-origin": "var(--bits-floating-transform-origin)",
          "--bits-menubar-content-available-width": "var(--bits-floating-available-width)",
          "--bits-menubar-content-available-height": "var(--bits-floating-available-height)",
          "--bits-menubar-anchor-width": "var(--bits-floating-anchor-width)",
          "--bits-menubar-anchor-height": "var(--bits-floating-anchor-height)"
        },
        onkeydown: __privateGet(this, _onkeydown30)
      };
    }));
    this.interactOutsideBehavior = props.interactOutsideBehavior;
    this.menu = menu;
    this.id = props.id;
    this.ref = props.ref;
    this.root = menu.root;
    useRefById({
      id: this.id,
      ref: this.ref,
      onRefChange: (node) => {
        this.menu.contentNode = node;
      },
      deps: () => this.menu.open
    });
  }
  get hasInteractedOutside() {
    return get(__privateGet(this, _hasInteractedOutside));
  }
  set hasInteractedOutside(value) {
    set(__privateGet(this, _hasInteractedOutside), proxy(value, null, __privateGet(this, _hasInteractedOutside)));
  }
  get props() {
    return get(__privateGet(this, _props101));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _hasInteractedOutside)), owner, false);
    add_owner(get(__privateGet(this, _props101)), owner, false);
  }
};
_hasInteractedOutside = new WeakMap();
_onkeydown30 = new WeakMap();
_props101 = new WeakMap();
var [setMenubarRootContext, getMenubarRootContext] = createContext("Menubar.Root");
var [setMenubarMenuContext, getMenubarMenuContext] = createContext("Menubar.Menu");
function useMenubarRoot(props) {
  return setMenubarRootContext(new MenubarRootState(props));
}
function useMenubarMenu(props) {
  return setMenubarMenuContext(new MenubarMenuState(props, getMenubarRootContext()));
}
function useMenubarTrigger(props) {
  return new MenubarTriggerState(props, getMenubarMenuContext());
}
function useMenubarContent(props) {
  return new MenubarContentState(props, getMenubarMenuContext());
}

// node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte
mark_module_start();
Menubar[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte";
var root_273 = add_locations(template(`<div><!></div>`), Menubar[FILENAME], [[48, 1]]);
function Menubar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menubar);
  validate_prop_bindings($$props, ["ref"], [], Menubar);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 7, ""), dir = prop($$props, "dir", 3, "ltr"), loop = prop($$props, "loop", 3, true), onValueChange = prop($$props, "onValueChange", 3, noop2), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "dir",
      "loop",
      "onValueChange",
      "controlledValue"
    ],
    "restProps"
  );
  const rootState = useMenubarRoot({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      var _a;
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        (_a = onValueChange()) == null ? void 0 : _a(v);
      }
    }),
    dir: box.with(() => dir()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_273();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar = hmr(Menubar, () => Menubar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar[HMR].source;
    set(Menubar[HMR].source, module.default[HMR].original);
  });
}
var menubar_default = Menubar;
mark_module_end(Menubar);

// node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte
mark_module_start();
Menubar_menu[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte";
function Menubar_menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menubar_menu);
  validate_prop_bindings($$props, [], [], Menubar_menu);
  let value = prop($$props, "value", 19, useId), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "value"], "restProps");
  const menuState = useMenubarMenu({ value: box.with(() => value()) });
  var fragment = comment();
  var node = first_child(fragment);
  menu_default(node, spread_props(
    {
      get open() {
        return menuState.open;
      },
      onOpenChange: (open) => {
        if (!open) menuState.root.onMenuClose();
      },
      get dir() {
        return menuState.root.dir.current;
      },
      _internal_variant: "menubar"
    },
    () => restProps
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_menu = hmr(Menubar_menu, () => Menubar_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_menu[HMR].source;
    set(Menubar_menu[HMR].source, module.default[HMR].original);
  });
}
var menubar_menu_default = Menubar_menu;
mark_module_end(Menubar_menu);

// node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte
mark_module_start();
Menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte";
var root_417 = add_locations(template(`<div><!></div>`), Menu_content[FILENAME], [[76, 4]]);
var root_274 = add_locations(template(`<!> <!>`, 1), Menu_content[FILENAME], []);
var root_913 = add_locations(template(`<div><!></div>`), Menu_content[FILENAME], [[104, 4]]);
var root_78 = add_locations(template(`<!> <!>`, 1), Menu_content[FILENAME], []);
function Menu_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_content);
  validate_prop_bindings($$props, ["ref"], [], Menu_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const contentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } }));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_274();
          const finalProps = derived(() => mergeProps(props(), {
            style: {
              outline: "none",
              ...getFloatingContentCSSVars("menu")
            }
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_417();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.parentMenu.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_78();
              const finalProps = derived(() => mergeProps(props(), {
                style: {
                  outline: "none",
                  ...getFloatingContentCSSVars("menu")
                }
              }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_913();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.parentMenu.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_content = hmr(Menu_content, () => Menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_content[HMR].source;
    set(Menu_content[HMR].source, module.default[HMR].original);
  });
}
var menu_content_default = Menu_content;
mark_module_end(Menu_content);

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content.svelte
mark_module_start();
Menubar_content[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-content.svelte";
function Menubar_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menubar_content);
  validate_prop_bindings($$props, ["ref"], [], Menubar_content);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "interactOutsideBehavior",
      "id"
    ],
    "restProps"
  );
  const contentState = useMenubarContent({
    id: box.with(() => id()),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, menu_content_default);
    menu_content_default(node, spread_props(
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      },
      () => get(mergedProps),
      {
        preventScroll: false,
        get onInteractOutside() {
          return contentState.onInteractOutside;
        },
        get onFocusOutside() {
          return contentState.onFocusOutside;
        },
        get onCloseAutoFocus() {
          return contentState.onCloseAutoFocus;
        },
        get onOpenAutoFocus() {
          return contentState.onOpenAutoFocus;
        }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_content = hmr(Menubar_content, () => Menubar_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_content[HMR].source;
    set(Menubar_content[HMR].source, module.default[HMR].original);
  });
}
var menubar_content_default = Menubar_content;
mark_module_end(Menubar_content);

// node_modules/bits-ui/dist/bits/menu/components/menu-content-static.svelte
mark_module_start();
Menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-content-static.svelte";
var root_418 = add_locations(template(`<div><!></div>`), Menu_content_static[FILENAME], [[77, 4]]);
var root_275 = add_locations(template(`<!> <!>`, 1), Menu_content_static[FILENAME], []);
var root_914 = add_locations(template(`<div><!></div>`), Menu_content_static[FILENAME], [[106, 4]]);
var root_79 = add_locations(template(`<!> <!>`, 1), Menu_content_static[FILENAME], []);
function Menu_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_content_static);
  validate_prop_bindings($$props, ["ref"], [], Menu_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop2), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop2), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const contentState = useMenuContent({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isMounted: box.with(() => get(isMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } }));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = root_275();
          const finalProps = derived(() => mergeProps(props(), {
            style: {
              outline: "none",
              ...getFloatingContentCSSVars("menu")
            }
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_418();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(finalProps) }));
              append($$anchor4, div);
            }
          );
          var node_5 = sibling(node_2, 2);
          {
            add_owner_effect(() => get(isMounted), mounted_default);
            mounted_default(node_5, {
              get isMounted() {
                return get(isMounted);
              },
              set isMounted($$value) {
                set(isMounted, proxy($$value, null, isMounted));
              }
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.parentMenu.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          isStatic: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      if_block(
        node_6,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = root_79();
              const finalProps = derived(() => mergeProps(props(), {
                style: {
                  outline: "none",
                  ...getFloatingContentCSSVars("menu")
                }
              }));
              get(finalProps);
              var node_8 = first_child(fragment_6);
              if_block(
                node_8,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_9 = first_child(fragment_7);
                  snippet(node_9, () => $$props.child, () => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_914();
                  let attributes_1;
                  var node_10 = child(div_1);
                  snippet(node_10, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(finalProps) }));
                  append($$anchor5, div_1);
                }
              );
              var node_11 = sibling(node_8, 2);
              {
                add_owner_effect(() => get(isMounted), mounted_default);
                mounted_default(node_11, {
                  get isMounted() {
                    return get(isMounted);
                  },
                  set isMounted($$value) {
                    set(isMounted, proxy($$value, null, isMounted));
                  }
                });
              }
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_7, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.parentMenu.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              isStatic: true,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_content_static = hmr(Menu_content_static, () => Menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_content_static[HMR].source;
    set(Menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var menu_content_static_default = Menu_content_static;
mark_module_end(Menu_content_static);

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content-static.svelte
mark_module_start();
Menubar_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-content-static.svelte";
function Menubar_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menubar_content_static);
  validate_prop_bindings($$props, ["ref"], [], Menubar_content_static);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "interactOutsideBehavior",
      "id"
    ],
    "restProps"
  );
  const contentState = useMenubarContent({
    id: box.with(() => id()),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, menu_content_static_default);
    menu_content_static_default(node, spread_props(
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      },
      () => get(mergedProps),
      {
        preventScroll: false,
        get onInteractOutside() {
          return contentState.onInteractOutside;
        },
        get onFocusOutside() {
          return contentState.onFocusOutside;
        },
        get onCloseAutoFocus() {
          return contentState.onCloseAutoFocus;
        },
        get onOpenAutoFocus() {
          return contentState.onOpenAutoFocus;
        }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_content_static = hmr(Menubar_content_static, () => Menubar_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_content_static[HMR].source;
    set(Menubar_content_static[HMR].source, module.default[HMR].original);
  });
}
var menubar_content_static_default = Menubar_content_static;
mark_module_end(Menubar_content_static);

// node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte
mark_module_start();
Menubar_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte";
var root_316 = add_locations(template(`<button><!></button>`), Menubar_trigger[FILENAME], [[43, 2]]);
function Menubar_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menubar_trigger);
  validate_prop_bindings($$props, ["ref"], [], Menubar_trigger);
  let id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const triggerState = useMenubarTrigger({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  useMenuDropdownTrigger({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    children: wrap_snippet(Menubar_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var button = root_316();
          let attributes;
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
          append($$anchor3, button);
        }
      );
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_trigger = hmr(Menubar_trigger, () => Menubar_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_trigger[HMR].source;
    set(Menubar_trigger[HMR].source, module.default[HMR].original);
  });
}
var menubar_trigger_default = Menubar_trigger;
mark_module_end(Menubar_trigger);

// node_modules/bits-ui/dist/bits/navigation-menu/exports.js
var exports_exports21 = {};
__export(exports_exports21, {
  Content: () => navigation_menu_content_default,
  Indicator: () => navigation_menu_indicator_default,
  Item: () => navigation_menu_item_default,
  Link: () => navigation_menu_link_default,
  List: () => navigation_menu_list_default,
  Root: () => navigation_menu_default,
  Trigger: () => navigation_menu_trigger_default,
  Viewport: () => navigation_menu_viewport_default
});

// node_modules/bits-ui/dist/internal/use-arrow-navigation.js
var ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName))
    return null;
  const { arrowKeyOptions = "both", attributeName, itemsArray = [], loop = true, dir = "ltr", preventScroll = true, focus: focus2 = false } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical))
    return null;
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length)
    return null;
  if (preventScroll)
    e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) {
    item = allCollectionItems.at(0) || null;
  } else if (end) {
    item = allCollectionItems.at(-1) || null;
  }
  if (focus2)
    item == null ? void 0 : item.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, { goForward, loop }, iterations = elements.length) {
  if (--iterations === 0)
    return null;
  const index2 = elements.indexOf(currentElement);
  const newIndex = goForward ? index2 + 1 : index2 - 1;
  if (!loop && (newIndex < 0 || newIndex >= elements.length))
    return null;
  const adjustedNewIndex = (newIndex + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate)
    return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) {
    return findNextFocusableElement(elements, candidate, { goForward, loop }, iterations);
  }
  return candidate;
}

// node_modules/bits-ui/dist/bits/navigation-menu/navigation-menu.svelte.js
var [setNavigationMenuRootContext] = createContext("NavigationMenu.Root");
var [
  setNavigationMenuMenuContext,
  getNavigationMenuMenuContext
] = createContext("NavigationMenu.Root or NavigationMenu.Sub");
var [
  setNavigationMenuListContext,
  getNavigationMenuListContext
] = createContext("NavigationMenu.List");
var [
  setNavigationMenuItemContext,
  getNavigationMenuItemContext
] = createContext("NavigationMenu.Item");
var [
  setNavigationMenuContentContext,
  getNavigationMenuContentContext
] = createContext("NavigationMenu.Content");
var ROOT_ATTR6 = "data-navigation-menu-root";
var SUB_ATTR = "data-navigation-menu-sub";
var ITEM_ATTR2 = "data-navigation-menu-item";
var INDICATOR_ATTR = "data-navigation-menu-indicator";
var LIST_ATTR2 = "data-navigation-menu-list";
var TRIGGER_ATTR3 = "data-navigation-menu-trigger";
var CONTENT_ATTR2 = "data-navigation-menu-content";
var LINK_ATTR = "data-navigation-menu-link";
var _isOpenDelayed, _props102;
var NavigationMenuRootState = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "rootRef");
    __publicField(this, "delayDuration");
    __publicField(this, "skipDelayDuration");
    __publicField(this, "orientation");
    __publicField(this, "dir");
    __publicField(this, "value");
    __publicField(this, "previousValue", new Previous(() => this.value.current));
    __publicField(this, "openTimer", 0);
    __publicField(this, "closeTimer", 0);
    __publicField(this, "skipDelayTimer", 0);
    __privateAdd(this, _isOpenDelayed, state(false));
    __publicField(this, "setValue", (v) => {
      this.value.current = v;
    });
    __publicField(this, "startCloseTimer", () => {
      window.clearTimeout(this.closeTimer);
      this.closeTimer = window.setTimeout(() => this.setValue(""), 150);
    });
    __publicField(this, "handleOpen", (itemValue) => {
      window.clearTimeout(this.closeTimer);
      this.setValue(itemValue);
    });
    __publicField(this, "handleClose", () => {
      this.onItemDismiss();
      this.onContentLeave();
    });
    __publicField(this, "handleDelayedOpen", (itemValue) => {
      const isOpenItem = strict_equals(this.value.current, itemValue);
      if (isOpenItem) {
        window.clearTimeout(this.closeTimer);
      } else {
        this.openTimer = window.setTimeout(
          () => {
            window.clearTimeout(this.closeTimer);
            this.setValue(itemValue);
          },
          this.delayDuration.current
        );
      }
    });
    __publicField(this, "onTriggerEnter", (itemValue) => {
      window.clearTimeout(this.openTimer);
      if (this.isOpenDelayed) {
        this.handleDelayedOpen(itemValue);
      } else {
        this.handleOpen(itemValue);
      }
    });
    __publicField(this, "onTriggerLeave", () => {
      window.clearTimeout(this.openTimer);
      this.startCloseTimer();
    });
    __publicField(this, "onContentEnter", () => {
      window.clearTimeout(this.closeTimer);
    });
    __publicField(this, "onContentLeave", () => {
      this.startCloseTimer();
    });
    __publicField(this, "onItemSelect", (itemValue) => {
      const prevValue = this.value.current;
      this.setValue(strict_equals(prevValue, itemValue) ? "" : itemValue);
    });
    __publicField(this, "onItemDismiss", () => {
      this.setValue("");
    });
    __privateAdd(this, _props102, derived(() => ({
      id: this.id.current,
      "aria-label": "Main",
      "data-orientation": getDataOrientation(this.orientation.current),
      dir: this.dir.current,
      [ROOT_ATTR6]: ""
    })));
    this.id = props.id;
    this.delayDuration = props.delayDuration;
    this.skipDelayDuration = props.skipDelayDuration;
    this.orientation = props.orientation;
    this.dir = props.dir;
    this.value = props.value;
    this.rootRef = props.ref;
    useRefById({ id: this.id, ref: this.rootRef });
    user_effect(() => {
      this.value.current;
      untrack(() => {
        const curr = this.value.current;
        const isOpen = strict_equals(curr, "", false);
        const hasSkipDelayDuration = this.skipDelayDuration.current > 0;
        if (isOpen) {
          window.clearTimeout(this.skipDelayTimer);
          if (hasSkipDelayDuration) this.isOpenDelayed = false;
        } else {
          window.clearTimeout(this.skipDelayTimer);
          this.skipDelayTimer = window.setTimeout(() => this.isOpenDelayed = true, this.skipDelayDuration.current);
        }
      });
    });
    user_effect(() => {
      return () => {
        window.clearTimeout(this.openTimer);
        window.clearTimeout(this.closeTimer);
        window.clearTimeout(this.skipDelayTimer);
      };
    });
  }
  get isOpenDelayed() {
    return get(__privateGet(this, _isOpenDelayed));
  }
  set isOpenDelayed(value) {
    set(__privateGet(this, _isOpenDelayed), proxy(value, null, __privateGet(this, _isOpenDelayed)));
  }
  get props() {
    return get(__privateGet(this, _props102));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isOpenDelayed)), owner, false);
    add_owner(get(__privateGet(this, _props102)), owner, false);
  }
};
_isOpenDelayed = new WeakMap();
_props102 = new WeakMap();
var _isRoot, _viewportNode3, _indicatorTrackNode;
var NavigationMenuMenuState = class {
  constructor(props, root17) {
    __privateAdd(this, _isRoot, state(false));
    __publicField(this, "rootNavigationId");
    __publicField(this, "dir");
    __publicField(this, "orientation");
    __publicField(this, "value");
    __publicField(this, "previousValue");
    __publicField(this, "onTriggerEnter");
    __publicField(this, "onTriggerLeave");
    __publicField(this, "onContentEnter");
    __publicField(this, "onContentLeave");
    __publicField(this, "onItemSelect");
    __publicField(this, "onItemDismiss");
    __privateAdd(this, _viewportNode3, state(null));
    __privateAdd(this, _indicatorTrackNode, state(null));
    __publicField(this, "viewportContentId", box.with(() => void 0));
    __publicField(this, "root");
    __publicField(this, "triggerRefs", /* @__PURE__ */ new Set());
    __publicField(this, "registerTrigger", (ref) => {
      this.triggerRefs.add(ref);
    });
    __publicField(this, "deRegisterTrigger", (ref) => {
      this.triggerRefs.delete(ref);
    });
    __publicField(this, "getTriggerNodes", () => {
      return Array.from(this.triggerRefs).map((ref) => ref.current).filter((node) => Boolean(node));
    });
    this.isRoot = props.isRoot;
    this.rootNavigationId = props.rootNavigationId;
    this.dir = props.dir;
    this.orientation = props.orientation;
    this.value = props.value;
    this.onTriggerEnter = props.onTriggerEnter;
    this.onTriggerLeave = props.onTriggerLeave;
    this.onContentEnter = props.onContentEnter;
    this.onContentLeave = props.onContentLeave;
    this.onItemSelect = props.onItemSelect;
    this.onItemDismiss = props.onItemDismiss;
    this.root = root17;
    this.previousValue = props.previousValue;
  }
  get isRoot() {
    return get(__privateGet(this, _isRoot));
  }
  set isRoot(value) {
    set(__privateGet(this, _isRoot), proxy(value, null, __privateGet(this, _isRoot)));
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode3));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode3), proxy(value, null, __privateGet(this, _viewportNode3)));
  }
  get indicatorTrackNode() {
    return get(__privateGet(this, _indicatorTrackNode));
  }
  set indicatorTrackNode(value) {
    set(__privateGet(this, _indicatorTrackNode), proxy(value, null, __privateGet(this, _indicatorTrackNode)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isRoot)), owner, false);
    add_owner(get(__privateGet(this, _viewportNode3)), owner, false);
    add_owner(get(__privateGet(this, _indicatorTrackNode)), owner, false);
  }
};
_isRoot = new WeakMap();
_viewportNode3 = new WeakMap();
_indicatorTrackNode = new WeakMap();
var _viewportNode4, _indicatorTrackNode2, _props103;
var NavigationMenuSubState = class {
  constructor(props, root17) {
    __publicField(this, "id");
    __publicField(this, "isRoot", false);
    __publicField(this, "rootNavigationId");
    __publicField(this, "dir");
    __publicField(this, "orientation");
    __publicField(this, "value");
    __publicField(this, "previousValue", new Previous(() => this.value.current));
    __publicField(this, "onTriggerLeave");
    __publicField(this, "onContentEnter");
    __publicField(this, "onContentLeave");
    __privateAdd(this, _viewportNode4, state(null));
    __privateAdd(this, _indicatorTrackNode2, state(null));
    __publicField(this, "viewportContentId", box.with(() => void 0));
    __publicField(this, "root");
    __publicField(this, "triggerRefs", /* @__PURE__ */ new Set());
    __publicField(this, "ref");
    __publicField(this, "onTriggerEnter", (itemValue) => {
      this.value.current = itemValue;
    });
    __publicField(this, "onItemSelect", (itemValue) => {
      this.value.current = itemValue;
    });
    __publicField(this, "onItemDismiss", () => {
      this.value.current = "";
    });
    __publicField(this, "registerTrigger", (ref) => {
      this.triggerRefs.add(ref);
    });
    __publicField(this, "deRegisterTrigger", (ref) => {
      this.triggerRefs.delete(ref);
    });
    __publicField(this, "getTriggerNodes", () => {
      return Array.from(this.triggerRefs).map((ref) => ref.current).filter((node) => Boolean(node));
    });
    __privateAdd(this, _props103, derived(() => ({
      id: this.id.current,
      "data-orientation": getDataOrientation(this.orientation.current),
      [SUB_ATTR]: ""
    })));
    this.id = props.id;
    this.rootNavigationId = root17.id;
    this.dir = root17.dir;
    this.orientation = props.orientation;
    this.value = props.value;
    this.root = root17;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode4));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode4), proxy(value, null, __privateGet(this, _viewportNode4)));
  }
  get indicatorTrackNode() {
    return get(__privateGet(this, _indicatorTrackNode2));
  }
  set indicatorTrackNode(value) {
    set(__privateGet(this, _indicatorTrackNode2), proxy(value, null, __privateGet(this, _indicatorTrackNode2)));
  }
  createList(props) {
    return new NavigationMenuListState(props, this);
  }
  createIndicator(props) {
    return new NavigationMenuIndicatorState(props, this);
  }
  createViewport(props) {
    return new NavigationMenuViewportState(props, this);
  }
  get props() {
    return get(__privateGet(this, _props103));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _viewportNode4)), owner, false);
    add_owner(get(__privateGet(this, _indicatorTrackNode2)), owner, false);
    add_owner(get(__privateGet(this, _props103)), owner, false);
  }
};
_viewportNode4 = new WeakMap();
_indicatorTrackNode2 = new WeakMap();
_props103 = new WeakMap();
var _id69, _ref69, _indicatorTrackProps, _props104;
var NavigationMenuListState = class {
  constructor(props, menu) {
    __publicField(this, "menu");
    __privateAdd(this, _id69);
    __privateAdd(this, _ref69);
    __publicField(this, "indicatorTrackRef");
    __publicField(this, "indicatorTrackId", box(useId()));
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _indicatorTrackProps, derived(() => ({
      id: this.indicatorTrackId.current,
      style: { position: "relative" }
    })));
    __privateAdd(this, _props104, derived(() => ({
      id: __privateGet(this, _id69).current,
      "data-orientation": getDataOrientation(this.menu.orientation.current),
      [LIST_ATTR2]: ""
    })));
    this.menu = menu;
    __privateSet(this, _id69, props.id);
    __privateSet(this, _ref69, props.ref);
    this.indicatorTrackRef = props.indicatorTrackRef;
    this.rovingFocusGroup = useRovingFocus({
      rootNodeId: __privateGet(this, _id69),
      candidateAttr: TRIGGER_ATTR3,
      candidateSelector: `:is([${TRIGGER_ATTR3}], [data-list-link]):not([data-disabled])`,
      loop: box.with(() => false),
      orientation: this.menu.orientation
    });
    useRefById({ id: __privateGet(this, _id69), ref: __privateGet(this, _ref69) });
    useRefById({
      id: this.indicatorTrackId,
      ref: this.indicatorTrackRef,
      onRefChange: (node) => {
        this.menu.indicatorTrackNode = node;
      },
      deps: () => Boolean(this.menu.root.value.current)
    });
  }
  get indicatorTrackProps() {
    return get(__privateGet(this, _indicatorTrackProps));
  }
  set indicatorTrackProps(_) {
    throw new Error("Cannot update a derived property ('indicatorTrackProps')");
  }
  createItem(props) {
    return new NavigationMenuItemState(props, this, this.menu);
  }
  get props() {
    return get(__privateGet(this, _props104));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _indicatorTrackProps)), owner, false);
    add_owner(get(__privateGet(this, _props104)), owner, false);
  }
};
_id69 = new WeakMap();
_ref69 = new WeakMap();
_indicatorTrackProps = new WeakMap();
_props104 = new WeakMap();
var _ref70, _contentNode8, _triggerNode7, _focusProxyNode, _wasEscapeClose, _handleContentEntry, _handleContentExit, _props105;
var NavigationMenuItemState = class {
  constructor(props, list, menu) {
    __publicField(this, "id");
    __privateAdd(this, _ref70);
    __publicField(this, "value");
    __privateAdd(this, _contentNode8, state(null));
    __privateAdd(this, _triggerNode7, state(null));
    __publicField(this, "focusProxyRef", box(null));
    __privateAdd(this, _focusProxyNode, state(null));
    __publicField(this, "focusProxyId", box(useId()));
    __publicField(this, "restoreContentTabOrder", noop2);
    __privateAdd(this, _wasEscapeClose, state(false));
    __publicField(this, "menu");
    __publicField(this, "list");
    __privateAdd(this, _handleContentEntry, (side = "start") => {
      var _a, _b;
      if (!this.contentNode) return;
      this.restoreContentTabOrder();
      const candidates = getTabbableCandidates(this.contentNode);
      if (candidates.length) {
        if (strict_equals(side, "start")) {
          (_a = candidates[0]) == null ? void 0 : _a.focus();
        } else {
          (_b = candidates[candidates.length - 1]) == null ? void 0 : _b.focus();
        }
      }
    });
    __privateAdd(this, _handleContentExit, () => {
      if (!this.contentNode) return;
      const candidates = getTabbableCandidates(this.contentNode);
      if (candidates.length) {
        this.restoreContentTabOrder = removeFromTabOrder(candidates);
      }
    });
    __publicField(this, "onEntryKeydown", __privateGet(this, _handleContentEntry));
    __publicField(this, "onFocusProxyEnter", __privateGet(this, _handleContentEntry));
    __publicField(this, "onContentFocusOutside", __privateGet(this, _handleContentExit));
    __publicField(this, "onRootContentClose", __privateGet(this, _handleContentExit));
    __privateAdd(this, _props105, derived(() => ({ id: this.id.current, [ITEM_ATTR2]: "" })));
    this.id = props.id;
    __privateSet(this, _ref70, props.ref);
    this.value = props.value;
    this.menu = menu;
    this.list = list;
    useRefById({ id: this.id, ref: __privateGet(this, _ref70) });
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode8));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode8), proxy(value, null, __privateGet(this, _contentNode8)));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode7));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode7), proxy(value, null, __privateGet(this, _triggerNode7)));
  }
  get focusProxyNode() {
    return get(__privateGet(this, _focusProxyNode));
  }
  set focusProxyNode(value) {
    set(__privateGet(this, _focusProxyNode), proxy(value, null, __privateGet(this, _focusProxyNode)));
  }
  get wasEscapeClose() {
    return get(__privateGet(this, _wasEscapeClose));
  }
  set wasEscapeClose(value) {
    set(__privateGet(this, _wasEscapeClose), proxy(value, null, __privateGet(this, _wasEscapeClose)));
  }
  get props() {
    return get(__privateGet(this, _props105));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _contentNode8)), owner, false);
    add_owner(get(__privateGet(this, _triggerNode7)), owner, false);
    add_owner(get(__privateGet(this, _focusProxyNode)), owner, false);
    add_owner(get(__privateGet(this, _wasEscapeClose)), owner, false);
    add_owner(get(__privateGet(this, _props105)), owner, false);
  }
};
_ref70 = new WeakMap();
_contentNode8 = new WeakMap();
_triggerNode7 = new WeakMap();
_focusProxyNode = new WeakMap();
_wasEscapeClose = new WeakMap();
_handleContentEntry = new WeakMap();
_handleContentExit = new WeakMap();
_props105 = new WeakMap();
var _id70, _ref71, _wasClickClose, _open2, _onpointerenter4, _onpointermove9, _onpointerleave5, _onclick15, _onkeydown31, _props106, _visuallyHiddenProps;
var NavigationMenuTriggerState = class {
  constructor(props, item) {
    __privateAdd(this, _id70);
    __privateAdd(this, _ref71);
    __publicField(this, "focusProxyMounted");
    __publicField(this, "menu");
    __publicField(this, "item");
    __publicField(this, "disabled");
    __publicField(this, "hasPointerMoveOpened", boxAutoReset(false, 150));
    __privateAdd(this, _wasClickClose, state(false));
    __privateAdd(this, _open2, derived(() => strict_equals(this.item.value.current, this.menu.value.current)));
    __privateAdd(this, _onpointerenter4, () => {
      this.wasClickClose = false;
      this.item.wasEscapeClose = false;
    });
    __privateAdd(this, _onpointermove9, (e) => {
      if (strict_equals(e.pointerType, "mouse", false)) return;
      if (this.disabled.current || this.wasClickClose || this.item.wasEscapeClose || this.hasPointerMoveOpened.current) return;
      this.menu.onTriggerEnter(this.item.value.current);
      this.hasPointerMoveOpened.current = true;
    });
    __privateAdd(this, _onpointerleave5, (e) => {
      var _a, _b;
      if (strict_equals(e.pointerType, "mouse", false) || this.disabled.current) return;
      (_b = (_a = this.menu).onTriggerLeave) == null ? void 0 : _b.call(_a);
      this.hasPointerMoveOpened.current = false;
    });
    __privateAdd(this, _onclick15, (_) => {
      if (this.hasPointerMoveOpened.current) return;
      if (this.open) {
        this.menu.onItemSelect("");
      } else {
        this.menu.onItemSelect(this.item.value.current);
      }
      this.wasClickClose = this.open;
    });
    __privateAdd(this, _onkeydown31, (e) => {
      const verticalEntryKey = strict_equals(this.menu.dir.current, "rtl") ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT;
      const entryKey = {
        horizontal: kbd_constants_exports.ARROW_DOWN,
        vertical: verticalEntryKey
      }[this.menu.orientation.current];
      if (this.open && strict_equals(e.key, entryKey)) {
        this.item.onEntryKeydown();
        e.preventDefault();
        return;
      }
      this.item.list.rovingFocusGroup.handleKeydown(__privateGet(this, _ref71).current, e);
    });
    __privateAdd(this, _props106, derived(() => ({
      id: __privateGet(this, _id70).current,
      disabled: getDisabled(this.disabled.current),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-state": getDataOpenClosed(this.open),
      "aria-expanded": getAriaExpanded(this.open),
      "aria-controls": this.item.contentNode ? this.item.contentNode.id : void 0,
      "data-value": this.item.value.current,
      onpointerenter: __privateGet(this, _onpointerenter4),
      onpointermove: __privateGet(this, _onpointermove9),
      onpointerleave: __privateGet(this, _onpointerleave5),
      onclick: __privateGet(this, _onclick15),
      onkeydown: __privateGet(this, _onkeydown31),
      [TRIGGER_ATTR3]: ""
    })));
    __privateAdd(this, _visuallyHiddenProps, derived(() => ({
      id: this.item.focusProxyId.current,
      "aria-hidden": "true",
      tabIndex: 0,
      onfocus: (e) => {
        var _a;
        const prevFocusedElement = e.relatedTarget;
        const wasTriggerFocused = strict_equals(prevFocusedElement, this.item.triggerNode);
        const wasFocusFromContent = (_a = this.item.contentNode) == null ? void 0 : _a.contains(prevFocusedElement);
        if (wasTriggerFocused || !wasFocusFromContent) {
          e.preventDefault();
          this.item.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
        }
      }
    })));
    __privateSet(this, _id70, props.id);
    __privateSet(this, _ref71, props.ref);
    this.item = item;
    this.menu = item.menu;
    this.disabled = props.disabled;
    this.focusProxyMounted = props.focusProxyMounted;
    useRefById({
      id: __privateGet(this, _id70),
      ref: __privateGet(this, _ref71),
      onRefChange: (node) => {
        this.item.triggerNode = node;
      }
    });
    useRefById({
      id: this.item.focusProxyId,
      ref: this.item.focusProxyRef,
      onRefChange: (node) => {
        this.item.focusProxyNode = node;
      },
      deps: () => this.focusProxyMounted.current
    });
    user_effect(() => {
      this.menu.registerTrigger(__privateGet(this, _ref71));
      return () => {
        this.menu.deRegisterTrigger(__privateGet(this, _ref71));
      };
    });
  }
  get wasClickClose() {
    return get(__privateGet(this, _wasClickClose));
  }
  set wasClickClose(value) {
    set(__privateGet(this, _wasClickClose), proxy(value, null, __privateGet(this, _wasClickClose)));
  }
  get open() {
    return get(__privateGet(this, _open2));
  }
  set open(_) {
    throw new Error("Cannot update a derived property ('open')");
  }
  get props() {
    return get(__privateGet(this, _props106));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  get visuallyHiddenProps() {
    return get(__privateGet(this, _visuallyHiddenProps));
  }
  set visuallyHiddenProps(_) {
    throw new Error("Cannot update a derived property ('visuallyHiddenProps')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _wasClickClose)), owner, false);
    add_owner(get(__privateGet(this, _open2)), owner, false);
    add_owner(get(__privateGet(this, _props106)), owner, false);
    add_owner(get(__privateGet(this, _visuallyHiddenProps)), owner, false);
  }
};
_id70 = new WeakMap();
_ref71 = new WeakMap();
_wasClickClose = new WeakMap();
_open2 = new WeakMap();
_onpointerenter4 = new WeakMap();
_onpointermove9 = new WeakMap();
_onpointerleave5 = new WeakMap();
_onclick15 = new WeakMap();
_onkeydown31 = new WeakMap();
_props106 = new WeakMap();
_visuallyHiddenProps = new WeakMap();
var _id71, _ref72, _onclick16, _onkeydown32, _props107;
var NavigationMenuLinkState = class {
  constructor(props, item, content) {
    __privateAdd(this, _id71);
    __privateAdd(this, _ref72);
    __publicField(this, "active");
    __publicField(this, "onSelect");
    __publicField(this, "content");
    __publicField(this, "item");
    __privateAdd(this, _onclick16, (e) => {
      const linkSelectEvent = new CustomEvent("navigationMenu.linkSelect", { bubbles: true, cancelable: true });
      this.onSelect.current(linkSelectEvent);
      if (!linkSelectEvent.defaultPrevented && !e.metaKey) {
      }
    });
    __privateAdd(this, _onkeydown32, (e) => {
      this.item.list.rovingFocusGroup.handleKeydown(__privateGet(this, _ref72).current, e);
    });
    __privateAdd(this, _props107, derived(() => ({
      id: __privateGet(this, _id71).current,
      "data-active": this.active.current ? "" : void 0,
      "aria-current": this.active.current ? "page" : void 0,
      "data-list-link": this.content ? void 0 : "",
      onclick: __privateGet(this, _onclick16),
      onfocus: (_) => {
      },
      onkeydown: this.content ? void 0 : __privateGet(this, _onkeydown32)
    })));
    __privateSet(this, _id71, props.id);
    __privateSet(this, _ref72, props.ref);
    this.active = props.active;
    this.onSelect = props.onSelect;
    this.content = content;
    this.item = item;
    useRefById({ id: __privateGet(this, _id71), ref: __privateGet(this, _ref72) });
  }
  get props() {
    return get(__privateGet(this, _props107));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props107)), owner, false);
  }
};
_id71 = new WeakMap();
_ref72 = new WeakMap();
_onclick16 = new WeakMap();
_onkeydown32 = new WeakMap();
_props107 = new WeakMap();
var _activeTrigger, _position, _isHorizontal, _isVisible, _props108;
var NavigationMenuIndicatorState = class {
  constructor(props, menu) {
    __publicField(this, "id");
    __publicField(this, "menu");
    __privateAdd(this, _activeTrigger, state(null));
    __privateAdd(this, _position, state(null));
    __privateAdd(this, _isHorizontal, derived(() => strict_equals(this.menu.orientation.current, "horizontal")));
    __privateAdd(this, _isVisible, derived(() => Boolean(this.menu.value.current)));
    __publicField(this, "indicatorRef");
    __publicField(this, "handlePositionChange", () => {
      if (!this.activeTrigger) return;
      this.position = {
        size: this.isHorizontal ? this.activeTrigger.offsetWidth : this.activeTrigger.offsetHeight,
        offset: this.isHorizontal ? this.activeTrigger.offsetLeft : this.activeTrigger.offsetTop
      };
    });
    __privateAdd(this, _props108, derived(() => ({
      "aria-hidden": getAriaHidden(true),
      "data-state": this.isVisible ? "visible" : "hidden",
      "data-orientation": getDataOrientation(this.menu.orientation.current),
      style: {
        position: "absolute",
        ...this.isHorizontal ? {
          left: 0,
          width: this.position ? `${this.position.size}px` : void 0,
          transform: this.position ? `translateX(${this.position.offset}px)` : void 0
        } : {
          top: 0,
          height: this.position ? `${this.position.size}px` : void 0,
          transform: this.position ? `translateY(${this.position.offset}px)` : void 0
        }
      },
      [INDICATOR_ATTR]: ""
    })));
    this.id = props.id;
    this.indicatorRef = props.ref;
    this.menu = menu;
    useRefById({
      id: this.id,
      ref: this.indicatorRef,
      onRefChange: (node) => {
        this.menu.viewportNode = node;
      }
    });
    user_effect(() => {
      const triggerNodes = this.menu.getTriggerNodes();
      const triggerNode = triggerNodes.find((node) => strict_equals(node.dataset.value, this.menu.value.current));
      if (triggerNode) {
        untrack(() => {
          this.activeTrigger = triggerNode;
        });
      }
    });
    useResizeObserver2(() => this.activeTrigger, this.handlePositionChange);
    useResizeObserver2(() => this.menu.indicatorTrackNode, this.handlePositionChange);
  }
  get activeTrigger() {
    return get(__privateGet(this, _activeTrigger));
  }
  set activeTrigger(value) {
    set(__privateGet(this, _activeTrigger), proxy(value, null, __privateGet(this, _activeTrigger)));
  }
  get position() {
    return get(__privateGet(this, _position));
  }
  set position(value) {
    set(__privateGet(this, _position), proxy(value, null, __privateGet(this, _position)));
  }
  get isHorizontal() {
    return get(__privateGet(this, _isHorizontal));
  }
  set isHorizontal(_) {
    throw new Error("Cannot update a derived property ('isHorizontal')");
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible));
  }
  set isVisible(_) {
    throw new Error("Cannot update a derived property ('isVisible')");
  }
  get props() {
    return get(__privateGet(this, _props108));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _activeTrigger)), owner, false);
    add_owner(get(__privateGet(this, _position)), owner, false);
    add_owner(get(__privateGet(this, _isHorizontal)), owner, false);
    add_owner(get(__privateGet(this, _isVisible)), owner, false);
    add_owner(get(__privateGet(this, _props108)), owner, false);
  }
};
_activeTrigger = new WeakMap();
_position = new WeakMap();
_isHorizontal = new WeakMap();
_isVisible = new WeakMap();
_props108 = new WeakMap();
var _prevMotionAttribute, _motionAttribute, _open3, _isPresent, _onkeydown33, _props109;
var NavigationMenuContentState = class {
  constructor(props, item) {
    __publicField(this, "id");
    __publicField(this, "forceMount");
    __publicField(this, "isMounted");
    __publicField(this, "contentRef");
    __publicField(this, "menu");
    __publicField(this, "item");
    __privateAdd(this, _prevMotionAttribute, state(null));
    __privateAdd(this, _motionAttribute, state(null));
    __privateAdd(this, _open3, derived(() => strict_equals(this.menu.value.current, this.item.value.current)));
    __privateAdd(this, _isPresent, derived(() => this.open || this.forceMount.current));
    __publicField(this, "onFocusOutside", (e) => {
      var _a;
      this.item.onContentFocusOutside();
      const target = e.target;
      if ((_a = this.menu.root.rootRef.current) == null ? void 0 : _a.contains(target)) {
        e.preventDefault();
      } else {
        this.menu.root.handleClose();
      }
    });
    __publicField(this, "onInteractOutside", (e) => {
      var _a;
      if (e.defaultPrevented) return;
      const target = e.target;
      const isTrigger = this.menu.getTriggerNodes().some((node) => node.contains(target));
      const isRootViewport = this.menu.isRoot && ((_a = this.menu.viewportNode) == null ? void 0 : _a.contains(target));
      if (isTrigger || isRootViewport || !this.menu.isRoot) {
        e.preventDefault();
      }
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      var _a, _b;
      this.menu.root.handleClose();
      const target = e.target;
      if ((_a = this.contentRef.current) == null ? void 0 : _a.contains(target)) {
        (_b = this.item.triggerNode) == null ? void 0 : _b.focus();
      }
      this.item.wasEscapeClose = true;
    });
    __privateAdd(this, _onkeydown33, (e) => {
      var _a;
      const isMetaKey = e.altKey || e.ctrlKey || e.metaKey;
      const isTabKey = strict_equals(e.key, kbd_constants_exports.TAB) && !isMetaKey;
      const candidates = getTabbableCandidates(e.currentTarget);
      if (isTabKey) {
        const focusedElement = document.activeElement;
        const index2 = candidates.findIndex((candidate) => strict_equals(candidate, focusedElement));
        const isMovingBackwards = e.shiftKey;
        const nextCandidates = isMovingBackwards ? candidates.slice(0, index2).reverse() : candidates.slice(index2 + 1, candidates.length);
        if (focusFirst2(nextCandidates)) {
          e.preventDefault();
          return;
        } else {
          (_a = this.item.focusProxyNode) == null ? void 0 : _a.focus();
          return;
        }
      }
      const newSelectedElement = useArrowNavigation(e, document.activeElement, void 0, {
        itemsArray: candidates,
        attributeName: `[${LINK_ATTR}]`,
        loop: false,
        enableIgnoredElement: true
      });
      newSelectedElement == null ? void 0 : newSelectedElement.focus();
    });
    __privateAdd(this, _props109, derived(() => {
      var _a;
      return {
        id: this.id.current,
        "aria-labelledby": ((_a = this.item.triggerNode) == null ? void 0 : _a.id) ?? void 0,
        "data-motion": this.motionAttribute,
        "data-state": getDataOpenClosed(strict_equals(this.menu.value.current, this.item.value.current)),
        "data-orientation": getDataOrientation(this.menu.orientation.current),
        [CONTENT_ATTR2]: "",
        style: {
          pointerEvents: !this.open && this.menu.isRoot ? "none" : void 0
        },
        onkeydown: __privateGet(this, _onkeydown33)
      };
    }));
    this.id = props.id;
    this.forceMount = props.forceMount;
    this.isMounted = props.isMounted;
    this.item = item;
    this.menu = item.menu;
    this.contentRef = props.ref;
    useRefById({
      id: this.id,
      ref: this.contentRef,
      onRefChange: (node) => {
        this.item.contentNode = node;
      },
      deps: () => this.isMounted.current
    });
    user_effect(() => {
      const items = this.menu.getTriggerNodes();
      const prev2 = this.menu.previousValue.current;
      const values = items.map((item2) => item2.dataset.value).filter((v) => Boolean(v));
      if (strict_equals(this.menu.dir.current, "rtl")) values.reverse();
      const index2 = values.indexOf(this.menu.value.current);
      const prevIndex = values.indexOf(prev2 ?? "");
      const isSelected = strict_equals(this.item.value.current, this.menu.value.current);
      const wasSelected = strict_equals(prevIndex, values.indexOf(this.item.value.current));
      if (!isSelected && !wasSelected) {
        this.motionAttribute = this.prevMotionAttribute;
      }
      const attribute = (() => {
        if (strict_equals(index2, prevIndex, false)) {
          if (isSelected && strict_equals(prevIndex, -1, false)) {
            return index2 > prevIndex ? "from-end" : "from-start";
          }
          if (wasSelected && strict_equals(index2, -1, false)) {
            return index2 > prevIndex ? "to-start" : "to-end";
          }
        }
        return null;
      })();
      this.prevMotionAttribute = attribute;
      this.motionAttribute = attribute;
    });
  }
  get prevMotionAttribute() {
    return get(__privateGet(this, _prevMotionAttribute));
  }
  set prevMotionAttribute(value) {
    set(__privateGet(this, _prevMotionAttribute), proxy(value, null, __privateGet(this, _prevMotionAttribute)));
  }
  get motionAttribute() {
    return get(__privateGet(this, _motionAttribute));
  }
  set motionAttribute(value) {
    set(__privateGet(this, _motionAttribute), proxy(value, null, __privateGet(this, _motionAttribute)));
  }
  get open() {
    return get(__privateGet(this, _open3));
  }
  set open(_) {
    throw new Error("Cannot update a derived property ('open')");
  }
  get isPresent() {
    return get(__privateGet(this, _isPresent));
  }
  set isPresent(_) {
    throw new Error("Cannot update a derived property ('isPresent')");
  }
  get props() {
    return get(__privateGet(this, _props109));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _prevMotionAttribute)), owner, false);
    add_owner(get(__privateGet(this, _motionAttribute)), owner, false);
    add_owner(get(__privateGet(this, _open3)), owner, false);
    add_owner(get(__privateGet(this, _isPresent)), owner, false);
    add_owner(get(__privateGet(this, _props109)), owner, false);
  }
};
_prevMotionAttribute = new WeakMap();
_motionAttribute = new WeakMap();
_open3 = new WeakMap();
_isPresent = new WeakMap();
_onkeydown33 = new WeakMap();
_props109 = new WeakMap();
var _size2, _open4, _activeContentValue, _contentNode9, _onpointerenter5, _onpointerleave6, _props110;
var NavigationMenuViewportState = class {
  constructor(props, menu) {
    __publicField(this, "id");
    __publicField(this, "menu");
    __privateAdd(this, _size2, state(null));
    __privateAdd(this, _open4, derived(() => strict_equals(this.menu.value.current, "", false)));
    __privateAdd(this, _activeContentValue, derived(() => this.menu.value.current));
    __publicField(this, "viewportRef");
    __privateAdd(this, _contentNode9, state());
    __privateAdd(this, _onpointerenter5, () => {
      var _a, _b;
      (_b = (_a = this.menu).onContentEnter) == null ? void 0 : _b.call(_a);
    });
    __privateAdd(this, _onpointerleave6, (e) => {
      var _a, _b;
      if (strict_equals(e.pointerType, "mouse", false)) return;
      (_b = (_a = this.menu).onContentLeave) == null ? void 0 : _b.call(_a);
    });
    __privateAdd(this, _props110, derived(() => ({
      id: this.id.current,
      "data-state": getDataOpenClosed(this.open),
      "data-orientation": getDataOrientation(this.menu.orientation.current),
      style: {
        pointerEvents: !this.open && this.menu.isRoot ? "none" : void 0,
        "--bits-navigation-menu-viewport-width": this.size ? `${this.size.width}px` : void 0,
        "--bits-navigation-menu-viewport-height": this.size ? `${this.size.height}px` : void 0
      },
      onpointerenter: __privateGet(this, _onpointerenter5),
      onpointerleave: __privateGet(this, _onpointerleave6)
    })));
    this.id = props.id;
    this.menu = menu;
    this.viewportRef = props.ref;
    useRefById({
      id: this.id,
      ref: this.viewportRef,
      onRefChange: (node) => {
        this.menu.viewportNode = node;
      },
      deps: () => this.open
    });
    user_effect(() => {
      this.open;
      this.activeContentValue;
      const currentNode = untrack(() => this.viewportRef.current);
      if (!currentNode) return;
      afterTick(() => {
        var _a, _b;
        const contentNode = (_b = (_a = currentNode.querySelector("[data-state=open]")) == null ? void 0 : _a.children) == null ? void 0 : _b[0];
        this.contentNode = contentNode;
      });
    });
    useResizeObserver2(() => this.contentNode, () => {
      if (this.contentNode) {
        this.size = {
          width: this.contentNode.offsetWidth,
          height: this.contentNode.offsetHeight
        };
      }
    });
  }
  get size() {
    return get(__privateGet(this, _size2));
  }
  set size(value) {
    set(__privateGet(this, _size2), proxy(value, null, __privateGet(this, _size2)));
  }
  get open() {
    return get(__privateGet(this, _open4));
  }
  set open(_) {
    throw new Error("Cannot update a derived property ('open')");
  }
  get activeContentValue() {
    return get(__privateGet(this, _activeContentValue));
  }
  set activeContentValue(_) {
    throw new Error("Cannot update a derived property ('activeContentValue')");
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode9));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode9), proxy(value, null, __privateGet(this, _contentNode9)));
  }
  get props() {
    return get(__privateGet(this, _props110));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _size2)), owner, false);
    add_owner(get(__privateGet(this, _open4)), owner, false);
    add_owner(get(__privateGet(this, _activeContentValue)), owner, false);
    add_owner(get(__privateGet(this, _contentNode9)), owner, false);
    add_owner(get(__privateGet(this, _props110)), owner, false);
  }
};
_size2 = new WeakMap();
_open4 = new WeakMap();
_activeContentValue = new WeakMap();
_contentNode9 = new WeakMap();
_onpointerenter5 = new WeakMap();
_onpointerleave6 = new WeakMap();
_props110 = new WeakMap();
function useNavigationMenuRoot(props) {
  const rootState = new NavigationMenuRootState(props);
  const menuState = new NavigationMenuMenuState(
    {
      rootNavigationId: rootState.id,
      dir: rootState.dir,
      orientation: rootState.orientation,
      value: rootState.value,
      isRoot: true,
      onTriggerEnter: rootState.onTriggerEnter,
      onItemSelect: rootState.onItemSelect,
      onItemDismiss: rootState.onItemDismiss,
      onContentEnter: rootState.onContentEnter,
      onContentLeave: rootState.onContentLeave,
      onTriggerLeave: rootState.onTriggerLeave,
      previousValue: rootState.previousValue
    },
    rootState
  );
  setNavigationMenuMenuContext(menuState);
  return setNavigationMenuRootContext(rootState);
}
function useNavigationMenuList(props) {
  const menuState = getNavigationMenuMenuContext();
  return setNavigationMenuListContext(new NavigationMenuListState(props, menuState));
}
function useNavigationMenuItem(props) {
  const listState = getNavigationMenuListContext();
  return setNavigationMenuItemContext(new NavigationMenuItemState(props, listState, listState.menu));
}
function useNavigationMenuTrigger(props) {
  return new NavigationMenuTriggerState(props, getNavigationMenuItemContext());
}
function useNavigationMenuContent(props) {
  return setNavigationMenuContentContext(new NavigationMenuContentState(props, getNavigationMenuItemContext()));
}
function useNavigationMenuViewport(props) {
  return new NavigationMenuViewportState(props, getNavigationMenuMenuContext());
}
function useNavigationMenuIndicator(props) {
  return new NavigationMenuIndicatorState(props, getNavigationMenuMenuContext());
}
function useNavigationMenuLink(props) {
  const content = getNavigationMenuContentContext(null);
  if (content) {
    return new NavigationMenuLinkState(props, content.item, content);
  }
  return new NavigationMenuLinkState(props, getNavigationMenuItemContext());
}
function focusFirst2(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (strict_equals(candidate, previouslyFocusedElement)) return true;
    candidate.focus();
    return strict_equals(document.activeElement, previouslyFocusedElement, false);
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function useResizeObserver2(element2, onResize) {
  user_effect(() => {
    let rAF = 0;
    const node = element2();
    if (node) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(onResize);
      });
      resizeObserver.observe(node);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(node);
      };
    }
  });
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu.svelte
mark_module_start();
Navigation_menu[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu.svelte";
var root_276 = add_locations(template(`<nav><!></nav>`), Navigation_menu[FILENAME], [[52, 1]]);
function Navigation_menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu);
  validate_prop_bindings($$props, ["ref", "value"], [], Navigation_menu);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop2), delayDuration = prop($$props, "delayDuration", 3, 200), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300), dir = prop($$props, "dir", 3, "ltr"), orientation = prop($$props, "orientation", 3, "horizontal"), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "delayDuration",
      "skipDelayDuration",
      "dir",
      "orientation",
      "controlledValue"
    ],
    "restProps"
  );
  const rootState = useNavigationMenuRoot({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    delayDuration: box.with(() => delayDuration()),
    skipDelayDuration: box.with(() => skipDelayDuration()),
    dir: box.with(() => dir()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps({ "aria-label": "main" }, restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var nav = root_276();
      let attributes;
      var node_2 = child(nav);
      snippet(node_2, () => $$props.children ?? noop);
      reset(nav);
      template_effect(() => attributes = set_attributes(nav, attributes, { ...get(mergedProps) }));
      append($$anchor2, nav);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu = hmr(Navigation_menu, () => Navigation_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu[HMR].source;
    set(Navigation_menu[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_default = Navigation_menu;
mark_module_end(Navigation_menu);

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content.svelte
mark_module_start();
Navigation_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content.svelte";
var root_5 = add_locations(template(`<!> <!>`, 1), Navigation_menu_content[FILENAME], []);
var root_63 = add_locations(template(`<!> <div><!></div>`, 1), Navigation_menu_content[FILENAME], [[73, 7]]);
function Navigation_menu_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu_content);
  validate_prop_bindings($$props, ["ref"], [], Navigation_menu_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "forceMount",
      "onEscapeKeydown",
      "onInteractOutside",
      "onFocusOutside"
    ],
    "restProps"
  );
  let isMounted = state(false);
  const contentState = useNavigationMenuContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => {
      ref(v);
    }),
    forceMount: box.with(() => forceMount()),
    isMounted: box.with(() => get(isMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  const portalDisabled = derived(() => !contentState.menu.viewportNode);
  var fragment = comment();
  var node = first_child(fragment);
  var to = derived(() => contentState.menu.viewportNode ?? void 0);
  portal_default(node, {
    get to() {
      return get(to);
    },
    get disabled() {
      return get(portalDisabled);
    },
    children: wrap_snippet(Navigation_menu_content, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const presence = wrap_snippet(Navigation_menu_content, ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          escape_layer_default(node_2, {
            get enabled() {
              return contentState.isPresent;
            },
            onEscapeKeydown: (e) => {
              var _a;
              (_a = $$props.onEscapeKeydown) == null ? void 0 : _a.call($$props, e);
              if (e.defaultPrevented) return;
              contentState.onEscapeKeydown(e);
            },
            children: wrap_snippet(Navigation_menu_content, ($$anchor4, $$slotProps2) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                const children = wrap_snippet(Navigation_menu_content, ($$anchor5, $$arg0) => {
                  let dismissibleProps = () => $$arg0 == null ? void 0 : $$arg0().props;
                  dismissibleProps();
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  if_block(
                    node_4,
                    () => $$props.child,
                    ($$anchor6) => {
                      var fragment_5 = root_5();
                      var node_5 = first_child(fragment_5);
                      {
                        add_owner_effect(() => get(isMounted), mounted_default);
                        mounted_default(node_5, {
                          get isMounted() {
                            return get(isMounted);
                          },
                          set isMounted($$value) {
                            set(isMounted, proxy($$value, null, isMounted));
                          }
                        });
                      }
                      var node_6 = sibling(node_5, 2);
                      var render_arg = derived_safe_equal(() => ({
                        props: mergeProps(dismissibleProps(), get(mergedProps))
                      }));
                      snippet(node_6, () => $$props.child, () => get(render_arg));
                      append($$anchor6, fragment_5);
                    },
                    ($$anchor6) => {
                      var fragment_6 = root_63();
                      var node_7 = first_child(fragment_6);
                      {
                        add_owner_effect(() => get(isMounted), mounted_default);
                        mounted_default(node_7, {
                          get isMounted() {
                            return get(isMounted);
                          },
                          set isMounted($$value) {
                            set(isMounted, proxy($$value, null, isMounted));
                          }
                        });
                      }
                      var div = sibling(node_7, 2);
                      const spread_with_call = derived(() => mergeProps(dismissibleProps(), get(mergedProps)));
                      let attributes;
                      var node_8 = child(div);
                      snippet(node_8, () => $$props.children ?? noop);
                      reset(div);
                      template_effect(() => attributes = set_attributes(div, attributes, { ...get(spread_with_call) }));
                      append($$anchor6, fragment_6);
                    }
                  );
                  append($$anchor5, fragment_4);
                });
                dismissible_layer_default(node_3, {
                  get enabled() {
                    return contentState.isPresent;
                  },
                  get id() {
                    return id();
                  },
                  onInteractOutside: (e) => {
                    var _a;
                    (_a = $$props.onInteractOutside) == null ? void 0 : _a.call($$props, e);
                    if (e.defaultPrevented) return;
                    contentState.onInteractOutside(e);
                  },
                  onFocusOutside: (e) => {
                    var _a;
                    (_a = $$props.onFocusOutside) == null ? void 0 : _a.call($$props, e);
                    if (e.defaultPrevented) return;
                    contentState.onFocusOutside(e);
                  },
                  children,
                  $$slots: { default: true }
                });
              }
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_2);
        });
        presence_layer_default(node_1, {
          get id() {
            return id();
          },
          get present() {
            return contentState.isPresent;
          },
          presence,
          $$slots: { presence: true }
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_content = hmr(Navigation_menu_content, () => Navigation_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_content[HMR].source;
    set(Navigation_menu_content[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_content_default = Navigation_menu_content;
mark_module_end(Navigation_menu_content);

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator.svelte
mark_module_start();
Navigation_menu_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator.svelte";
var root_52 = add_locations(template(`<div><!></div>`), Navigation_menu_indicator[FILENAME], [[36, 5]]);
function Navigation_menu_indicator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu_indicator);
  validate_prop_bindings($$props, ["ref"], [], Navigation_menu_indicator);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const indicatorState = useNavigationMenuIndicator({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, indicatorState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => indicatorState.menu.indicatorTrackNode, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    portal_default(node_1, {
      get to() {
        return indicatorState.menu.indicatorTrackNode;
      },
      children: wrap_snippet(Navigation_menu_indicator, ($$anchor3, $$slotProps) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        var present = derived(() => forceMount() || indicatorState.isVisible);
        {
          const presence = wrap_snippet(Navigation_menu_indicator, ($$anchor4) => {
            var fragment_3 = comment();
            var node_3 = first_child(fragment_3);
            if_block(
              node_3,
              () => $$props.child,
              ($$anchor5) => {
                var fragment_4 = comment();
                var node_4 = first_child(fragment_4);
                snippet(node_4, () => $$props.child, () => ({ props: get(mergedProps) }));
                append($$anchor5, fragment_4);
              },
              ($$anchor5) => {
                var div = root_52();
                let attributes;
                var node_5 = child(div);
                snippet(node_5, () => $$props.children ?? noop);
                reset(div);
                template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
                append($$anchor5, div);
              }
            );
            append($$anchor4, fragment_3);
          });
          presence_layer_default(node_2, {
            get id() {
              return id();
            },
            get present() {
              return get(present);
            },
            presence,
            $$slots: { presence: true }
          });
        }
        append($$anchor3, fragment_2);
      }),
      $$slots: { default: true }
    });
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_indicator = hmr(Navigation_menu_indicator, () => Navigation_menu_indicator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_indicator[HMR].source;
    set(Navigation_menu_indicator[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_indicator_default = Navigation_menu_indicator;
mark_module_end(Navigation_menu_indicator);

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-item.svelte
mark_module_start();
Navigation_menu_item[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-item.svelte";
var root_277 = add_locations(template(`<li><!></li>`), Navigation_menu_item[FILENAME], [[31, 1]]);
function Navigation_menu_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu_item);
  validate_prop_bindings($$props, ["ref"], [], Navigation_menu_item);
  let id = prop($$props, "id", 19, useId), value = prop($$props, "value", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "value",
      "ref",
      "child",
      "children"
    ],
    "restProps"
  );
  const itemState = useNavigationMenuItem({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value())
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var li = root_277();
      let attributes;
      var node_2 = child(li);
      snippet(node_2, () => $$props.children ?? noop);
      reset(li);
      template_effect(() => attributes = set_attributes(li, attributes, { ...get(mergedProps) }));
      append($$anchor2, li);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_item = hmr(Navigation_menu_item, () => Navigation_menu_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_item[HMR].source;
    set(Navigation_menu_item[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_item_default = Navigation_menu_item;
mark_module_end(Navigation_menu_item);

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-link.svelte
mark_module_start();
Navigation_menu_link[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-link.svelte";
var root_278 = add_locations(template(`<a><!></a>`), Navigation_menu_link[FILENAME], [[34, 1]]);
function Navigation_menu_link($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu_link);
  validate_prop_bindings($$props, ["ref"], [], Navigation_menu_link);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), active = prop($$props, "active", 3, false), onSelect = prop($$props, "onSelect", 3, noop2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "active",
      "onSelect"
    ],
    "restProps"
  );
  const linkState = useNavigationMenuLink({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    active: box.with(() => active()),
    onSelect: box.with(() => onSelect())
  });
  const mergedProps = derived(() => mergeProps(restProps, linkState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var a2 = root_278();
      let attributes;
      var node_2 = child(a2);
      snippet(node_2, () => $$props.children ?? noop);
      reset(a2);
      template_effect(() => attributes = set_attributes(a2, attributes, { ...get(mergedProps) }));
      append($$anchor2, a2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_link = hmr(Navigation_menu_link, () => Navigation_menu_link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_link[HMR].source;
    set(Navigation_menu_link[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_link_default = Navigation_menu_link;
mark_module_end(Navigation_menu_link);

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-list.svelte
mark_module_start();
Navigation_menu_list[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-list.svelte";
var root_279 = add_locations(template(`<ul><!></ul>`), Navigation_menu_list[FILENAME], [[32, 2]]);
var root10 = add_locations(template(`<div><!></div>`), Navigation_menu_list[FILENAME], [[28, 0]]);
function Navigation_menu_list($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu_list);
  validate_prop_bindings($$props, ["ref"], [], Navigation_menu_list);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const listState = useNavigationMenuList({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    indicatorTrackRef: box(null)
  });
  const mergedProps = derived(() => mergeProps(restProps, listState.props));
  const indicatorTrackProps = derived(() => mergeProps(listState.indicatorTrackProps, {}));
  var div = root10();
  let attributes;
  var node = child(div);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment);
    },
    ($$anchor2) => {
      var ul = root_279();
      let attributes_1;
      var node_2 = child(ul);
      snippet(node_2, () => $$props.children ?? noop);
      reset(ul);
      template_effect(() => attributes_1 = set_attributes(ul, attributes_1, { ...get(mergedProps) }));
      append($$anchor2, ul);
    }
  );
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...get(indicatorTrackProps) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_list = hmr(Navigation_menu_list, () => Navigation_menu_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_list[HMR].source;
    set(Navigation_menu_list[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_list_default = Navigation_menu_list;
mark_module_end(Navigation_menu_list);

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-trigger.svelte
mark_module_start();
Navigation_menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-trigger.svelte";
var root_280 = add_locations(template(`<button><!></button>`), Navigation_menu_trigger[FILENAME], [[36, 1]]);
var root_419 = add_locations(template(`<span></span>`), Navigation_menu_trigger[FILENAME], [[45, 2]]);
var root_317 = add_locations(template(`<!> <!> <!>`, 1), Navigation_menu_trigger[FILENAME], []);
var root11 = add_locations(template(`<!> <!>`, 1), Navigation_menu_trigger[FILENAME], []);
function Navigation_menu_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu_trigger);
  validate_prop_bindings($$props, ["ref"], [], Navigation_menu_trigger);
  let id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  let focusProxyMounted = state(false);
  const triggerState = useNavigationMenuTrigger({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v)),
    focusProxyMounted: box.with(() => get(focusProxyMounted))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props));
  var fragment = root11();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_280();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  var node_3 = sibling(node, 2);
  if_block(node_3, () => triggerState.open, ($$anchor2) => {
    var fragment_2 = root_317();
    var node_4 = first_child(fragment_2);
    {
      add_owner_effect(() => get(focusProxyMounted), mounted_default);
      mounted_default(node_4, {
        get isMounted() {
          return get(focusProxyMounted);
        },
        set isMounted($$value) {
          set(focusProxyMounted, proxy($$value, null, focusProxyMounted));
        }
      });
    }
    var node_5 = sibling(node_4, 2);
    visually_hidden_default(node_5, spread_props(() => triggerState.visuallyHiddenProps));
    var node_6 = sibling(node_5, 2);
    if_block(node_6, () => triggerState.menu.viewportNode, ($$anchor3) => {
      var span = root_419();
      template_effect(() => {
        var _a;
        return set_attribute(span, "aria-owns", ((_a = triggerState.item.contentNode) == null ? void 0 : _a.id) ?? void 0);
      });
      append($$anchor3, span);
    });
    append($$anchor2, fragment_2);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_trigger = hmr(Navigation_menu_trigger, () => Navigation_menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_trigger[HMR].source;
    set(Navigation_menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_trigger_default = Navigation_menu_trigger;
mark_module_end(Navigation_menu_trigger);

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-viewport.svelte
mark_module_start();
Navigation_menu_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-viewport.svelte";
var root_318 = add_locations(template(`<div><!></div>`), Navigation_menu_viewport[FILENAME], [[33, 3]]);
function Navigation_menu_viewport($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Navigation_menu_viewport);
  validate_prop_bindings($$props, ["ref"], [], Navigation_menu_viewport);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const viewportState = useNavigationMenuViewport({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, viewportState.props));
  var fragment = comment();
  var node = first_child(fragment);
  var present = derived(() => forceMount() || viewportState.open);
  {
    const presence = wrap_snippet(Navigation_menu_viewport, ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var div = root_318();
          let attributes;
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
          append($$anchor3, div);
        }
      );
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get id() {
        return id();
      },
      get present() {
        return get(present);
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_viewport = hmr(Navigation_menu_viewport, () => Navigation_menu_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_viewport[HMR].source;
    set(Navigation_menu_viewport[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_viewport_default = Navigation_menu_viewport;
mark_module_end(Navigation_menu_viewport);

// node_modules/bits-ui/dist/bits/pagination/exports.js
var exports_exports22 = {};
__export(exports_exports22, {
  NextButton: () => pagination_next_button_default,
  Page: () => pagination_page_default,
  PrevButton: () => pagination_prev_button_default,
  Root: () => pagination_default
});

// node_modules/bits-ui/dist/bits/pagination/pagination.svelte.js
var ROOT_ATTR7 = "data-pagination-root";
var PAGE_ATTR = "data-pagination-page";
var PREV_ATTR = "data-pagination-prev";
var NEXT_ATTR = "data-pagination-next";
var _totalPages, _range, _pages, _hasPrevPage, _hasNextPage, _snippetProps18, _props111;
var PaginationRootState = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "orientation");
    __publicField(this, "count");
    __publicField(this, "perPage");
    __publicField(this, "siblingCount");
    __publicField(this, "page");
    __publicField(this, "loop");
    __privateAdd(this, _totalPages, derived(() => {
      if (strict_equals(this.count.current, 0)) return 1;
      return Math.ceil(this.count.current / this.perPage.current);
    }));
    __privateAdd(this, _range, derived(() => {
      const start = (this.page.current - 1) * this.perPage.current;
      const end = Math.min(start + this.perPage.current, this.count.current);
      return { start, end };
    }));
    __privateAdd(this, _pages, derived(() => getPageItems({
      page: this.page.current,
      totalPages: this.totalPages,
      siblingCount: this.siblingCount.current
    })));
    __publicField(this, "setPage", (page) => {
      this.page.current = page;
    });
    __publicField(this, "getPageTriggerNodes", () => {
      const node = this.ref.current;
      if (!node) return [];
      return Array.from(node.querySelectorAll("[data-pagination-page]"));
    });
    __publicField(this, "getButtonNode", (type) => {
      const node = this.ref.current;
      if (!node) return;
      return node.querySelector(`[data-pagination-${type}]`);
    });
    __privateAdd(this, _hasPrevPage, derived(() => this.page.current > 1));
    __privateAdd(this, _hasNextPage, derived(() => this.page.current < this.totalPages));
    __publicField(this, "prevPage", () => {
      this.page.current = Math.max(this.page.current - 1, 1);
    });
    __publicField(this, "nextPage", () => {
      this.page.current = Math.min(this.page.current + 1, this.totalPages);
    });
    __privateAdd(this, _snippetProps18, derived(() => ({
      pages: this.pages,
      range: this.range,
      currentPage: this.page.current
    })));
    __privateAdd(this, _props111, derived(() => ({
      id: this.id.current,
      "data-orientation": getDataOrientation(this.orientation.current),
      [ROOT_ATTR7]: ""
    })));
    this.id = props.id;
    this.perPage = props.perPage;
    this.count = props.count;
    this.siblingCount = props.siblingCount;
    this.page = props.page;
    this.orientation = props.orientation;
    this.loop = props.loop;
    this.ref = props.ref;
    useRefById({ id: this.id, ref: this.ref });
  }
  get totalPages() {
    return get(__privateGet(this, _totalPages));
  }
  set totalPages(_) {
    throw new Error("Cannot update a derived property ('totalPages')");
  }
  get range() {
    return get(__privateGet(this, _range));
  }
  set range(_) {
    throw new Error("Cannot update a derived property ('range')");
  }
  get pages() {
    return get(__privateGet(this, _pages));
  }
  set pages(_) {
    throw new Error("Cannot update a derived property ('pages')");
  }
  get hasPrevPage() {
    return get(__privateGet(this, _hasPrevPage));
  }
  set hasPrevPage(_) {
    throw new Error("Cannot update a derived property ('hasPrevPage')");
  }
  get hasNextPage() {
    return get(__privateGet(this, _hasNextPage));
  }
  set hasNextPage(_) {
    throw new Error("Cannot update a derived property ('hasNextPage')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps18));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props111));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _totalPages)), owner, false);
    add_owner(get(__privateGet(this, _range)), owner, false);
    add_owner(get(__privateGet(this, _pages)), owner, false);
    add_owner(get(__privateGet(this, _hasPrevPage)), owner, false);
    add_owner(get(__privateGet(this, _hasNextPage)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps18)), owner, false);
    add_owner(get(__privateGet(this, _props111)), owner, false);
  }
};
_totalPages = new WeakMap();
_range = new WeakMap();
_pages = new WeakMap();
_hasPrevPage = new WeakMap();
_hasNextPage = new WeakMap();
_snippetProps18 = new WeakMap();
_props111 = new WeakMap();
var _id72, _ref73, _root33, _disabled11, _isSelected3, _onpointerdown17, _onpointerup10, _onkeydown34, _props112;
var PaginationPageState = class {
  constructor(props, root17) {
    __privateAdd(this, _id72);
    __privateAdd(this, _ref73);
    __privateAdd(this, _root33);
    __privateAdd(this, _disabled11);
    __publicField(this, "page");
    __privateAdd(this, _isSelected3, derived(() => strict_equals(this.page.current.value, __privateGet(this, _root33).page.current)));
    __privateAdd(this, _onpointerdown17, (e) => {
      if (__privateGet(this, _disabled11).current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      __privateGet(this, _root33).setPage(this.page.current.value);
    });
    __privateAdd(this, _onpointerup10, (e) => {
      if (__privateGet(this, _disabled11).current) return;
      if (strict_equals(e.pointerType, "touch")) {
        e.preventDefault();
        __privateGet(this, _root33).setPage(this.page.current.value);
      }
    });
    __privateAdd(this, _onkeydown34, (e) => {
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        e.preventDefault();
        __privateGet(this, _root33).setPage(this.page.current.value);
      } else {
        handleTriggerKeydown(e, __privateGet(this, _ref73).current, __privateGet(this, _root33));
      }
    });
    __privateAdd(this, _props112, derived(() => ({
      id: __privateGet(this, _id72).current,
      "aria-label": `Page ${this.page.current.value}`,
      "data-value": `${this.page.current.value}`,
      "data-selected": get(__privateGet(this, _isSelected3)) ? "" : void 0,
      [PAGE_ATTR]: "",
      //
      onpointerdown: __privateGet(this, _onpointerdown17),
      onpointerup: __privateGet(this, _onpointerup10),
      onkeydown: __privateGet(this, _onkeydown34)
    })));
    __privateSet(this, _root33, root17);
    __privateSet(this, _id72, props.id);
    this.page = props.page;
    __privateSet(this, _ref73, props.ref);
    __privateSet(this, _disabled11, props.disabled);
    useRefById({ id: __privateGet(this, _id72), ref: __privateGet(this, _ref73) });
  }
  get props() {
    return get(__privateGet(this, _props112));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props112)), owner, false);
  }
};
_id72 = new WeakMap();
_ref73 = new WeakMap();
_root33 = new WeakMap();
_disabled11 = new WeakMap();
_isSelected3 = new WeakMap();
_onpointerdown17 = new WeakMap();
_onpointerup10 = new WeakMap();
_onkeydown34 = new WeakMap();
_props112 = new WeakMap();
var _ref74, _disabled12, _root34, _type2, _action, _isDisabled8, _onpointerdown18, _onpointerup11, _onkeydown35, _props113;
var PaginationButtonState = class {
  constructor(props, root17) {
    __publicField(this, "id");
    __privateAdd(this, _ref74);
    __privateAdd(this, _disabled12);
    __privateAdd(this, _root34);
    __privateAdd(this, _type2, state());
    __privateAdd(this, _action, () => {
      strict_equals(this.type, "prev") ? __privateGet(this, _root34).prevPage() : __privateGet(this, _root34).nextPage();
    });
    __privateAdd(this, _isDisabled8, derived(() => {
      if (__privateGet(this, _disabled12).current) return true;
      if (strict_equals(this.type, "prev")) return !__privateGet(this, _root34).hasPrevPage;
      if (strict_equals(this.type, "next")) return !__privateGet(this, _root34).hasNextPage;
      return false;
    }));
    __privateAdd(this, _onpointerdown18, (e) => {
      if (__privateGet(this, _disabled12).current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      __privateGet(this, _action).call(this);
    });
    __privateAdd(this, _onpointerup11, (e) => {
      if (__privateGet(this, _disabled12).current) return;
      if (strict_equals(e.pointerType, "touch")) {
        e.preventDefault();
        __privateGet(this, _action).call(this);
      }
    });
    __privateAdd(this, _onkeydown35, (e) => {
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        e.preventDefault();
        __privateGet(this, _action).call(this);
      } else {
        handleTriggerKeydown(e, __privateGet(this, _ref74).current, __privateGet(this, _root34));
      }
    });
    __privateAdd(this, _props113, derived(() => ({
      id: this.id.current,
      [PREV_ATTR]: strict_equals(this.type, "prev") ? "" : void 0,
      [NEXT_ATTR]: strict_equals(this.type, "next") ? "" : void 0,
      disabled: get(__privateGet(this, _isDisabled8)),
      //
      onpointerdown: __privateGet(this, _onpointerdown18),
      onpointerup: __privateGet(this, _onpointerup11),
      onkeydown: __privateGet(this, _onkeydown35)
    })));
    __privateSet(this, _root34, root17);
    this.id = props.id;
    this.type = props.type;
    __privateSet(this, _ref74, props.ref);
    __privateSet(this, _disabled12, props.disabled);
    useRefById({ id: this.id, ref: __privateGet(this, _ref74) });
  }
  get type() {
    return get(__privateGet(this, _type2));
  }
  set type(value) {
    set(__privateGet(this, _type2), proxy(value, null, __privateGet(this, _type2)));
  }
  get props() {
    return get(__privateGet(this, _props113));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _type2)), owner, false);
    add_owner(get(__privateGet(this, _props113)), owner, false);
  }
};
_ref74 = new WeakMap();
_disabled12 = new WeakMap();
_root34 = new WeakMap();
_type2 = new WeakMap();
_action = new WeakMap();
_isDisabled8 = new WeakMap();
_onpointerdown18 = new WeakMap();
_onpointerup11 = new WeakMap();
_onkeydown35 = new WeakMap();
_props113 = new WeakMap();
function handleTriggerKeydown(e, node, root17) {
  if (!node || !root17.ref.current) return;
  const items = root17.getPageTriggerNodes();
  const nextButton = root17.getButtonNode("next");
  const prevButton = root17.getButtonNode("prev");
  if (prevButton) {
    items.unshift(prevButton);
  }
  if (nextButton) {
    items.push(nextButton);
  }
  const currentIndex = items.indexOf(node);
  const dir = getElemDirection(root17.ref.current);
  const { nextKey, prevKey } = getDirectionalKeys(dir, root17.orientation.current);
  const loop = root17.loop.current;
  const keyToIndex = {
    [nextKey]: currentIndex + 1,
    [prevKey]: currentIndex - 1,
    [kbd_constants_exports.HOME]: 0,
    [kbd_constants_exports.END]: items.length - 1
  };
  let itemIndex = keyToIndex[e.key];
  if (strict_equals(itemIndex, void 0)) return;
  e.preventDefault();
  if (itemIndex < 0 && loop) {
    itemIndex = items.length - 1;
  } else if (strict_equals(itemIndex, items.length) && loop) {
    itemIndex = 0;
  }
  const itemToFocus = items[itemIndex];
  if (!itemToFocus) return;
  itemToFocus.focus();
}
function getPageItems({ page = 1, totalPages, siblingCount = 1 }) {
  const pageItems = [];
  const pagesToShow = /* @__PURE__ */ new Set([1, totalPages]);
  const firstItemWithSiblings = 3 + siblingCount;
  const lastItemWithSiblings = totalPages - 2 - siblingCount;
  if (firstItemWithSiblings > lastItemWithSiblings) {
    for (let i = 2; i <= totalPages - 1; (i += 1) - 1) {
      pagesToShow.add(i);
    }
  } else if (page < firstItemWithSiblings) {
    for (let i = 2; i <= Math.min(firstItemWithSiblings, totalPages); (i += 1) - 1) {
      pagesToShow.add(i);
    }
  } else if (page > lastItemWithSiblings) {
    for (let i = totalPages - 1; i >= Math.max(lastItemWithSiblings, 2); (i -= 1) + 1) {
      pagesToShow.add(i);
    }
  } else {
    for (let i = Math.max(page - siblingCount, 2); i <= Math.min(page + siblingCount, totalPages); (i += 1) - 1) {
      pagesToShow.add(i);
    }
  }
  function addPage(value) {
    pageItems.push({ type: "page", value, key: `page-${value}` });
  }
  function addEllipsis() {
    const id = useId();
    pageItems.push({ type: "ellipsis", key: `ellipsis-${id}` });
  }
  let lastNumber = 0;
  for (const p2 of Array.from(pagesToShow).sort((a2, b) => a2 - b)) {
    if (p2 - lastNumber > 1) {
      addEllipsis();
    }
    addPage(p2);
    lastNumber = p2;
  }
  return pageItems;
}
var [
  setPaginationRootContext,
  getPaginationRootContext
] = createContext("Pagination.Root");
function usePaginationRoot(props) {
  return setPaginationRootContext(new PaginationRootState(props));
}
function usePaginationPage(props) {
  return new PaginationPageState(props, getPaginationRootContext());
}
function usePaginationButton(props) {
  return new PaginationButtonState(props, getPaginationRootContext());
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte
mark_module_start();
Pagination[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte";
var root_281 = add_locations(template(`<div><!></div>`), Pagination[FILENAME], [[54, 1]]);
function Pagination($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pagination);
  validate_prop_bindings($$props, ["page", "ref"], [], Pagination);
  let id = prop($$props, "id", 19, useId), perPage = prop($$props, "perPage", 3, 1), page = prop($$props, "page", 15, 1), ref = prop($$props, "ref", 15, null), siblingCount = prop($$props, "siblingCount", 3, 1), onPageChange = prop($$props, "onPageChange", 3, noop2), loop = prop($$props, "loop", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), controlledPage = prop($$props, "controlledPage", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "count",
      "perPage",
      "page",
      "ref",
      "siblingCount",
      "onPageChange",
      "loop",
      "orientation",
      "controlledPage",
      "child",
      "children"
    ],
    "restProps"
  );
  const rootState = usePaginationRoot({
    id: box.with(() => id()),
    count: box.with(() => $$props.count),
    perPage: box.with(() => perPage()),
    page: box.with(() => page(), (v) => {
      var _a;
      if (controlledPage()) {
        onPageChange()(v);
      } else {
        page(v);
        (_a = onPageChange()) == null ? void 0 : _a(v);
      }
    }),
    loop: box.with(() => loop()),
    siblingCount: box.with(() => siblingCount()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_281();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination = hmr(Pagination, () => Pagination[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination[HMR].source;
    set(Pagination[HMR].source, module.default[HMR].original);
  });
}
var pagination_default = Pagination;
mark_module_end(Pagination);

// node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte
mark_module_start();
Pagination_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte";
var root_282 = add_locations(template(`<button><!></button>`), Pagination_prev_button[FILENAME], [[33, 1]]);
function Pagination_prev_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pagination_prev_button);
  validate_prop_bindings($$props, ["ref"], [], Pagination_prev_button);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const prevButtonState = usePaginationButton({
    type: "prev",
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = derived(() => mergeProps(restProps, prevButtonState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_282();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_prev_button = hmr(Pagination_prev_button, () => Pagination_prev_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_prev_button[HMR].source;
    set(Pagination_prev_button[HMR].source, module.default[HMR].original);
  });
}
var pagination_prev_button_default = Pagination_prev_button;
mark_module_end(Pagination_prev_button);

// node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte
mark_module_start();
Pagination_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte";
var root_283 = add_locations(template(`<button><!></button>`), Pagination_next_button[FILENAME], [[33, 1]]);
function Pagination_next_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pagination_next_button);
  validate_prop_bindings($$props, ["ref"], [], Pagination_next_button);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const nextButtonState = usePaginationButton({
    type: "next",
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = derived(() => mergeProps(restProps, nextButtonState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_283();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_next_button = hmr(Pagination_next_button, () => Pagination_next_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_next_button[HMR].source;
    set(Pagination_next_button[HMR].source, module.default[HMR].original);
  });
}
var pagination_next_button_default = Pagination_next_button;
mark_module_end(Pagination_next_button);

// node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte
mark_module_start();
Pagination_page[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte";
var root_284 = add_locations(template(`<button><!></button>`), Pagination_page[FILENAME], [[34, 1]]);
function Pagination_page($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pagination_page);
  validate_prop_bindings($$props, ["ref"], [], Pagination_page);
  let id = prop($$props, "id", 19, useId), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "page",
      "child",
      "children",
      "type",
      "ref",
      "disabled"
    ],
    "restProps"
  );
  const pageState = usePaginationPage({
    id: box.with(() => id()),
    page: box.with(() => $$props.page),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = derived(() => mergeProps(restProps, pageState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_284();
      let attributes;
      var node_2 = child(button);
      if_block(
        node_2,
        () => $$props.children,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $$props.page.value));
          append($$anchor3, text2);
        }
      );
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_page = hmr(Pagination_page, () => Pagination_page[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_page[HMR].source;
    set(Pagination_page[HMR].source, module.default[HMR].original);
  });
}
var pagination_page_default = Pagination_page;
mark_module_end(Pagination_page);

// node_modules/bits-ui/dist/bits/pin-input/exports.js
var exports_exports23 = {};
__export(exports_exports23, {
  Cell: () => pin_input_cell_default,
  Root: () => pin_input_default
});

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte
mark_module_start();
Pin_input[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte";
var root12 = add_locations(template(`<div><!> <div><input></div></div>`), Pin_input[FILENAME], [
  [
    63,
    0,
    [[66, 1, [[67, 2]]]]
  ]
]);
function Pin_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pin_input);
  validate_prop_bindings($$props, ["ref", "value"], [], Pin_input);
  let id = prop($$props, "id", 19, useId), inputId = prop($$props, "inputId", 19, useId), ref = prop($$props, "ref", 15, null), maxlength = prop($$props, "maxlength", 3, 6), textalign = prop($$props, "textalign", 3, "left"), inputmode = prop($$props, "inputmode", 3, "numeric"), onComplete = prop($$props, "onComplete", 3, noop2), pushPasswordManagerStrategy = prop($$props, "pushPasswordManagerStrategy", 3, "increase-width"), containerClass = prop($$props, "class", 3, ""), autocomplete = prop($$props, "autocomplete", 3, "one-time-code"), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop2), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "inputId",
      "ref",
      "maxlength",
      "textalign",
      "pattern",
      "inputmode",
      "onComplete",
      "pushPasswordManagerStrategy",
      "class",
      "children",
      "autocomplete",
      "disabled",
      "value",
      "onValueChange",
      "controlledValue",
      "onPaste"
    ],
    "restProps"
  );
  const rootState = usePinInput({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    inputId: box.with(() => inputId()),
    autocomplete: box.with(() => autocomplete()),
    maxLength: box.with(() => maxlength()),
    textAlign: box.with(() => textalign()),
    disabled: box.with(() => disabled()),
    inputmode: box.with(() => inputmode()),
    pattern: box.with(() => $$props.pattern),
    onComplete: box.with(() => onComplete()),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    pushPasswordManagerStrategy: box.with(() => pushPasswordManagerStrategy()),
    onPaste: box.with(() => $$props.onPaste)
  });
  const mergedInputProps = derived(() => mergeProps(restProps, rootState.inputProps));
  const mergedRootProps = derived(() => mergeProps(rootState.rootProps, { class: containerClass() }));
  const mergedInputWrapperProps = derived(() => mergeProps(rootState.inputWrapperProps, {}));
  var div = root12();
  let attributes;
  var node = child(div);
  snippet(node, () => $$props.children ?? noop, () => rootState.snippetProps);
  var div_1 = sibling(node, 2);
  let attributes_1;
  var input = child(div_1);
  remove_input_defaults(input);
  let attributes_2;
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...get(mergedRootProps) });
    attributes_1 = set_attributes(div_1, attributes_1, { ...get(mergedInputWrapperProps) });
    attributes_2 = set_attributes(input, attributes_2, { ...get(mergedInputProps) });
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pin_input = hmr(Pin_input, () => Pin_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pin_input[HMR].source;
    set(Pin_input[HMR].source, module.default[HMR].original);
  });
}
var pin_input_default = Pin_input;
mark_module_end(Pin_input);

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input-cell.svelte
mark_module_start();
Pin_input_cell[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input-cell.svelte";
var root_285 = add_locations(template(`<div><!></div>`), Pin_input_cell[FILENAME], [[31, 1]]);
function Pin_input_cell($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pin_input_cell);
  validate_prop_bindings($$props, ["ref"], [], Pin_input_cell);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "cell",
      "child",
      "children"
    ],
    "restProps"
  );
  const cellState = usePinInputCell({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    cell: box.with(() => $$props.cell)
  });
  const mergedProps = derived(() => mergeProps(restProps, cellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_285();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pin_input_cell = hmr(Pin_input_cell, () => Pin_input_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pin_input_cell[HMR].source;
    set(Pin_input_cell[HMR].source, module.default[HMR].original);
  });
}
var pin_input_cell_default = Pin_input_cell;
mark_module_end(Pin_input_cell);

// node_modules/bits-ui/dist/bits/popover/exports.js
var exports_exports24 = {};
__export(exports_exports24, {
  Arrow: () => popover_arrow_default,
  Close: () => popover_close_default,
  Content: () => popover_content_default,
  ContentStatic: () => popover_content_static_default,
  Portal: () => portal_default,
  Root: () => popover_default,
  Trigger: () => popover_trigger_default
});

// node_modules/bits-ui/dist/bits/popover/components/popover.svelte
mark_module_start();
Popover[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover.svelte";
function Popover($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover);
  validate_prop_bindings($$props, ["open"], [], Popover);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), controlledOpen = prop($$props, "controlledOpen", 3, false);
  usePopoverRoot({
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    })
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Popover, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover = hmr(Popover, () => Popover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover[HMR].source;
    set(Popover[HMR].source, module.default[HMR].original);
  });
}
var popover_default = Popover;
mark_module_end(Popover);

// node_modules/bits-ui/dist/bits/progress/exports.js
var exports_exports25 = {};
__export(exports_exports25, {
  Root: () => progress_default
});

// node_modules/bits-ui/dist/bits/progress/progress.svelte.js
var ROOT_ATTR8 = "data-progress-root";
var _id73, _ref75, _value8, _max, _props114;
var ProgressRootState = class {
  constructor(props) {
    __privateAdd(this, _id73);
    __privateAdd(this, _ref75);
    __privateAdd(this, _value8);
    __privateAdd(this, _max);
    __privateAdd(this, _props114, derived(() => ({
      role: "meter",
      value: __privateGet(this, _value8).current,
      max: __privateGet(this, _max).current,
      "aria-valuemin": 0,
      "aria-valuemax": __privateGet(this, _max).current,
      "aria-valuenow": __privateGet(this, _value8).current,
      "data-value": __privateGet(this, _value8).current,
      "data-state": getProgressDataState(__privateGet(this, _value8).current, __privateGet(this, _max).current),
      "data-max": __privateGet(this, _max).current,
      [ROOT_ATTR8]: ""
    })));
    __privateSet(this, _value8, props.value);
    __privateSet(this, _max, props.max);
    __privateSet(this, _id73, props.id);
    __privateSet(this, _ref75, props.ref);
    useRefById({ id: __privateGet(this, _id73), ref: __privateGet(this, _ref75) });
  }
  get props() {
    return get(__privateGet(this, _props114));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props114)), owner, false);
  }
};
_id73 = new WeakMap();
_ref75 = new WeakMap();
_value8 = new WeakMap();
_max = new WeakMap();
_props114 = new WeakMap();
function getProgressDataState(value, max) {
  if (strict_equals(value, null)) return "indeterminate";
  return strict_equals(value, max) ? "loaded" : "loading";
}
function useProgressRootState(props) {
  return new ProgressRootState(props);
}

// node_modules/bits-ui/dist/bits/progress/components/progress.svelte
mark_module_start();
Progress[FILENAME] = "node_modules/bits-ui/dist/bits/progress/components/progress.svelte";
var root_286 = add_locations(template(`<div><!></div>`), Progress[FILENAME], [[33, 1]]);
function Progress($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Progress);
  validate_prop_bindings($$props, ["ref"], [], Progress);
  let value = prop($$props, "value", 3, 0), max = prop($$props, "max", 3, 100), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "max",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = useProgressRootState({
    value: box.with(() => value()),
    max: box.with(() => max()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_286();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Progress = hmr(Progress, () => Progress[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Progress[HMR].source;
    set(Progress[HMR].source, module.default[HMR].original);
  });
}
var progress_default = Progress;
mark_module_end(Progress);

// node_modules/bits-ui/dist/bits/radio-group/exports.js
var exports_exports26 = {};
__export(exports_exports26, {
  Item: () => radio_group_item_default,
  Root: () => radio_group_default
});

// node_modules/bits-ui/dist/bits/radio-group/radio-group.svelte.js
var RADIO_GROUP_ROOT_ATTR = "data-radio-group-root";
var RADIO_GROUP_ITEM_ATTR = "data-radio-group-item";
var _id74, _ref76, _hasValue3, _props115;
var RadioGroupRootState = class {
  constructor(props) {
    __privateAdd(this, _id74);
    __privateAdd(this, _ref76);
    __publicField(this, "disabled");
    __publicField(this, "required");
    __publicField(this, "loop");
    __publicField(this, "orientation");
    __publicField(this, "name");
    __publicField(this, "value");
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _hasValue3, derived(() => strict_equals(this.value.current, "", false)));
    __publicField(this, "isChecked", (value) => {
      return strict_equals(this.value.current, value);
    });
    __publicField(this, "setValue", (value) => {
      this.value.current = value;
    });
    __privateAdd(this, _props115, derived(() => ({
      id: __privateGet(this, _id74).current,
      role: "radiogroup",
      "aria-required": getAriaRequired(this.required.current),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-orientation": this.orientation.current,
      [RADIO_GROUP_ROOT_ATTR]: ""
    })));
    __privateSet(this, _id74, props.id);
    this.disabled = props.disabled;
    this.required = props.required;
    this.loop = props.loop;
    this.orientation = props.orientation;
    this.name = props.name;
    this.value = props.value;
    __privateSet(this, _ref76, props.ref);
    this.rovingFocusGroup = useRovingFocus({
      rootNodeId: __privateGet(this, _id74),
      candidateAttr: RADIO_GROUP_ITEM_ATTR,
      loop: this.loop,
      orientation: this.orientation
    });
    useRefById({ id: __privateGet(this, _id74), ref: __privateGet(this, _ref76) });
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue3));
  }
  set hasValue(_) {
    throw new Error("Cannot update a derived property ('hasValue')");
  }
  get props() {
    return get(__privateGet(this, _props115));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _hasValue3)), owner, false);
    add_owner(get(__privateGet(this, _props115)), owner, false);
  }
};
_id74 = new WeakMap();
_ref76 = new WeakMap();
_hasValue3 = new WeakMap();
_props115 = new WeakMap();
var _id75, _ref77, _root35, _disabled13, _value9, _checked2, _isDisabled9, _isChecked2, _onclick17, _onfocus7, _onkeydown36, _tabIndex2, _snippetProps19, _props116;
var RadioGroupItemState = class {
  constructor(props, root17) {
    __privateAdd(this, _id75);
    __privateAdd(this, _ref77);
    __privateAdd(this, _root35);
    __privateAdd(this, _disabled13);
    __privateAdd(this, _value9);
    __privateAdd(this, _checked2, derived(() => strict_equals(__privateGet(this, _root35).value.current, __privateGet(this, _value9).current)));
    __privateAdd(this, _isDisabled9, derived(() => __privateGet(this, _disabled13).current || __privateGet(this, _root35).disabled.current));
    __privateAdd(this, _isChecked2, derived(() => __privateGet(this, _root35).isChecked(__privateGet(this, _value9).current)));
    __privateAdd(this, _onclick17, (e) => {
      if (__privateGet(this, _disabled13).current) return;
      __privateGet(this, _root35).setValue(__privateGet(this, _value9).current);
    });
    __privateAdd(this, _onfocus7, () => {
      if (!__privateGet(this, _root35).hasValue) return;
      __privateGet(this, _root35).setValue(__privateGet(this, _value9).current);
    });
    __privateAdd(this, _onkeydown36, (e) => {
      if (get(__privateGet(this, _isDisabled9))) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE)) {
        e.preventDefault();
        __privateGet(this, _root35).setValue(__privateGet(this, _value9).current);
        return;
      }
      __privateGet(this, _root35).rovingFocusGroup.handleKeydown(__privateGet(this, _ref77).current, e, true);
    });
    __privateAdd(this, _tabIndex2, state(0));
    __privateAdd(this, _snippetProps19, derived(() => ({ checked: get(__privateGet(this, _isChecked2)) })));
    __privateAdd(this, _props116, derived(() => ({
      id: __privateGet(this, _id75).current,
      disabled: get(__privateGet(this, _isDisabled9)) ? true : void 0,
      "data-value": __privateGet(this, _value9).current,
      "data-orientation": __privateGet(this, _root35).orientation.current,
      "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled9))),
      "data-state": get(__privateGet(this, _isChecked2)) ? "checked" : "unchecked",
      "aria-checked": getAriaChecked(get(__privateGet(this, _isChecked2)), false),
      [RADIO_GROUP_ITEM_ATTR]: "",
      type: "button",
      role: "radio",
      tabindex: get(__privateGet(this, _tabIndex2)),
      //
      onkeydown: __privateGet(this, _onkeydown36),
      onfocus: __privateGet(this, _onfocus7),
      onclick: __privateGet(this, _onclick17)
    })));
    __privateSet(this, _disabled13, props.disabled);
    __privateSet(this, _value9, props.value);
    __privateSet(this, _root35, root17);
    __privateSet(this, _id75, props.id);
    __privateSet(this, _ref77, props.ref);
    useRefById({ id: __privateGet(this, _id75), ref: __privateGet(this, _ref77) });
    user_effect(() => {
      set(__privateGet(this, _tabIndex2), proxy(__privateGet(this, _root35).rovingFocusGroup.getTabIndex(__privateGet(this, _ref77).current), null, __privateGet(this, _tabIndex2)));
    });
  }
  get checked() {
    return get(__privateGet(this, _checked2));
  }
  set checked(_) {
    throw new Error("Cannot update a derived property ('checked')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps19));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props116));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _checked2)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps19)), owner, false);
    add_owner(get(__privateGet(this, _props116)), owner, false);
  }
};
_id75 = new WeakMap();
_ref77 = new WeakMap();
_root35 = new WeakMap();
_disabled13 = new WeakMap();
_value9 = new WeakMap();
_checked2 = new WeakMap();
_isDisabled9 = new WeakMap();
_isChecked2 = new WeakMap();
_onclick17 = new WeakMap();
_onfocus7 = new WeakMap();
_onkeydown36 = new WeakMap();
_tabIndex2 = new WeakMap();
_snippetProps19 = new WeakMap();
_props116 = new WeakMap();
var _root36, _shouldRender8, _props117;
var RadioGroupInputState = class {
  constructor(root17) {
    __privateAdd(this, _root36);
    __privateAdd(this, _shouldRender8, derived(() => strict_equals(__privateGet(this, _root36).name.current, void 0, false)));
    __privateAdd(this, _props117, derived(() => ({
      name: __privateGet(this, _root36).name.current,
      value: __privateGet(this, _root36).value.current,
      required: __privateGet(this, _root36).required.current,
      disabled: __privateGet(this, _root36).disabled.current,
      "aria-hidden": "true",
      hidden: true,
      style: styleToString(srOnlyStyles),
      tabIndex: -1
    })));
    __privateSet(this, _root36, root17);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender8));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get props() {
    return get(__privateGet(this, _props117));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _shouldRender8)), owner, false);
    add_owner(get(__privateGet(this, _props117)), owner, false);
  }
};
_root36 = new WeakMap();
_shouldRender8 = new WeakMap();
_props117 = new WeakMap();
var [
  setRadioGroupRootContext,
  getRadioGroupRootContext
] = createContext("RadioGroup.Root");
function useRadioGroupRoot(props) {
  return setRadioGroupRootContext(new RadioGroupRootState(props));
}
function useRadioGroupItem(props) {
  return new RadioGroupItemState(props, getRadioGroupRootContext());
}
function useRadioGroupInput() {
  return new RadioGroupInputState(getRadioGroupRootContext());
}

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte
mark_module_start();
Radio_group_input[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte";
var root_16 = add_locations(template(`<input>`), Radio_group_input[FILENAME], [[8, 1]]);
function Radio_group_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Radio_group_input);
  const inputState = useRadioGroupInput();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => inputState.shouldRender, ($$anchor2) => {
    var input = root_16();
    remove_input_defaults(input);
    let attributes;
    template_effect(() => attributes = set_attributes(input, attributes, { ...inputState.props }));
    append($$anchor2, input);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group_input = hmr(Radio_group_input, () => Radio_group_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group_input[HMR].source;
    set(Radio_group_input[HMR].source, module.default[HMR].original);
  });
}
var radio_group_input_default = Radio_group_input;
mark_module_end(Radio_group_input);

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte
mark_module_start();
Radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte";
var root_287 = add_locations(template(`<div><!></div>`), Radio_group[FILENAME], [[56, 1]]);
var root13 = add_locations(template(`<!> <!>`, 1), Radio_group[FILENAME], []);
function Radio_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Radio_group);
  validate_prop_bindings($$props, ["value", "ref"], [], Radio_group);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), ref = prop($$props, "ref", 15, null), orientation = prop($$props, "orientation", 3, "vertical"), loop = prop($$props, "loop", 3, true), name = prop($$props, "name", 3, void 0), required = prop($$props, "required", 3, false), id = prop($$props, "id", 19, useId), onValueChange = prop($$props, "onValueChange", 3, noop2), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "value",
      "ref",
      "orientation",
      "loop",
      "name",
      "required",
      "id",
      "onValueChange",
      "controlledValue"
    ],
    "restProps"
  );
  const rootState = useRadioGroupRoot({
    orientation: box.with(() => orientation()),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    name: box.with(() => name()),
    required: box.with(() => required()),
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      var _a;
      if (strict_equals(v, value())) return;
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        (_a = onValueChange()) == null ? void 0 : _a(v);
      }
    }),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = root13();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_287();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  var node_3 = sibling(node, 2);
  radio_group_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group = hmr(Radio_group, () => Radio_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group[HMR].source;
    set(Radio_group[HMR].source, module.default[HMR].original);
  });
}
var radio_group_default = Radio_group;
mark_module_end(Radio_group);

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte
mark_module_start();
Radio_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte";
var root_288 = add_locations(template(`<button><!></button>`), Radio_group_item[FILENAME], [[33, 1]]);
function Radio_group_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Radio_group_item);
  validate_prop_bindings($$props, ["ref"], [], Radio_group_item);
  let id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "value",
      "disabled",
      "ref"
    ],
    "restProps"
  );
  const itemState = useRadioGroupItem({
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_288();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group_item = hmr(Radio_group_item, () => Radio_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group_item[HMR].source;
    set(Radio_group_item[HMR].source, module.default[HMR].original);
  });
}
var radio_group_item_default = Radio_group_item;
mark_module_end(Radio_group_item);

// node_modules/bits-ui/dist/bits/range-calendar/exports.js
var exports_exports27 = {};
__export(exports_exports27, {
  Cell: () => range_calendar_cell_default,
  Day: () => range_calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => range_calendar_default
});

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte
mark_module_start();
Range_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte";
var root_289 = add_locations(template(`<div><!></div>`), Range_calendar[FILENAME], [[131, 1]]);
function Range_calendar($$anchor, $$props) {
  var _a, _b, _c;
  check_target(new.target);
  push($$props, true, Range_calendar);
  validate_prop_bindings($$props, ["ref", "value", "placeholder"], [], Range_calendar);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop2), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), weekStartsOn = prop($$props, "weekStartsOn", 3, 0), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), locale = prop($$props, "locale", 3, "en"), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop2), onEndValueChange = prop($$props, "onEndValueChange", 3, noop2), controlledPlaceholder = prop($$props, "controlledPlaceholder", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "weekdayFormat",
      "weekStartsOn",
      "pagedNavigation",
      "isDateDisabled",
      "isDateUnavailable",
      "fixedWeeks",
      "numberOfMonths",
      "locale",
      "calendarLabel",
      "disabled",
      "readonly",
      "minValue",
      "maxValue",
      "preventDeselect",
      "disableDaysOutsideMonth",
      "onStartValueChange",
      "onEndValueChange",
      "controlledPlaceholder",
      "controlledValue"
    ],
    "restProps"
  );
  let startValue = state(proxy((_a = value()) == null ? void 0 : _a.start));
  let endValue = state(proxy((_b = value()) == null ? void 0 : _b.end));
  if (strict_equals(placeholder(), void 0)) {
    const defaultPlaceholder = getDefaultDate({
      defaultPlaceholder: void 0,
      defaultValue: (_c = value()) == null ? void 0 : _c.start
    });
    if (controlledPlaceholder()) {
      onPlaceholderChange()(defaultPlaceholder);
    } else {
      placeholder(defaultPlaceholder);
    }
  }
  if (strict_equals(value(), void 0)) {
    const defaultValue = { start: void 0, end: void 0 };
    if (controlledValue()) {
      onValueChange()(defaultValue);
    } else {
      value(defaultValue);
    }
  }
  const rootState = useRangeCalendarRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      if (controlledPlaceholder()) {
        onPlaceholderChange()(v);
      } else {
        placeholder(v);
        onPlaceholderChange()(v);
      }
    }),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    preventDeselect: box.with(() => preventDeselect()),
    minValue: box.with(() => minValue()),
    maxValue: box.with(() => maxValue()),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    isDateDisabled: box.with(() => isDateDisabled()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => weekStartsOn()),
    weekdayFormat: box.with(() => weekdayFormat()),
    numberOfMonths: box.with(() => numberOfMonths()),
    locale: box.with(() => locale()),
    calendarLabel: box.with(() => calendarLabel()),
    fixedWeeks: box.with(() => fixedWeeks()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, proxy(v, null, startValue));
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, proxy(v, null, endValue));
      onEndValueChange()(v);
    })
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_289();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar = hmr(Range_calendar, () => Range_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar[HMR].source;
    set(Range_calendar[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_default = Range_calendar;
mark_module_end(Range_calendar);

// node_modules/bits-ui/dist/bits/scroll-area/exports.js
var exports_exports28 = {};
__export(exports_exports28, {
  Corner: () => scroll_area_corner_default,
  Root: () => scroll_area_default,
  Scrollbar: () => scroll_area_scrollbar_default,
  Thumb: () => scroll_area_thumb_default,
  Viewport: () => scroll_area_viewport_default
});

// node_modules/bits-ui/dist/internal/clamp.js
function clamp(n2, min, max) {
  return Math.min(max, Math.max(min, n2));
}

// node_modules/bits-ui/dist/internal/use-resize-observer.svelte.js
function useResizeObserver3(node, onResize) {
  user_effect(() => {
    let rAF = 0;
    const _node2 = node();
    if (!_node2) return;
    const resizeObserver = new ResizeObserver(() => {
      cancelAnimationFrame(rAF);
      rAF = window.requestAnimationFrame(onResize);
    });
    resizeObserver.observe(_node2);
    return () => {
      window.cancelAnimationFrame(rAF);
      resizeObserver.unobserve(_node2);
    };
  });
}

// node_modules/bits-ui/dist/bits/scroll-area/scroll-area.svelte.js
var SCROLL_AREA_ROOT_ATTR = "data-scroll-area-root";
var SCROLL_AREA_VIEWPORT_ATTR = "data-scroll-area-viewport";
var SCROLL_AREA_CORNER_ATTR = "data-scroll-area-corner";
var SCROLL_AREA_THUMB_ATTR = "data-scroll-area-thumb";
var SCROLL_AREA_SCROLLBAR_ATTR = "data-scroll-area-scrollbar";
var _id76, _ref78, _scrollAreaNode, _viewportNode5, _contentNode10, _scrollbarXNode, _scrollbarYNode, _cornerWidth, _cornerHeight, _scrollbarXEnabled, _scrollbarYEnabled, _props118;
var ScrollAreaRootState = class {
  constructor(props) {
    __privateAdd(this, _id76);
    __privateAdd(this, _ref78);
    __publicField(this, "dir");
    __publicField(this, "type");
    __publicField(this, "scrollHideDelay");
    __privateAdd(this, _scrollAreaNode, state(null));
    __privateAdd(this, _viewportNode5, state(null));
    __privateAdd(this, _contentNode10, state(null));
    __privateAdd(this, _scrollbarXNode, state(null));
    __privateAdd(this, _scrollbarYNode, state(null));
    __privateAdd(this, _cornerWidth, state(0));
    __privateAdd(this, _cornerHeight, state(0));
    __privateAdd(this, _scrollbarXEnabled, state(false));
    __privateAdd(this, _scrollbarYEnabled, state(false));
    __privateAdd(this, _props118, derived(() => ({
      id: __privateGet(this, _id76).current,
      dir: this.dir.current,
      style: {
        position: "relative",
        "--bits-scroll-area-corner-height": `${this.cornerHeight}px`,
        "--bits-scroll-area-corner-width": `${this.cornerWidth}px`
      },
      [SCROLL_AREA_ROOT_ATTR]: ""
    })));
    __privateSet(this, _id76, props.id);
    __privateSet(this, _ref78, props.ref);
    this.dir = props.dir;
    this.type = props.type;
    this.scrollHideDelay = props.scrollHideDelay;
    useRefById({
      id: __privateGet(this, _id76),
      ref: __privateGet(this, _ref78),
      onRefChange: (node) => {
        this.scrollAreaNode = node;
      }
    });
  }
  get scrollAreaNode() {
    return get(__privateGet(this, _scrollAreaNode));
  }
  set scrollAreaNode(value) {
    set(__privateGet(this, _scrollAreaNode), proxy(value, null, __privateGet(this, _scrollAreaNode)));
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode5));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode5), proxy(value, null, __privateGet(this, _viewportNode5)));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode10));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode10), proxy(value, null, __privateGet(this, _contentNode10)));
  }
  get scrollbarXNode() {
    return get(__privateGet(this, _scrollbarXNode));
  }
  set scrollbarXNode(value) {
    set(__privateGet(this, _scrollbarXNode), proxy(value, null, __privateGet(this, _scrollbarXNode)));
  }
  get scrollbarYNode() {
    return get(__privateGet(this, _scrollbarYNode));
  }
  set scrollbarYNode(value) {
    set(__privateGet(this, _scrollbarYNode), proxy(value, null, __privateGet(this, _scrollbarYNode)));
  }
  get cornerWidth() {
    return get(__privateGet(this, _cornerWidth));
  }
  set cornerWidth(value) {
    set(__privateGet(this, _cornerWidth), proxy(value, null, __privateGet(this, _cornerWidth)));
  }
  get cornerHeight() {
    return get(__privateGet(this, _cornerHeight));
  }
  set cornerHeight(value) {
    set(__privateGet(this, _cornerHeight), proxy(value, null, __privateGet(this, _cornerHeight)));
  }
  get scrollbarXEnabled() {
    return get(__privateGet(this, _scrollbarXEnabled));
  }
  set scrollbarXEnabled(value) {
    set(__privateGet(this, _scrollbarXEnabled), proxy(value, null, __privateGet(this, _scrollbarXEnabled)));
  }
  get scrollbarYEnabled() {
    return get(__privateGet(this, _scrollbarYEnabled));
  }
  set scrollbarYEnabled(value) {
    set(__privateGet(this, _scrollbarYEnabled), proxy(value, null, __privateGet(this, _scrollbarYEnabled)));
  }
  get props() {
    return get(__privateGet(this, _props118));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _scrollAreaNode)), owner, false);
    add_owner(get(__privateGet(this, _viewportNode5)), owner, false);
    add_owner(get(__privateGet(this, _contentNode10)), owner, false);
    add_owner(get(__privateGet(this, _scrollbarXNode)), owner, false);
    add_owner(get(__privateGet(this, _scrollbarYNode)), owner, false);
    add_owner(get(__privateGet(this, _cornerWidth)), owner, false);
    add_owner(get(__privateGet(this, _cornerHeight)), owner, false);
    add_owner(get(__privateGet(this, _scrollbarXEnabled)), owner, false);
    add_owner(get(__privateGet(this, _scrollbarYEnabled)), owner, false);
    add_owner(get(__privateGet(this, _props118)), owner, false);
  }
};
_id76 = new WeakMap();
_ref78 = new WeakMap();
_scrollAreaNode = new WeakMap();
_viewportNode5 = new WeakMap();
_contentNode10 = new WeakMap();
_scrollbarXNode = new WeakMap();
_scrollbarYNode = new WeakMap();
_cornerWidth = new WeakMap();
_cornerHeight = new WeakMap();
_scrollbarXEnabled = new WeakMap();
_scrollbarYEnabled = new WeakMap();
_props118 = new WeakMap();
var _id77, _ref79, _contentId5, _contentRef, _props119, _contentProps;
var ScrollAreaViewportState = class {
  constructor(props, root17) {
    __privateAdd(this, _id77);
    __privateAdd(this, _ref79);
    __privateAdd(this, _contentId5, box(useId()));
    __privateAdd(this, _contentRef, box(null));
    __publicField(this, "root");
    __privateAdd(this, _props119, derived(() => ({
      id: __privateGet(this, _id77).current,
      style: {
        overflowX: this.root.scrollbarXEnabled ? "scroll" : "hidden",
        overflowY: this.root.scrollbarYEnabled ? "scroll" : "hidden"
      },
      [SCROLL_AREA_VIEWPORT_ATTR]: ""
    })));
    __privateAdd(this, _contentProps, derived(() => ({
      id: __privateGet(this, _contentId5).current,
      "data-scroll-area-content": "",
      /**
       * When horizontal scrollbar is visible: this element should be at least
       * as wide as its children for size calculations to work correctly.
       *
       * When horizontal scrollbar is NOT visible: this element's width should
       * be constrained by the parent container to enable `text-overflow: ellipsis`
       */
      style: {
        minWidth: this.root.scrollbarXEnabled ? "fit-content" : void 0
      }
    })));
    __privateSet(this, _id77, props.id);
    __privateSet(this, _ref79, props.ref);
    this.root = root17;
    useRefById({
      id: __privateGet(this, _id77),
      ref: __privateGet(this, _ref79),
      onRefChange: (node) => {
        this.root.viewportNode = node;
      }
    });
    useRefById({
      id: __privateGet(this, _contentId5),
      ref: __privateGet(this, _contentRef),
      onRefChange: (node) => {
        this.root.contentNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props119));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  get contentProps() {
    return get(__privateGet(this, _contentProps));
  }
  set contentProps(_) {
    throw new Error("Cannot update a derived property ('contentProps')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props119)), owner, false);
    add_owner(get(__privateGet(this, _contentProps)), owner, false);
  }
};
_id77 = new WeakMap();
_ref79 = new WeakMap();
_contentId5 = new WeakMap();
_contentRef = new WeakMap();
_props119 = new WeakMap();
_contentProps = new WeakMap();
var _isHorizontal2, _hasThumb;
var ScrollAreaScrollbarState = class {
  constructor(props, root17) {
    __publicField(this, "ref");
    __publicField(this, "id");
    __publicField(this, "root");
    __publicField(this, "orientation");
    __privateAdd(this, _isHorizontal2, derived(() => strict_equals(this.orientation.current, "horizontal")));
    __privateAdd(this, _hasThumb, state(false));
    this.root = root17;
    this.orientation = props.orientation;
    this.ref = props.ref;
    this.id = props.id;
    user_effect(() => {
      this.isHorizontal ? this.root.scrollbarXEnabled = true : this.root.scrollbarYEnabled = true;
      return () => {
        this.isHorizontal ? this.root.scrollbarXEnabled = false : this.root.scrollbarYEnabled = false;
      };
    });
  }
  get isHorizontal() {
    return get(__privateGet(this, _isHorizontal2));
  }
  set isHorizontal(_) {
    throw new Error("Cannot update a derived property ('isHorizontal')");
  }
  get hasThumb() {
    return get(__privateGet(this, _hasThumb));
  }
  set hasThumb(value) {
    set(__privateGet(this, _hasThumb), proxy(value, null, __privateGet(this, _hasThumb)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isHorizontal2)), owner, false);
    add_owner(get(__privateGet(this, _hasThumb)), owner, false);
  }
};
_isHorizontal2 = new WeakMap();
_hasThumb = new WeakMap();
var _isVisible2, _props120;
var ScrollAreaScrollbarHoverState = class {
  constructor(scrollbar) {
    __publicField(this, "root");
    __privateAdd(this, _isVisible2, state(false));
    __publicField(this, "scrollbar");
    __privateAdd(this, _props120, derived(() => ({
      "data-state": this.isVisible ? "visible" : "hidden"
    })));
    this.root = scrollbar.root;
    this.scrollbar = scrollbar;
    user_effect(() => {
      const scrollAreaNode = this.root.scrollAreaNode;
      const hideDelay = this.root.scrollHideDelay.current;
      let hideTimer = 0;
      if (!scrollAreaNode) return;
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        untrack(() => this.isVisible = true);
      };
      const handlePointerLeave = () => {
        if (hideTimer) window.clearTimeout(hideTimer);
        hideTimer = window.setTimeout(
          () => {
            untrack(() => {
              this.scrollbar.hasThumb = false;
              this.isVisible = false;
            });
          },
          hideDelay
        );
      };
      const unsubListeners = executeCallbacks(addEventListener2(scrollAreaNode, "pointerenter", handlePointerEnter), addEventListener2(scrollAreaNode, "pointerleave", handlePointerLeave));
      return () => {
        window.clearTimeout(hideTimer);
        unsubListeners();
      };
    });
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible2));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible2), proxy(value, null, __privateGet(this, _isVisible2)));
  }
  get props() {
    return get(__privateGet(this, _props120));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isVisible2)), owner, false);
    add_owner(get(__privateGet(this, _props120)), owner, false);
  }
};
_isVisible2 = new WeakMap();
_props120 = new WeakMap();
var _isHidden, _onpointerenter6, _onpointerleave7, _props121;
var ScrollAreaScrollbarScrollState = class {
  constructor(scrollbar) {
    __publicField(this, "orientation");
    __publicField(this, "root");
    __publicField(this, "scrollbar");
    __publicField(this, "machine", useStateMachine("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: { SCROLL: "interacting", POINTER_LEAVE: "idle" },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }));
    __privateAdd(this, _isHidden, derived(() => strict_equals(this.machine.state.current, "hidden")));
    __privateAdd(this, _onpointerenter6, () => {
      this.machine.dispatch("POINTER_ENTER");
    });
    __privateAdd(this, _onpointerleave7, () => {
      this.machine.dispatch("POINTER_LEAVE");
    });
    __privateAdd(this, _props121, derived(() => ({
      "data-state": strict_equals(this.machine.state.current, "hidden") ? "hidden" : "visible",
      onpointerenter: __privateGet(this, _onpointerenter6),
      onpointerleave: __privateGet(this, _onpointerleave7)
    })));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    this.orientation = this.scrollbar.orientation;
    const debounceScrollend = useDebounce(() => this.machine.dispatch("SCROLL_END"), 100);
    user_effect(() => {
      const _state = this.machine.state.current;
      const scrollHideDelay = this.root.scrollHideDelay.current;
      if (strict_equals(_state, "idle")) {
        const hideTimer = window.setTimeout(() => this.machine.dispatch("HIDE"), scrollHideDelay);
        return () => window.clearTimeout(hideTimer);
      }
    });
    user_effect(() => {
      const viewportNode = this.root.viewportNode;
      if (!viewportNode) return;
      const scrollDirection = this.scrollbar.isHorizontal ? "scrollLeft" : "scrollTop";
      let prevScrollPos = viewportNode[scrollDirection];
      const handleScroll = () => {
        const scrollPos = viewportNode[scrollDirection];
        const hasScrollInDirectionChanged = strict_equals(prevScrollPos, scrollPos, false);
        if (hasScrollInDirectionChanged) {
          this.machine.dispatch("SCROLL");
          debounceScrollend();
        }
        prevScrollPos = scrollPos;
      };
      const unsubListener = addEventListener2(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
  }
  get isHidden() {
    return get(__privateGet(this, _isHidden));
  }
  set isHidden(_) {
    throw new Error("Cannot update a derived property ('isHidden')");
  }
  get props() {
    return get(__privateGet(this, _props121));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isHidden)), owner, false);
    add_owner(get(__privateGet(this, _props121)), owner, false);
  }
};
_isHidden = new WeakMap();
_onpointerenter6 = new WeakMap();
_onpointerleave7 = new WeakMap();
_props121 = new WeakMap();
var _isVisible3, _props122;
var ScrollAreaScrollbarAutoState = class {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _isVisible3, state(false));
    __privateAdd(this, _props122, derived(() => ({
      "data-state": this.isVisible ? "visible" : "hidden"
    })));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    const handleResize = useDebounce(
      () => {
        const viewportNode = this.root.viewportNode;
        if (!viewportNode) return;
        const isOverflowX = viewportNode.offsetWidth < viewportNode.scrollWidth;
        const isOverflowY = viewportNode.offsetHeight < viewportNode.scrollHeight;
        this.isVisible = this.scrollbar.isHorizontal ? isOverflowX : isOverflowY;
      },
      10
    );
    useResizeObserver3(() => this.root.viewportNode, handleResize);
    useResizeObserver3(() => this.root.contentNode, handleResize);
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible3));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible3), proxy(value, null, __privateGet(this, _isVisible3)));
  }
  get props() {
    return get(__privateGet(this, _props122));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isVisible3)), owner, false);
    add_owner(get(__privateGet(this, _props122)), owner, false);
  }
};
_isVisible3 = new WeakMap();
_props122 = new WeakMap();
var _thumbNode, _pointerOffset, _sizes, _thumbRatio, _hasThumb2;
var ScrollAreaScrollbarVisibleState = class {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _thumbNode, state(null));
    __privateAdd(this, _pointerOffset, state(0));
    __privateAdd(this, _sizes, state({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }));
    __privateAdd(this, _thumbRatio, derived(() => getThumbRatio(this.sizes.viewport, this.sizes.content)));
    __privateAdd(this, _hasThumb2, derived(() => Boolean(this.thumbRatio > 0 && this.thumbRatio < 1)));
    __publicField(this, "prevTransformStyle", "");
    __publicField(this, "setSizes", (sizes) => {
      this.sizes = sizes;
    });
    __publicField(this, "getScrollPosition", (pointerPos, dir) => {
      return getScrollPositionFromPointer({
        pointerPos,
        pointerOffset: this.pointerOffset,
        sizes: this.sizes,
        dir
      });
    });
    __publicField(this, "onThumbPointerUp", () => {
      this.pointerOffset = 0;
    });
    __publicField(this, "onThumbPointerDown", (pointerPos) => {
      this.pointerOffset = pointerPos;
    });
    __publicField(this, "xOnThumbPositionChange", () => {
      if (!(this.root.viewportNode && this.thumbNode)) return;
      const scrollPos = this.root.viewportNode.scrollLeft;
      const offset2 = getThumbOffsetFromScroll({
        scrollPos,
        sizes: this.sizes,
        dir: this.root.dir.current
      });
      const transformStyle = `translate3d(${offset2}px, 0, 0)`;
      this.thumbNode.style.transform = transformStyle;
    });
    __publicField(this, "xOnWheelScroll", (scrollPos) => {
      if (!this.root.viewportNode) return;
      this.root.viewportNode.scrollLeft = scrollPos;
    });
    __publicField(this, "xOnDragScroll", (pointerPos) => {
      if (!this.root.viewportNode) return;
      this.root.viewportNode.scrollLeft = this.getScrollPosition(pointerPos, this.root.dir.current);
    });
    __publicField(this, "yOnThumbPositionChange", () => {
      if (!(this.root.viewportNode && this.thumbNode)) return;
      const scrollPos = this.root.viewportNode.scrollTop;
      const offset2 = getThumbOffsetFromScroll({ scrollPos, sizes: this.sizes });
      const transformStyle = `translate3d(0, ${offset2}px, 0)`;
      this.thumbNode.style.transform = transformStyle;
    });
    __publicField(this, "yOnWheelScroll", (scrollPos) => {
      if (!this.root.viewportNode) return;
      this.root.viewportNode.scrollTop = scrollPos;
    });
    __publicField(this, "yOnDragScroll", (pointerPos) => {
      if (!this.root.viewportNode) return;
      this.root.viewportNode.scrollTop = this.getScrollPosition(pointerPos, this.root.dir.current);
    });
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    user_effect(() => {
      this.scrollbar.hasThumb = this.hasThumb;
    });
    user_pre_effect(() => {
      if (!this.scrollbar.hasThumb && this.thumbNode) {
        this.prevTransformStyle = this.thumbNode.style.transform;
      }
    });
  }
  get thumbNode() {
    return get(__privateGet(this, _thumbNode));
  }
  set thumbNode(value) {
    set(__privateGet(this, _thumbNode), proxy(value, null, __privateGet(this, _thumbNode)));
  }
  get pointerOffset() {
    return get(__privateGet(this, _pointerOffset));
  }
  set pointerOffset(value) {
    set(__privateGet(this, _pointerOffset), proxy(value, null, __privateGet(this, _pointerOffset)));
  }
  get sizes() {
    return get(__privateGet(this, _sizes));
  }
  set sizes(value) {
    set(__privateGet(this, _sizes), value);
  }
  get thumbRatio() {
    return get(__privateGet(this, _thumbRatio));
  }
  set thumbRatio(_) {
    throw new Error("Cannot update a derived property ('thumbRatio')");
  }
  get hasThumb() {
    return get(__privateGet(this, _hasThumb2));
  }
  set hasThumb(_) {
    throw new Error("Cannot update a derived property ('hasThumb')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _thumbNode)), owner, false);
    add_owner(get(__privateGet(this, _pointerOffset)), owner, false);
    add_owner(get(__privateGet(this, _sizes)), owner, false);
    add_owner(get(__privateGet(this, _thumbRatio)), owner, false);
    add_owner(get(__privateGet(this, _hasThumb2)), owner, false);
  }
};
_thumbNode = new WeakMap();
_pointerOffset = new WeakMap();
_sizes = new WeakMap();
_thumbRatio = new WeakMap();
_hasThumb2 = new WeakMap();
var _id78, _mounted2, _computedStyle, _thumbSize, _props123;
var ScrollAreaScrollbarXState = class {
  constructor(props, scrollbarVis) {
    __privateAdd(this, _id78);
    __privateAdd(this, _mounted2);
    __publicField(this, "ref");
    __publicField(this, "scrollbarVis");
    __publicField(this, "root");
    __privateAdd(this, _computedStyle, state());
    __publicField(this, "onThumbPointerDown", (pointerPos) => {
      this.scrollbarVis.onThumbPointerDown(pointerPos.x);
    });
    __publicField(this, "onDragScroll", (pointerPos) => {
      this.scrollbarVis.xOnDragScroll(pointerPos.x);
    });
    __publicField(this, "onThumbPointerUp", () => {
      this.scrollbarVis.onThumbPointerUp();
    });
    __publicField(this, "onThumbPositionChange", () => {
      this.scrollbarVis.xOnThumbPositionChange();
    });
    __publicField(this, "onWheelScroll", (e, maxScrollPos) => {
      if (!this.root.viewportNode) return;
      const scrollPos = this.root.viewportNode.scrollLeft + e.deltaX;
      this.scrollbarVis.xOnWheelScroll(scrollPos);
      if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
        e.preventDefault();
      }
    });
    __publicField(this, "onResize", () => {
      if (!(this.ref.current && this.root.viewportNode && this.computedStyle)) return;
      this.scrollbarVis.setSizes({
        content: this.root.viewportNode.scrollWidth,
        viewport: this.root.viewportNode.offsetWidth,
        scrollbar: {
          size: this.ref.current.clientWidth,
          paddingStart: toInt(this.computedStyle.paddingLeft),
          paddingEnd: toInt(this.computedStyle.paddingRight)
        }
      });
    });
    __privateAdd(this, _thumbSize, derived(() => {
      return getThumbSize(this.scrollbarVis.sizes);
    }));
    __privateAdd(this, _props123, derived(() => ({
      id: __privateGet(this, _id78).current,
      "data-orientation": "horizontal",
      style: {
        bottom: 0,
        left: strict_equals(this.root.dir.current, "rtl") ? "var(--bits-scroll-area-corner-width)" : 0,
        right: strict_equals(this.root.dir.current, "ltr") ? "var(--bits-scroll-area-corner-width)" : 0,
        "--bits-scroll-area-thumb-width": `${this.thumbSize}px`
      }
    })));
    __privateSet(this, _mounted2, props.mounted);
    this.scrollbarVis = scrollbarVis;
    __privateSet(this, _id78, this.scrollbarVis.scrollbar.id);
    this.ref = this.scrollbarVis.scrollbar.ref;
    this.root = scrollbarVis.root;
    useRefById({
      id: __privateGet(this, _id78),
      ref: this.ref,
      onRefChange: (node) => {
        this.root.scrollbarXNode = node;
      },
      deps: () => __privateGet(this, _mounted2).current
    });
    user_effect(() => {
      if (!this.ref.current) return;
      if (__privateGet(this, _mounted2).current) {
        this.computedStyle = getComputedStyle(this.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
  }
  get computedStyle() {
    return get(__privateGet(this, _computedStyle));
  }
  set computedStyle(value) {
    set(__privateGet(this, _computedStyle), proxy(value, null, __privateGet(this, _computedStyle)));
  }
  get thumbSize() {
    return get(__privateGet(this, _thumbSize));
  }
  set thumbSize(_) {
    throw new Error("Cannot update a derived property ('thumbSize')");
  }
  get props() {
    return get(__privateGet(this, _props123));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _computedStyle)), owner, false);
    add_owner(get(__privateGet(this, _thumbSize)), owner, false);
    add_owner(get(__privateGet(this, _props123)), owner, false);
  }
};
_id78 = new WeakMap();
_mounted2 = new WeakMap();
_computedStyle = new WeakMap();
_thumbSize = new WeakMap();
_props123 = new WeakMap();
var _id79, _mounted3, _computedStyle2, _thumbSize2, _props124;
var ScrollAreaScrollbarYState = class {
  constructor(props, scrollbarVis) {
    __privateAdd(this, _id79);
    __privateAdd(this, _mounted3);
    __publicField(this, "ref");
    __publicField(this, "scrollbarVis");
    __publicField(this, "root");
    __privateAdd(this, _computedStyle2, state());
    __publicField(this, "onThumbPointerDown", (pointerPos) => {
      this.scrollbarVis.onThumbPointerDown(pointerPos.y);
    });
    __publicField(this, "onDragScroll", (pointerPos) => {
      this.scrollbarVis.yOnDragScroll(pointerPos.y);
    });
    __publicField(this, "onThumbPointerUp", () => {
      this.scrollbarVis.onThumbPointerUp();
    });
    __publicField(this, "onThumbPositionChange", () => {
      this.scrollbarVis.yOnThumbPositionChange();
    });
    __publicField(this, "onWheelScroll", (e, maxScrollPos) => {
      if (!this.root.viewportNode) return;
      const scrollPos = this.root.viewportNode.scrollTop + e.deltaY;
      this.scrollbarVis.yOnWheelScroll(scrollPos);
      if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
        e.preventDefault();
      }
    });
    __publicField(this, "onResize", () => {
      if (!(this.ref.current && this.root.viewportNode && this.computedStyle)) return;
      this.scrollbarVis.setSizes({
        content: this.root.viewportNode.scrollHeight,
        viewport: this.root.viewportNode.offsetHeight,
        scrollbar: {
          size: this.ref.current.clientHeight,
          paddingStart: toInt(this.computedStyle.paddingTop),
          paddingEnd: toInt(this.computedStyle.paddingBottom)
        }
      });
    });
    __privateAdd(this, _thumbSize2, derived(() => {
      return getThumbSize(this.scrollbarVis.sizes);
    }));
    __privateAdd(this, _props124, derived(() => ({
      id: __privateGet(this, _id79).current,
      "data-orientation": "vertical",
      style: {
        top: 0,
        right: strict_equals(this.root.dir.current, "ltr") ? 0 : void 0,
        left: strict_equals(this.root.dir.current, "rtl") ? 0 : void 0,
        bottom: "var(--bits-scroll-area-corner-height)",
        "--bits-scroll-area-thumb-height": `${this.thumbSize}px`
      }
    })));
    __privateSet(this, _mounted3, props.mounted);
    this.scrollbarVis = scrollbarVis;
    __privateSet(this, _id79, this.scrollbarVis.scrollbar.id);
    this.ref = this.scrollbarVis.scrollbar.ref;
    this.root = scrollbarVis.root;
    useRefById({
      id: this.scrollbarVis.scrollbar.id,
      ref: this.scrollbarVis.scrollbar.ref,
      onRefChange: (node) => {
        this.root.scrollbarYNode = node;
      },
      deps: () => __privateGet(this, _mounted3).current
    });
    user_effect(() => {
      if (!this.ref.current) return;
      if (__privateGet(this, _mounted3).current) {
        this.computedStyle = getComputedStyle(this.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
  }
  get computedStyle() {
    return get(__privateGet(this, _computedStyle2));
  }
  set computedStyle(value) {
    set(__privateGet(this, _computedStyle2), proxy(value, null, __privateGet(this, _computedStyle2)));
  }
  get thumbSize() {
    return get(__privateGet(this, _thumbSize2));
  }
  set thumbSize(_) {
    throw new Error("Cannot update a derived property ('thumbSize')");
  }
  get props() {
    return get(__privateGet(this, _props124));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _computedStyle2)), owner, false);
    add_owner(get(__privateGet(this, _thumbSize2)), owner, false);
    add_owner(get(__privateGet(this, _props124)), owner, false);
  }
};
_id79 = new WeakMap();
_mounted3 = new WeakMap();
_computedStyle2 = new WeakMap();
_thumbSize2 = new WeakMap();
_props124 = new WeakMap();
var _rect, _prevWebkitUserSelect, _maxScrollPos, _onpointerdown19, _onpointermove10, _onpointerup12, _props125;
var ScrollAreaScrollbarSharedState = class {
  constructor(scrollbarState) {
    __publicField(this, "scrollbarState");
    __publicField(this, "root");
    __publicField(this, "scrollbarVis");
    __privateAdd(this, _rect, state(null));
    __privateAdd(this, _prevWebkitUserSelect, state(""));
    __publicField(this, "handleResize");
    __publicField(this, "handleThumbPositionChange");
    __publicField(this, "handleWheelScroll");
    __publicField(this, "handleThumbPointerDown");
    __publicField(this, "handleThumbPointerUp");
    __privateAdd(this, _maxScrollPos, derived(() => this.scrollbarVis.sizes.content - this.scrollbarVis.sizes.viewport));
    __publicField(this, "handleDragScroll", (e) => {
      if (!this.rect) return;
      const x = e.clientX - this.rect.left;
      const y = e.clientY - this.rect.top;
      this.scrollbarState.onDragScroll({ x, y });
    });
    __privateAdd(this, _onpointerdown19, (e) => {
      var _a;
      if (strict_equals(e.button, 0, false)) return;
      const target = e.target;
      target.setPointerCapture(e.pointerId);
      this.rect = ((_a = this.scrollbarState.ref.current) == null ? void 0 : _a.getBoundingClientRect()) ?? null;
      this.prevWebkitUserSelect = document.body.style.webkitUserSelect;
      document.body.style.webkitUserSelect = "none";
      if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "auto";
      this.handleDragScroll(e);
    });
    __privateAdd(this, _onpointermove10, (e) => {
      this.handleDragScroll(e);
    });
    __privateAdd(this, _onpointerup12, (e) => {
      const target = e.target;
      if (target.hasPointerCapture(e.pointerId)) {
        target.releasePointerCapture(e.pointerId);
      }
      document.body.style.webkitUserSelect = this.prevWebkitUserSelect;
      if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "";
      this.rect = null;
    });
    __privateAdd(this, _props125, derived(() => mergeProps({
      ...this.scrollbarState.props,
      style: {
        position: "absolute",
        ...this.scrollbarState.props.style
      },
      [SCROLL_AREA_SCROLLBAR_ATTR]: "",
      onpointerdown: __privateGet(this, _onpointerdown19),
      onpointermove: __privateGet(this, _onpointermove10),
      onpointerup: __privateGet(this, _onpointerup12)
    })));
    this.scrollbarState = scrollbarState;
    this.root = scrollbarState.root;
    this.scrollbarVis = scrollbarState.scrollbarVis;
    this.handleResize = useDebounce(() => this.scrollbarState.onResize(), 10);
    this.handleThumbPositionChange = this.scrollbarState.onThumbPositionChange;
    this.handleWheelScroll = this.scrollbarState.onWheelScroll;
    this.handleThumbPointerDown = this.scrollbarState.onThumbPointerDown;
    this.handleThumbPointerUp = this.scrollbarState.onThumbPointerUp;
    user_effect(() => {
      const maxScrollPos = this.maxScrollPos;
      const scrollbarNode = this.scrollbarState.ref.current;
      this.root.viewportNode;
      const handleWheel = (e) => {
        const node = e.target;
        const isScrollbarWheel = scrollbarNode == null ? void 0 : scrollbarNode.contains(node);
        if (isScrollbarWheel) this.handleWheelScroll(e, maxScrollPos);
      };
      const unsubListener = addEventListener2(document, "wheel", handleWheel, { passive: false });
      return unsubListener;
    });
    user_effect(() => {
      this.scrollbarVis.sizes;
      untrack(() => this.handleThumbPositionChange());
    });
    user_effect(() => {
      this.handleThumbPositionChange();
    });
    useResizeObserver3(() => this.scrollbarState.ref.current, this.handleResize);
    useResizeObserver3(() => this.root.contentNode, this.handleResize);
  }
  get rect() {
    return get(__privateGet(this, _rect));
  }
  set rect(value) {
    set(__privateGet(this, _rect), value);
  }
  get prevWebkitUserSelect() {
    return get(__privateGet(this, _prevWebkitUserSelect));
  }
  set prevWebkitUserSelect(value) {
    set(__privateGet(this, _prevWebkitUserSelect), proxy(value, null, __privateGet(this, _prevWebkitUserSelect)));
  }
  get maxScrollPos() {
    return get(__privateGet(this, _maxScrollPos));
  }
  set maxScrollPos(_) {
    throw new Error("Cannot update a derived property ('maxScrollPos')");
  }
  get props() {
    return get(__privateGet(this, _props125));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _rect)), owner, false);
    add_owner(get(__privateGet(this, _prevWebkitUserSelect)), owner, false);
    add_owner(get(__privateGet(this, _maxScrollPos)), owner, false);
    add_owner(get(__privateGet(this, _props125)), owner, false);
  }
};
_rect = new WeakMap();
_prevWebkitUserSelect = new WeakMap();
_maxScrollPos = new WeakMap();
_onpointerdown19 = new WeakMap();
_onpointermove10 = new WeakMap();
_onpointerup12 = new WeakMap();
_props125 = new WeakMap();
var _id80, _ref80, _root37, _scrollbarState, _removeUnlinkedScrollListener, _debounceScrollEnd, _mounted4, _onpointerdowncapture, _onpointerup13, _props126;
var ScrollAreaThumbImplState = class {
  constructor(props, scrollbarState) {
    __privateAdd(this, _id80);
    __privateAdd(this, _ref80);
    __privateAdd(this, _root37);
    __privateAdd(this, _scrollbarState);
    __privateAdd(this, _removeUnlinkedScrollListener, state());
    __privateAdd(this, _debounceScrollEnd, useDebounce(
      () => {
        if (get(__privateGet(this, _removeUnlinkedScrollListener))) {
          get(__privateGet(this, _removeUnlinkedScrollListener))();
          set(__privateGet(this, _removeUnlinkedScrollListener), void 0);
        }
      },
      100
    ));
    __privateAdd(this, _mounted4);
    __privateAdd(this, _onpointerdowncapture, (e) => {
      const thumb = e.target;
      if (!thumb) return;
      const thumbRect = thumb.getBoundingClientRect();
      const x = e.clientX - thumbRect.left;
      const y = e.clientY - thumbRect.top;
      __privateGet(this, _scrollbarState).handleThumbPointerDown({ x, y });
    });
    __privateAdd(this, _onpointerup13, () => {
      __privateGet(this, _scrollbarState).handleThumbPointerUp();
    });
    __privateAdd(this, _props126, derived(() => ({
      id: __privateGet(this, _id80).current,
      "data-state": __privateGet(this, _scrollbarState).scrollbarVis.hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--bits-scroll-area-thumb-width)",
        height: "var(--bits-scroll-area-thumb-height)",
        transform: __privateGet(this, _scrollbarState).scrollbarVis.prevTransformStyle
      },
      onpointerdowncapture: __privateGet(this, _onpointerdowncapture),
      onpointerup: __privateGet(this, _onpointerup13),
      [SCROLL_AREA_THUMB_ATTR]: ""
    })));
    __privateSet(this, _root37, scrollbarState.root);
    __privateSet(this, _scrollbarState, scrollbarState);
    __privateSet(this, _mounted4, props.mounted);
    __privateSet(this, _id80, props.id);
    __privateSet(this, _ref80, props.ref);
    useRefById({
      id: __privateGet(this, _id80),
      ref: __privateGet(this, _ref80),
      onRefChange: (node) => {
        __privateGet(this, _scrollbarState).scrollbarVis.thumbNode = node;
      },
      deps: () => __privateGet(this, _mounted4).current
    });
    user_effect(() => {
      const viewportNode = __privateGet(this, _root37).viewportNode;
      if (!viewportNode) return;
      const handleScroll = () => {
        __privateGet(this, _debounceScrollEnd).call(this);
        if (!get(__privateGet(this, _removeUnlinkedScrollListener))) {
          const listener = addUnlinkedScrollListener(viewportNode, __privateGet(this, _scrollbarState).handleThumbPositionChange);
          set(__privateGet(this, _removeUnlinkedScrollListener), proxy(listener, null, __privateGet(this, _removeUnlinkedScrollListener)));
          __privateGet(this, _scrollbarState).handleThumbPositionChange();
        }
      };
      __privateGet(this, _scrollbarState).handleThumbPositionChange();
      const unsubListener = addEventListener2(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
  }
  get props() {
    return get(__privateGet(this, _props126));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props126)), owner, false);
  }
};
_id80 = new WeakMap();
_ref80 = new WeakMap();
_root37 = new WeakMap();
_scrollbarState = new WeakMap();
_removeUnlinkedScrollListener = new WeakMap();
_debounceScrollEnd = new WeakMap();
_mounted4 = new WeakMap();
_onpointerdowncapture = new WeakMap();
_onpointerup13 = new WeakMap();
_props126 = new WeakMap();
var _id81, _ref81, _root38, _width3, _height3, _hasSize, _props127;
var ScrollAreaCornerImplState = class {
  constructor(props, root17) {
    __privateAdd(this, _id81);
    __privateAdd(this, _ref81);
    __privateAdd(this, _root38);
    __privateAdd(this, _width3, state(0));
    __privateAdd(this, _height3, state(0));
    __privateAdd(this, _hasSize, derived(() => Boolean(get(__privateGet(this, _width3)) && get(__privateGet(this, _height3)))));
    __privateAdd(this, _props127, derived(() => ({
      id: __privateGet(this, _id81).current,
      style: {
        width: get(__privateGet(this, _width3)),
        height: get(__privateGet(this, _height3)),
        position: "absolute",
        right: strict_equals(__privateGet(this, _root38).dir.current, "ltr") ? 0 : void 0,
        left: strict_equals(__privateGet(this, _root38).dir.current, "rtl") ? 0 : void 0,
        bottom: 0
      },
      [SCROLL_AREA_CORNER_ATTR]: ""
    })));
    __privateSet(this, _root38, root17);
    __privateSet(this, _id81, props.id);
    __privateSet(this, _ref81, props.ref);
    useResizeObserver3(() => __privateGet(this, _root38).scrollbarXNode, () => {
      var _a;
      const height = ((_a = __privateGet(this, _root38).scrollbarXNode) == null ? void 0 : _a.offsetHeight) || 0;
      __privateGet(this, _root38).cornerHeight = height;
      set(__privateGet(this, _height3), proxy(height, null, __privateGet(this, _height3)));
    });
    useResizeObserver3(() => __privateGet(this, _root38).scrollbarYNode, () => {
      var _a;
      const width = ((_a = __privateGet(this, _root38).scrollbarYNode) == null ? void 0 : _a.offsetWidth) || 0;
      __privateGet(this, _root38).cornerWidth = width;
      set(__privateGet(this, _width3), proxy(width, null, __privateGet(this, _width3)));
    });
    useRefById({ id: __privateGet(this, _id81), ref: __privateGet(this, _ref81) });
  }
  get hasSize() {
    return get(__privateGet(this, _hasSize));
  }
  set hasSize(_) {
    throw new Error("Cannot update a derived property ('hasSize')");
  }
  get props() {
    return get(__privateGet(this, _props127));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _hasSize)), owner, false);
    add_owner(get(__privateGet(this, _props127)), owner, false);
  }
};
_id81 = new WeakMap();
_ref81 = new WeakMap();
_root38 = new WeakMap();
_width3 = new WeakMap();
_height3 = new WeakMap();
_hasSize = new WeakMap();
_props127 = new WeakMap();
var [
  setScrollAreaRootContext,
  getScrollAreaRootContext
] = createContext("ScrollArea.Root");
var [
  setScrollAreaScrollbarContext,
  getScrollAreaScrollbarContext
] = createContext("ScrollArea.Scrollbar");
var [
  setScrollAreaScrollbarVisibleContext,
  getScrollAreaScrollbarVisibleContext
] = createContext("ScrollArea.ScrollbarVisible");
var [
  setScrollAreaScrollbarAxisContext,
  getScrollAreaScrollbarAxisContext
] = createContext("ScrollArea.ScrollbarAxis");
var [
  setScrollAreaScrollbarSharedContext,
  getScrollAreaScrollbarSharedContext
] = createContext("ScrollArea.ScrollbarShared");
function useScrollAreaRoot(props) {
  return setScrollAreaRootContext(new ScrollAreaRootState(props));
}
function useScrollAreaViewport(props) {
  return new ScrollAreaViewportState(props, getScrollAreaRootContext());
}
function useScrollAreaScrollbar(props) {
  return setScrollAreaScrollbarContext(new ScrollAreaScrollbarState(props, getScrollAreaRootContext()));
}
function useScrollAreaScrollbarVisible() {
  return setScrollAreaScrollbarVisibleContext(new ScrollAreaScrollbarVisibleState(getScrollAreaScrollbarContext()));
}
function useScrollAreaScrollbarAuto() {
  return new ScrollAreaScrollbarAutoState(getScrollAreaScrollbarContext());
}
function useScrollAreaScrollbarScroll() {
  return new ScrollAreaScrollbarScrollState(getScrollAreaScrollbarContext());
}
function useScrollAreaScrollbarHover() {
  return new ScrollAreaScrollbarHoverState(getScrollAreaScrollbarContext());
}
function useScrollAreaScrollbarX(props) {
  return setScrollAreaScrollbarAxisContext(new ScrollAreaScrollbarXState(props, getScrollAreaScrollbarVisibleContext()));
}
function useScrollAreaScrollbarY(props) {
  return setScrollAreaScrollbarAxisContext(new ScrollAreaScrollbarYState(props, getScrollAreaScrollbarVisibleContext()));
}
function useScrollAreaScrollbarShared() {
  return setScrollAreaScrollbarSharedContext(new ScrollAreaScrollbarSharedState(getScrollAreaScrollbarAxisContext()));
}
function useScrollAreaThumb(props) {
  return new ScrollAreaThumbImplState(props, getScrollAreaScrollbarSharedContext());
}
function useScrollAreaCorner(props) {
  return new ScrollAreaCornerImplState(props, getScrollAreaRootContext());
}
function toInt(value) {
  return value ? Number.parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer({
  pointerPos,
  pointerOffset,
  sizes,
  dir = "ltr"
}) {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = strict_equals(dir, "ltr") ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll({ scrollPos, sizes, dir = "ltr" }) {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = strict_equals(dir, "ltr") ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange[0], scrollClampRange[1]);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (strict_equals(input[0], input[1]) || strict_equals(output[0], output[1])) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function addUnlinkedScrollListener(node, handler) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = strict_equals(prevPosition.left, position.left, false);
    const isVerticalScroll = strict_equals(prevPosition.top, position.top, false);
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte
mark_module_start();
Scroll_area[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte";
var root_290 = add_locations(template(`<div><!></div>`), Scroll_area[FILENAME], [[35, 1]]);
function Scroll_area($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area);
  validate_prop_bindings($$props, ["ref"], [], Scroll_area);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), type = prop($$props, "type", 3, "hover"), dir = prop($$props, "dir", 3, "ltr"), scrollHideDelay = prop($$props, "scrollHideDelay", 3, 600), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "type",
      "dir",
      "scrollHideDelay",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = useScrollAreaRoot({
    type: box.with(() => type()),
    dir: box.with(() => dir()),
    scrollHideDelay: box.with(() => scrollHideDelay()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_290();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area = hmr(Scroll_area, () => Scroll_area[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area[HMR].source;
    set(Scroll_area[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_default = Scroll_area;
mark_module_end(Scroll_area);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte
mark_module_start();
Scroll_area_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte";
var root14 = add_locations(template(`<div><div><!></div></div>`), Scroll_area_viewport[FILENAME], [[26, 0, [[27, 1]]]]);
var $$css2 = {
  hash: "s-fbvr5voIYKY7",
  code: "\r\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */\r\n	[data-scroll-area-viewport] {\r\n		scrollbar-width: none !important;\r\n		-ms-overflow-style: none !important;\r\n		-webkit-overflow-scrolling: touch !important;\r\n	}\r\n	[data-scroll-area-viewport]::-webkit-scrollbar {\r\n		display: none !important;\r\n	}\r\n\r\n	:where([data-scroll-area-viewport]) {\r\n		display: flex;\r\n		flex-direction: column;\r\n		align-items: stretch;\r\n	}\r\n	:where([data-scroll-area-content]) {\r\n		flex-grow: 1;\r\n	}\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLWFyZWEtdmlld3BvcnQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQStCTSIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsic2Nyb2xsLWFyZWEtdmlld3BvcnQuc3ZlbHRlIl19 */"
};
function Scroll_area_viewport($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_viewport);
  append_styles($$anchor, $$css2);
  validate_prop_bindings($$props, ["ref"], [], Scroll_area_viewport);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children"
    ],
    "restProps"
  );
  const viewportState = useScrollAreaViewport({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, viewportState.props));
  const mergedContentProps = derived(() => mergeProps({}, viewportState.contentProps));
  var div = root14();
  let attributes;
  var div_1 = child(div);
  let attributes_1;
  var node = child(div_1);
  snippet(node, () => $$props.children ?? noop);
  reset(div_1);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...get(mergedProps) }, "s-fbvr5voIYKY7");
    attributes_1 = set_attributes(div_1, attributes_1, { ...get(mergedContentProps) }, "s-fbvr5voIYKY7");
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_viewport = hmr(Scroll_area_viewport, () => Scroll_area_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-fbvr5voIYKY7");
    module.default[HMR].source = Scroll_area_viewport[HMR].source;
    set(Scroll_area_viewport[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_viewport_default = Scroll_area_viewport;
mark_module_end(Scroll_area_viewport);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-shared.svelte
mark_module_start();
Scroll_area_scrollbar_shared[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-shared.svelte";
var root_291 = add_locations(template(`<div><!></div>`), Scroll_area_scrollbar_shared[FILENAME], [[16, 1]]);
function Scroll_area_scrollbar_shared($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_shared);
  validate_prop_bindings($$props, [], [], Scroll_area_scrollbar_shared);
  let restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children"
    ],
    "restProps"
  );
  const scrollbarSharedState = useScrollAreaScrollbarShared();
  const mergedProps = derived(() => mergeProps(restProps, scrollbarSharedState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_291();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_shared = hmr(Scroll_area_scrollbar_shared, () => Scroll_area_scrollbar_shared[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_shared[HMR].source;
    set(Scroll_area_scrollbar_shared[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_shared_default = Scroll_area_scrollbar_shared;
mark_module_end(Scroll_area_scrollbar_shared);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte
mark_module_start();
Scroll_area_scrollbar_x[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte";
function Scroll_area_scrollbar_x($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_x);
  validate_prop_bindings($$props, [], [], Scroll_area_scrollbar_x);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const isMounted = new IsMounted();
  const scrollbarXState = useScrollAreaScrollbarX({ mounted: box.with(() => isMounted.current) });
  const mergedProps = derived(() => mergeProps(restProps, scrollbarXState.props));
  var fragment = comment();
  var node = first_child(fragment);
  scroll_area_scrollbar_shared_default(node, spread_props(() => get(mergedProps)));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_x = hmr(Scroll_area_scrollbar_x, () => Scroll_area_scrollbar_x[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_x[HMR].source;
    set(Scroll_area_scrollbar_x[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_x_default = Scroll_area_scrollbar_x;
mark_module_end(Scroll_area_scrollbar_x);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte
mark_module_start();
Scroll_area_scrollbar_y[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte";
function Scroll_area_scrollbar_y($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_y);
  validate_prop_bindings($$props, [], [], Scroll_area_scrollbar_y);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const isMounted = new IsMounted();
  const scrollbarYState = useScrollAreaScrollbarY({ mounted: box.with(() => isMounted.current) });
  const mergedProps = derived(() => mergeProps(restProps, scrollbarYState.props));
  var fragment = comment();
  var node = first_child(fragment);
  scroll_area_scrollbar_shared_default(node, spread_props(() => get(mergedProps)));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_y = hmr(Scroll_area_scrollbar_y, () => Scroll_area_scrollbar_y[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_y[HMR].source;
    set(Scroll_area_scrollbar_y[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_y_default = Scroll_area_scrollbar_y;
mark_module_end(Scroll_area_scrollbar_y);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-visible.svelte
mark_module_start();
Scroll_area_scrollbar_visible[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-visible.svelte";
function Scroll_area_scrollbar_visible($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_visible);
  validate_prop_bindings($$props, [], [], Scroll_area_scrollbar_visible);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const scrollbarVisibleState = useScrollAreaScrollbarVisible();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => strict_equals(scrollbarVisibleState.scrollbar.orientation.current, "horizontal"),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_x_default(node_1, spread_props(() => restProps));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      scroll_area_scrollbar_y_default(node_2, spread_props(() => restProps));
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_visible = hmr(Scroll_area_scrollbar_visible, () => Scroll_area_scrollbar_visible[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_visible[HMR].source;
    set(Scroll_area_scrollbar_visible[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_visible_default = Scroll_area_scrollbar_visible;
mark_module_end(Scroll_area_scrollbar_visible);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-auto.svelte
mark_module_start();
Scroll_area_scrollbar_auto[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-auto.svelte";
function Scroll_area_scrollbar_auto($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_auto);
  validate_prop_bindings($$props, [], [], Scroll_area_scrollbar_auto);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarAutoState = useScrollAreaScrollbarAuto();
  const mergedProps = derived(() => mergeProps(restProps, scrollbarAutoState.props));
  var fragment = comment();
  var node = first_child(fragment);
  var present = derived(() => forceMount() || scrollbarAutoState.isVisible);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_auto, ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps)));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(
      {
        get present() {
          return get(present);
        }
      },
      () => get(mergedProps),
      { presence, $$slots: { presence: true } }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_auto = hmr(Scroll_area_scrollbar_auto, () => Scroll_area_scrollbar_auto[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_auto[HMR].source;
    set(Scroll_area_scrollbar_auto[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_auto_default = Scroll_area_scrollbar_auto;
mark_module_end(Scroll_area_scrollbar_auto);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-scroll.svelte
mark_module_start();
Scroll_area_scrollbar_scroll[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-scroll.svelte";
function Scroll_area_scrollbar_scroll($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_scroll);
  validate_prop_bindings($$props, [], [], Scroll_area_scrollbar_scroll);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarScrollState = useScrollAreaScrollbarScroll();
  const mergedProps = derived(() => mergeProps(restProps, scrollbarScrollState.props));
  var fragment = comment();
  var node = first_child(fragment);
  var present = derived(() => forceMount() || !scrollbarScrollState.isHidden);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_scroll, ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps)));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(() => get(mergedProps), {
      get present() {
        return get(present);
      },
      presence,
      $$slots: { presence: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_scroll = hmr(Scroll_area_scrollbar_scroll, () => Scroll_area_scrollbar_scroll[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_scroll[HMR].source;
    set(Scroll_area_scrollbar_scroll[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_scroll_default = Scroll_area_scrollbar_scroll;
mark_module_end(Scroll_area_scrollbar_scroll);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-hover.svelte
mark_module_start();
Scroll_area_scrollbar_hover[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-hover.svelte";
function Scroll_area_scrollbar_hover($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_hover);
  validate_prop_bindings($$props, [], [], Scroll_area_scrollbar_hover);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarHoverState = useScrollAreaScrollbarHover();
  const scrollbarAutoState = useScrollAreaScrollbarAuto();
  const mergedProps = derived(() => mergeProps(restProps, scrollbarHoverState.props, scrollbarAutoState.props, {
    "data-state": scrollbarHoverState.isVisible ? "visible" : "hidden"
  }));
  const present = derived(() => forceMount() || scrollbarHoverState.isVisible && scrollbarAutoState.isVisible);
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_hover, ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps)));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(() => get(mergedProps), {
      get present() {
        return get(present);
      },
      presence,
      $$slots: { presence: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_hover = hmr(Scroll_area_scrollbar_hover, () => Scroll_area_scrollbar_hover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_hover[HMR].source;
    set(Scroll_area_scrollbar_hover[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_hover_default = Scroll_area_scrollbar_hover;
mark_module_end(Scroll_area_scrollbar_hover);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte
mark_module_start();
Scroll_area_scrollbar[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte";
function Scroll_area_scrollbar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar);
  validate_prop_bindings($$props, ["ref"], [], Scroll_area_scrollbar);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation"
    ],
    "restProps"
  );
  const scrollbarState = useScrollAreaScrollbar({
    orientation: box.with(() => $$props.orientation),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const type = derived(() => scrollbarState.root.type.current);
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => strict_equals(get(type), "hover"),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_hover_default(node_1, spread_props(() => restProps, {
        get id() {
          return id();
        }
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      if_block(
        node_2,
        () => strict_equals(get(type), "scroll"),
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          scroll_area_scrollbar_scroll_default(node_3, spread_props(() => restProps, {
            get id() {
              return id();
            }
          }));
          append($$anchor3, fragment_3);
        },
        ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          if_block(
            node_4,
            () => strict_equals(get(type), "auto"),
            ($$anchor4) => {
              var fragment_5 = comment();
              var node_5 = first_child(fragment_5);
              scroll_area_scrollbar_auto_default(node_5, spread_props(() => restProps, {
                get id() {
                  return id();
                }
              }));
              append($$anchor4, fragment_5);
            },
            ($$anchor4) => {
              var fragment_6 = comment();
              var node_6 = first_child(fragment_6);
              if_block(
                node_6,
                () => strict_equals(get(type), "always"),
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_7 = first_child(fragment_7);
                  scroll_area_scrollbar_visible_default(node_7, spread_props(() => restProps, {
                    get id() {
                      return id();
                    }
                  }));
                  append($$anchor5, fragment_7);
                },
                null,
                true
              );
              append($$anchor4, fragment_6);
            },
            true
          );
          append($$anchor3, fragment_4);
        },
        true
      );
      append($$anchor2, fragment_2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar = hmr(Scroll_area_scrollbar, () => Scroll_area_scrollbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar[HMR].source;
    set(Scroll_area_scrollbar[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_default = Scroll_area_scrollbar;
mark_module_end(Scroll_area_scrollbar);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-impl.svelte
mark_module_start();
Scroll_area_thumb_impl[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-impl.svelte";
var root_292 = add_locations(template(`<div><!></div>`), Scroll_area_thumb_impl[FILENAME], [[42, 1]]);
function Scroll_area_thumb_impl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_thumb_impl);
  validate_prop_bindings($$props, ["ref"], [], Scroll_area_thumb_impl);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children",
      "present"
    ],
    "restProps"
  );
  const isMounted = new IsMounted();
  const thumbState = useScrollAreaThumb({
    id: box.with(() => $$props.id),
    ref: box.with(() => ref(), (v) => ref(v)),
    mounted: box.with(() => isMounted.current)
  });
  const mergedProps = derived(() => mergeProps(restProps, thumbState.props, { style: { hidden: !$$props.present } }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_292();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_thumb_impl = hmr(Scroll_area_thumb_impl, () => Scroll_area_thumb_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_thumb_impl[HMR].source;
    set(Scroll_area_thumb_impl[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_thumb_impl_default = Scroll_area_thumb_impl;
mark_module_end(Scroll_area_thumb_impl);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte
mark_module_start();
Scroll_area_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte";
function Scroll_area_thumb($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_thumb);
  validate_prop_bindings($$props, ["ref"], [], Scroll_area_thumb);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarState = getScrollAreaScrollbarVisibleContext();
  var fragment = comment();
  var node = first_child(fragment);
  var present_1 = derived(() => forceMount() || scrollbarState.hasThumb);
  {
    const presence = wrap_snippet(Scroll_area_thumb, ($$anchor2, $$arg0) => {
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        add_owner_effect(ref, scroll_area_thumb_impl_default);
        scroll_area_thumb_impl_default(node_1, spread_props(() => restProps, {
          get id() {
            return id();
          },
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          },
          get present() {
            return present().current;
          }
        }));
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(
      {
        get present() {
          return get(present_1);
        }
      },
      () => restProps,
      {
        get id() {
          return id();
        },
        presence,
        $$slots: { presence: true }
      }
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_thumb = hmr(Scroll_area_thumb, () => Scroll_area_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_thumb[HMR].source;
    set(Scroll_area_thumb[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_thumb_default = Scroll_area_thumb;
mark_module_end(Scroll_area_thumb);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner-impl.svelte
mark_module_start();
Scroll_area_corner_impl[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner-impl.svelte";
var root_293 = add_locations(template(`<div><!></div>`), Scroll_area_corner_impl[FILENAME], [[30, 1]]);
function Scroll_area_corner_impl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_corner_impl);
  validate_prop_bindings($$props, ["ref"], [], Scroll_area_corner_impl);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children",
      "child"
    ],
    "restProps"
  );
  const cornerState = useScrollAreaCorner({
    id: box.with(() => $$props.id),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, cornerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_293();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_corner_impl = hmr(Scroll_area_corner_impl, () => Scroll_area_corner_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_corner_impl[HMR].source;
    set(Scroll_area_corner_impl[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_corner_impl_default = Scroll_area_corner_impl;
mark_module_end(Scroll_area_corner_impl);

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte
mark_module_start();
Scroll_area_corner[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte";
function Scroll_area_corner($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_corner);
  validate_prop_bindings($$props, ["ref"], [], Scroll_area_corner);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id"
    ],
    "restProps"
  );
  const scrollAreaState = getScrollAreaRootContext();
  const hasBothScrollbarsVisible = derived(() => Boolean(scrollAreaState.scrollbarXNode && scrollAreaState.scrollbarYNode));
  const hasCorner = derived(() => strict_equals(scrollAreaState.type.current, "scroll", false) && get(hasBothScrollbarsVisible));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => get(hasCorner), ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    {
      add_owner_effect(ref, scroll_area_corner_impl_default);
      scroll_area_corner_impl_default(node_1, spread_props(() => restProps, {
        get id() {
          return id();
        },
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      }));
    }
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_corner = hmr(Scroll_area_corner, () => Scroll_area_corner[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_corner[HMR].source;
    set(Scroll_area_corner[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_corner_default = Scroll_area_corner;
mark_module_end(Scroll_area_corner);

// node_modules/bits-ui/dist/bits/select/exports.js
var exports_exports29 = {};
__export(exports_exports29, {
  Content: () => select_content_default,
  ContentStatic: () => select_content_static_default,
  Group: () => select_group_default,
  GroupHeading: () => select_group_heading_default,
  Item: () => select_item_default,
  Portal: () => portal_default,
  Root: () => select_default,
  ScrollDownButton: () => select_scroll_down_button_default,
  ScrollUpButton: () => select_scroll_up_button_default,
  Trigger: () => select_trigger_default,
  Viewport: () => select_viewport_default
});

// node_modules/bits-ui/dist/bits/select/components/select.svelte
mark_module_start();
Select[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select.svelte";
var root15 = add_locations(template(`<!> <!>`, 1), Select[FILENAME], []);
function Select($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select);
  validate_prop_bindings($$props, ["value", "open"], [], Select);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), controlledOpen = prop($$props, "controlledOpen", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, true);
  if (strict_equals(value(), void 0)) {
    const defaultValue = strict_equals($$props.type, "single") ? "" : [];
    if (controlledValue()) {
      onValueChange()(defaultValue);
    } else {
      value(defaultValue);
    }
  }
  const rootState = useSelectRoot({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    disabled: box.with(() => disabled()),
    required: box.with(() => required()),
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    }),
    loop: box.with(() => loop()),
    scrollAlignment: box.with(() => scrollAlignment()),
    name: box.with(() => name()),
    isCombobox: false,
    items: box.with(() => items()),
    allowDeselect: box.with(() => allowDeselect())
  });
  var fragment = root15();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Select, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  if_block(
    node_2,
    () => Array.isArray(rootState.value.current),
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      if_block(node_3, () => rootState.value.current.length, ($$anchor3) => {
        var fragment_3 = comment();
        var node_4 = first_child(fragment_3);
        each(node_4, 17, () => rootState.value.current, index, ($$anchor4, item) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          select_hidden_input_default(node_5, {
            get value() {
              return get(item);
            }
          });
          append($$anchor4, fragment_4);
        });
        append($$anchor3, fragment_3);
      });
      append($$anchor2, fragment_2);
    },
    ($$anchor2) => {
      var fragment_5 = comment();
      var node_6 = first_child(fragment_5);
      validate_binding("bind:value={rootState.value.current as string}", () => rootState.value, () => "current", 82, 20);
      {
        add_owner_effect(() => rootState.value.current, select_hidden_input_default);
        select_hidden_input_default(node_6, {
          get value() {
            return rootState.value.current;
          },
          set value($$value) {
            rootState.value.current = $$value;
          }
        });
      }
      append($$anchor2, fragment_5);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select = hmr(Select, () => Select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select[HMR].source;
    set(Select[HMR].source, module.default[HMR].original);
  });
}
var select_default = Select;
mark_module_end(Select);

// node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte
mark_module_start();
Select_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte";
var root_319 = add_locations(template(`<button><!></button>`), Select_trigger[FILENAME], [[32, 2]]);
function Select_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_trigger);
  validate_prop_bindings($$props, ["ref"], [], Select_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const triggerState = useSelectTrigger({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      children: wrap_snippet(Select_trigger, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        if_block(
          node_1,
          () => $$props.child,
          ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          },
          ($$anchor4) => {
            var button = root_319();
            let attributes;
            var node_3 = child(button);
            snippet(node_3, () => $$props.children ?? noop);
            reset(button);
            template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
            append($$anchor4, button);
          }
        );
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_trigger = hmr(Select_trigger, () => Select_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_trigger[HMR].source;
    set(Select_trigger[HMR].source, module.default[HMR].original);
  });
}
var select_trigger_default = Select_trigger;
mark_module_end(Select_trigger);

// node_modules/bits-ui/dist/bits/separator/exports.js
var exports_exports30 = {};
__export(exports_exports30, {
  Root: () => separator_default
});

// node_modules/bits-ui/dist/bits/slider/exports.js
var exports_exports31 = {};
__export(exports_exports31, {
  Range: () => slider_range_default,
  Root: () => slider_default,
  Thumb: () => slider_thumb_default,
  Tick: () => slider_tick_default
});

// node_modules/bits-ui/dist/bits/slider/helpers.js
function getRangeStyles(direction, min, max) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${min}%`;
    styles.right = `${max}%`;
  } else if (direction === "rl") {
    styles.right = `${min}%`;
    styles.left = `${max}%`;
  } else if (direction === "bt") {
    styles.bottom = `${min}%`;
    styles.top = `${max}%`;
  } else {
    styles.top = `${min}%`;
    styles.bottom = `${max}%`;
  }
  return styles;
}
function getThumbStyles(direction, thumbPos) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${thumbPos}%`;
    styles.translate = "-50% 0";
  } else if (direction === "rl") {
    styles.right = `${thumbPos}%`;
    styles.translate = "50% 0";
  } else if (direction === "bt") {
    styles.bottom = `${thumbPos}%`;
    styles.translate = "0 50%";
  } else {
    styles.top = `${thumbPos}%`;
    styles.translate = "0 -50%";
  }
  return styles;
}
function getTickStyles(direction, tickPosition, offsetPercentage) {
  const style = {
    position: "absolute"
  };
  if (direction === "lr") {
    style.left = `${tickPosition}%`;
    style.translate = `${offsetPercentage}% 0`;
  } else if (direction === "rl") {
    style.right = `${tickPosition}%`;
    style.translate = `${-offsetPercentage}% 0`;
  } else if (direction === "bt") {
    style.bottom = `${tickPosition}%`;
    style.translate = `0 ${-offsetPercentage}%`;
  } else {
    style.top = `${tickPosition}%`;
    style.translate = `0 ${offsetPercentage}%`;
  }
  return style;
}

// node_modules/bits-ui/dist/internal/math.js
function snapValueToStep(value, min, max, step) {
  const remainder = (value - (Number.isNaN(min) ? 0 : min)) % step;
  let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;
  if (!Number.isNaN(min)) {
    if (snappedValue < min) {
      snappedValue = min;
    } else if (!Number.isNaN(max) && snappedValue > max) {
      snappedValue = min + Math.floor((max - min) / step) * step;
    }
  } else if (!Number.isNaN(max) && snappedValue > max) {
    snappedValue = Math.floor(max / step) * step;
  }
  const string = step.toString();
  const index2 = string.indexOf(".");
  const precision = index2 >= 0 ? string.length - index2 : 0;
  if (precision > 0) {
    const pow = 10 ** precision;
    snappedValue = Math.round(snappedValue * pow) / pow;
  }
  return snappedValue;
}

// node_modules/bits-ui/dist/bits/slider/slider.svelte.js
var SLIDER_ROOT_ATTR = "data-slider-root";
var SLIDER_THUMB_ATTR = "data-slider-thumb";
var SLIDER_RANGE_ATTR = "data-slider-range";
var SLIDER_TICK_ATTR = "data-slider-tick";
var _activeThumb, _isActive2, _currentThumbIdx, _direction, _thumbsPropsArr, _thumbsRenderArr, _ticksPropsArr, _ticksRenderArr, _snippetProps20, _touchAction, _props128;
var SliderRootState = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "value");
    __publicField(this, "disabled");
    __publicField(this, "orientation");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "step");
    __publicField(this, "dir");
    __publicField(this, "autoSort");
    __privateAdd(this, _activeThumb, state(null));
    __privateAdd(this, _isActive2, state(false));
    __privateAdd(this, _currentThumbIdx, state(0));
    __privateAdd(this, _direction, derived(() => {
      if (strict_equals(this.orientation.current, "horizontal")) {
        return strict_equals(this.dir.current, "rtl") ? "rl" : "lr";
      } else {
        return strict_equals(this.dir.current, "rtl") ? "tb" : "bt";
      }
    }));
    __publicField(this, "onValueCommit");
    __publicField(this, "applyPosition", ({ clientXY, activeThumbIdx, start, end }) => {
      const min = this.min.current;
      const max = this.max.current;
      const percent = (clientXY - start) / (end - start);
      const val = percent * (max - min) + min;
      if (val < min) {
        this.updateValue(min, activeThumbIdx);
      } else if (val > max) {
        this.updateValue(max, activeThumbIdx);
      } else {
        const step = this.step.current;
        const currStep = Math.floor((val - min) / step);
        const midpointOfCurrStep = min + currStep * step + step / 2;
        const midpointOfNextStep = min + (currStep + 1) * step + step / 2;
        const newValue = val >= midpointOfCurrStep && val < midpointOfNextStep ? (currStep + 1) * step + min : currStep * step + min;
        if (newValue <= max) {
          this.updateValue(newValue, activeThumbIdx);
        }
      }
    });
    __publicField(this, "getClosestThumb", (e) => {
      const thumbs = this.getAllThumbs();
      if (!thumbs.length) return;
      for (const thumb of thumbs) {
        thumb.blur();
      }
      const distances = thumbs.map((thumb) => {
        if (strict_equals(this.orientation.current, "horizontal")) {
          const { left, right } = thumb.getBoundingClientRect();
          return Math.abs(e.clientX - (left + right) / 2);
        } else {
          const { top, bottom } = thumb.getBoundingClientRect();
          return Math.abs(e.clientY - (top + bottom) / 2);
        }
      });
      const node = thumbs[distances.indexOf(Math.min(...distances))];
      const idx = thumbs.indexOf(node);
      return { node, idx };
    });
    __publicField(this, "handlePointerMove", (e) => {
      if (!this.isActive || this.disabled.current) return;
      e.preventDefault();
      e.stopPropagation();
      const sliderNode = this.ref.current;
      const activeThumb = this.activeThumb;
      if (!sliderNode || !activeThumb) return;
      activeThumb.node.focus();
      const { left, right, top, bottom } = sliderNode.getBoundingClientRect();
      const direction = this.direction;
      if (strict_equals(direction, "lr")) {
        this.applyPosition({
          clientXY: e.clientX,
          activeThumbIdx: activeThumb.idx,
          start: left,
          end: right
        });
      } else if (strict_equals(direction, "rl")) {
        this.applyPosition({
          clientXY: e.clientX,
          activeThumbIdx: activeThumb.idx,
          start: right,
          end: left
        });
      } else if (strict_equals(direction, "bt")) {
        this.applyPosition({
          clientXY: e.clientY,
          activeThumbIdx: activeThumb.idx,
          start: bottom,
          end: top
        });
      } else if (strict_equals(direction, "tb")) {
        this.applyPosition({
          clientXY: e.clientY,
          activeThumbIdx: activeThumb.idx,
          start: top,
          end: bottom
        });
      }
    });
    __publicField(this, "handlePointerDown", (e) => {
      if (strict_equals(e.button, 0, false) || this.disabled.current) return;
      const sliderNode = this.ref.current;
      const closestThumb = this.getClosestThumb(e);
      if (!closestThumb || !sliderNode) return;
      const target = e.target;
      if (!isElementOrSVGElement(target) || !sliderNode.contains(target)) return;
      e.preventDefault();
      this.activeThumb = closestThumb;
      closestThumb.node.focus();
      this.isActive = true;
      this.handlePointerMove(e);
    });
    __publicField(this, "handlePointerUp", () => {
      if (this.disabled.current) return;
      if (this.isActive) {
        this.onValueCommit.current(untrack(() => this.value.current));
      }
      this.isActive = false;
    });
    __publicField(this, "getPositionFromValue", (thumbValue) => {
      const min = this.min.current;
      const max = this.max.current;
      return (thumbValue - min) / (max - min) * 100;
    });
    __publicField(this, "getAllThumbs", () => {
      const node = this.ref.current;
      if (!node) return [];
      const thumbs = Array.from(node.querySelectorAll(`[${SLIDER_THUMB_ATTR}]`));
      return thumbs;
    });
    __publicField(this, "updateValue", (thumbValue, idx) => {
      const currValue = this.value.current;
      if (!currValue.length) {
        this.value.current.push(thumbValue);
        return;
      }
      const valueAtIndex = currValue[idx];
      if (strict_equals(valueAtIndex, thumbValue)) return;
      const newValue = [...currValue];
      if (!isValidIndex(idx, newValue)) return;
      const direction = newValue[idx] > thumbValue ? -1 : 1;
      const swap = () => {
        var _a;
        const diffIndex = idx + direction;
        newValue[idx] = newValue[diffIndex];
        newValue[diffIndex] = thumbValue;
        const thumbs = this.getAllThumbs();
        if (!thumbs.length) return;
        (_a = thumbs[diffIndex]) == null ? void 0 : _a.focus();
        this.activeThumb = { node: thumbs[diffIndex], idx: diffIndex };
      };
      if (this.autoSort.current && (strict_equals(direction, -1) && thumbValue < newValue[idx - 1] || strict_equals(direction, 1) && thumbValue > newValue[idx + 1])) {
        swap();
        this.value.current = newValue;
        return;
      }
      const min = this.min.current;
      const max = this.max.current;
      const step = this.step.current;
      newValue[idx] = snapValueToStep(thumbValue, min, max, step);
      this.value.current = newValue;
    });
    __privateAdd(this, _thumbsPropsArr, derived(() => {
      const currValue = this.value.current;
      return Array.from({ length: currValue.length || 1 }, (_, i) => {
        const currThumb = untrack(() => this.currentThumbIdx);
        if (currThumb < currValue.length) {
          untrack(() => {
            this.currentThumbIdx = currThumb + 1;
          });
        }
        const thumbValue = currValue[i];
        const thumbPosition = this.getPositionFromValue(thumbValue ?? 0);
        const style = getThumbStyles(this.direction, thumbPosition);
        return {
          role: "slider",
          "aria-valuemin": this.min.current,
          "aria-valuemax": this.max.current,
          "aria-valuenow": thumbValue,
          "aria-disabled": getAriaDisabled(this.disabled.current),
          "aria-orientation": getAriaOrientation(this.orientation.current),
          "data-value": thumbValue,
          tabindex: this.disabled.current ? -1 : 0,
          style,
          [SLIDER_THUMB_ATTR]: ""
        };
      });
    }));
    __privateAdd(this, _thumbsRenderArr, derived(() => {
      return this.thumbsPropsArr.map((_, i) => i);
    }));
    __privateAdd(this, _ticksPropsArr, derived(() => {
      const max = this.max.current;
      const min = this.min.current;
      const step = this.step.current;
      const difference = max - min;
      let count2 = Math.ceil(difference / step);
      if (equals(difference % step, 0)) {
        count2 += 1;
      }
      const currValue = this.value.current;
      return Array.from({ length: count2 }, (_, i) => {
        const tickPosition = i * (step / difference) * 100;
        const isFirst = strict_equals(i, 0);
        const isLast = strict_equals(i, count2 - 1);
        const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
        const style = getTickStyles(this.direction, tickPosition, offsetPercentage);
        const tickValue = min + i * step;
        const bounded = strict_equals(currValue.length, 1) ? tickValue <= currValue[0] : currValue[0] <= tickValue && tickValue <= currValue[currValue.length - 1];
        return {
          "data-disabled": getDataDisabled(this.disabled.current),
          "data-orientation": getDataOrientation(this.orientation.current),
          "data-bounded": bounded ? "" : void 0,
          "data-value": tickValue,
          style,
          [SLIDER_TICK_ATTR]: ""
        };
      });
    }));
    __privateAdd(this, _ticksRenderArr, derived(() => {
      return this.ticksPropsArr.map((_, i) => i);
    }));
    __privateAdd(this, _snippetProps20, derived(() => ({
      ticks: this.ticksRenderArr,
      thumbs: this.thumbsRenderArr
    })));
    __privateAdd(this, _touchAction, derived(() => {
      if (this.disabled.current) return void 0;
      return strict_equals(this.orientation.current, "horizontal") ? "pan-y" : "pan-x";
    }));
    __privateAdd(this, _props128, derived(() => ({
      id: this.id.current,
      "data-orientation": getDataOrientation(this.orientation.current),
      "data-disabled": getDataDisabled(this.disabled.current),
      style: { touchAction: get(__privateGet(this, _touchAction)) },
      [SLIDER_ROOT_ATTR]: ""
    })));
    this.id = props.id;
    this.ref = props.ref;
    this.disabled = props.disabled;
    this.orientation = props.orientation;
    this.min = props.min;
    this.max = props.max;
    this.step = props.step;
    this.dir = props.dir;
    this.autoSort = props.autoSort;
    this.value = props.value;
    this.onValueCommit = props.onValueCommit;
    useRefById({ id: this.id, ref: this.ref });
    user_effect(() => {
      const unsub = executeCallbacks(addEventListener2(document, "pointerdown", this.handlePointerDown), addEventListener2(document, "pointerup", this.handlePointerUp), addEventListener2(document, "pointermove", this.handlePointerMove), addEventListener2(document, "pointerleave", this.handlePointerUp));
      return unsub;
    });
    user_effect(() => {
      const step = this.step.current;
      const min = this.min.current;
      const max = this.max.current;
      const value = this.value.current;
      const isValidValue = (v) => {
        const snappedValue = snapValueToStep(v, min, max, step);
        return strict_equals(snappedValue, v);
      };
      const gcv = (v) => {
        return snapValueToStep(v, min, max, step);
      };
      if (value.some((v) => !isValidValue(v))) {
        this.value.current = value.map(gcv);
      }
    });
  }
  get activeThumb() {
    return get(__privateGet(this, _activeThumb));
  }
  set activeThumb(value) {
    set(__privateGet(this, _activeThumb), proxy(value, null, __privateGet(this, _activeThumb)));
  }
  get isActive() {
    return get(__privateGet(this, _isActive2));
  }
  set isActive(value) {
    set(__privateGet(this, _isActive2), proxy(value, null, __privateGet(this, _isActive2)));
  }
  get currentThumbIdx() {
    return get(__privateGet(this, _currentThumbIdx));
  }
  set currentThumbIdx(value) {
    set(__privateGet(this, _currentThumbIdx), proxy(value, null, __privateGet(this, _currentThumbIdx)));
  }
  get direction() {
    return get(__privateGet(this, _direction));
  }
  set direction(_) {
    throw new Error("Cannot update a derived property ('direction')");
  }
  get thumbsPropsArr() {
    return get(__privateGet(this, _thumbsPropsArr));
  }
  set thumbsPropsArr(_) {
    throw new Error("Cannot update a derived property ('thumbsPropsArr')");
  }
  get thumbsRenderArr() {
    return get(__privateGet(this, _thumbsRenderArr));
  }
  set thumbsRenderArr(_) {
    throw new Error("Cannot update a derived property ('thumbsRenderArr')");
  }
  get ticksPropsArr() {
    return get(__privateGet(this, _ticksPropsArr));
  }
  set ticksPropsArr(_) {
    throw new Error("Cannot update a derived property ('ticksPropsArr')");
  }
  get ticksRenderArr() {
    return get(__privateGet(this, _ticksRenderArr));
  }
  set ticksRenderArr(_) {
    throw new Error("Cannot update a derived property ('ticksRenderArr')");
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps20));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props128));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _activeThumb)), owner, false);
    add_owner(get(__privateGet(this, _isActive2)), owner, false);
    add_owner(get(__privateGet(this, _currentThumbIdx)), owner, false);
    add_owner(get(__privateGet(this, _direction)), owner, false);
    add_owner(get(__privateGet(this, _thumbsPropsArr)), owner, false);
    add_owner(get(__privateGet(this, _thumbsRenderArr)), owner, false);
    add_owner(get(__privateGet(this, _ticksPropsArr)), owner, false);
    add_owner(get(__privateGet(this, _ticksRenderArr)), owner, false);
    add_owner(get(__privateGet(this, _snippetProps20)), owner, false);
    add_owner(get(__privateGet(this, _props128)), owner, false);
  }
};
_activeThumb = new WeakMap();
_isActive2 = new WeakMap();
_currentThumbIdx = new WeakMap();
_direction = new WeakMap();
_thumbsPropsArr = new WeakMap();
_thumbsRenderArr = new WeakMap();
_ticksPropsArr = new WeakMap();
_ticksRenderArr = new WeakMap();
_snippetProps20 = new WeakMap();
_touchAction = new WeakMap();
_props128 = new WeakMap();
var VALID_SLIDER_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.HOME,
  kbd_constants_exports.END
];
var _id82, _ref82, _root39, _rangeStyles, _props129;
var SliderRangeState = class {
  constructor(props, root17) {
    __privateAdd(this, _id82);
    __privateAdd(this, _ref82);
    __privateAdd(this, _root39);
    __privateAdd(this, _rangeStyles, derived(() => {
      const value = __privateGet(this, _root39).value.current;
      const min = value.length > 1 ? __privateGet(this, _root39).getPositionFromValue(Math.min(...value) ?? 0) : 0;
      const max = 100 - __privateGet(this, _root39).getPositionFromValue(Math.max(...value) ?? 0);
      return {
        position: "absolute",
        ...getRangeStyles(__privateGet(this, _root39).direction, min, max)
      };
    }));
    __privateAdd(this, _props129, derived(() => ({
      id: __privateGet(this, _id82).current,
      "data-orientation": getDataOrientation(__privateGet(this, _root39).orientation.current),
      "data-disabled": getDataDisabled(__privateGet(this, _root39).disabled.current),
      style: this.rangeStyles,
      [SLIDER_RANGE_ATTR]: ""
    })));
    __privateSet(this, _id82, props.id);
    __privateSet(this, _ref82, props.ref);
    __privateSet(this, _root39, root17);
    useRefById({ id: __privateGet(this, _id82), ref: __privateGet(this, _ref82) });
  }
  get rangeStyles() {
    return get(__privateGet(this, _rangeStyles));
  }
  set rangeStyles(_) {
    throw new Error("Cannot update a derived property ('rangeStyles')");
  }
  get props() {
    return get(__privateGet(this, _props129));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _rangeStyles)), owner, false);
    add_owner(get(__privateGet(this, _props129)), owner, false);
  }
};
_id82 = new WeakMap();
_ref82 = new WeakMap();
_root39 = new WeakMap();
_rangeStyles = new WeakMap();
_props129 = new WeakMap();
var _id83, _ref83, _index, _root40, _isDisabled10, _onkeydown37, _props130;
var SliderThumbState = class {
  constructor(props, root17) {
    __privateAdd(this, _id83);
    __privateAdd(this, _ref83);
    __privateAdd(this, _index);
    __privateAdd(this, _root40);
    __privateAdd(this, _isDisabled10, derived(() => __privateGet(this, _root40).disabled.current || __privateGet(this, _root40).disabled.current));
    __publicField(this, "updateValue", (newValue) => {
      __privateGet(this, _root40).updateValue(newValue, __privateGet(this, _index).current);
    });
    __publicField(this, "moveValue", (thumbValue, increment) => {
      const newValue = thumbValue + increment;
      if (newValue >= __privateGet(this, _root40).min.current && newValue <= __privateGet(this, _root40).max.current) {
        this.updateValue(newValue);
      }
    });
    __publicField(this, "handleArrowKey", (thumbValue, isPositiveDirection, isHorizontal, e) => {
      const orientation = __privateGet(this, _root40).orientation.current;
      const direction = __privateGet(this, _root40).direction;
      if (isHorizontal && strict_equals(orientation, "horizontal", false) || !isHorizontal && strict_equals(orientation, "horizontal")) return;
      const isForwardDirection = isHorizontal && strict_equals(direction, "lr") || !isHorizontal && strict_equals(direction, "bt");
      if (e.metaKey) {
        const max = __privateGet(this, _root40).max.current;
        const min = __privateGet(this, _root40).min.current;
        this.updateValue(strict_equals(isForwardDirection, isPositiveDirection) ? max : min);
      } else {
        const step = __privateGet(this, _root40).step.current;
        this.moveValue(thumbValue, strict_equals(isForwardDirection, isPositiveDirection) ? step : -step);
      }
    });
    __privateAdd(this, _onkeydown37, (e) => {
      if (get(__privateGet(this, _isDisabled10))) return;
      const currNode = __privateGet(this, _ref83).current;
      if (!currNode) return;
      const thumbs = __privateGet(this, _root40).getAllThumbs();
      if (!thumbs.length) return;
      const idx = thumbs.indexOf(currNode);
      __privateGet(this, _root40).currentThumbIdx = idx;
      if (!VALID_SLIDER_KEYS.includes(e.key)) return;
      e.preventDefault();
      const min = __privateGet(this, _root40).min.current;
      const max = __privateGet(this, _root40).max.current;
      const value = __privateGet(this, _root40).value.current;
      const thumbValue = value[idx];
      const orientation = __privateGet(this, _root40).orientation.current;
      const direction = __privateGet(this, _root40).direction;
      const step = __privateGet(this, _root40).step.current;
      switch (e.key) {
        case kbd_constants_exports.HOME:
          this.updateValue(min);
          break;
        case kbd_constants_exports.END:
          this.updateValue(max);
          break;
        case kbd_constants_exports.ARROW_LEFT:
          if (strict_equals(orientation, "horizontal", false)) break;
          if (e.metaKey) {
            const newValue = strict_equals(direction, "rl") ? max : min;
            this.updateValue(newValue);
          } else if (strict_equals(direction, "rl") && thumbValue < max) {
            this.updateValue(thumbValue + step);
          } else if (strict_equals(direction, "lr") && thumbValue > min) {
            this.updateValue(thumbValue - step);
          }
          break;
        case kbd_constants_exports.ARROW_RIGHT:
          if (strict_equals(orientation, "horizontal", false)) break;
          if (e.metaKey) {
            const newValue = strict_equals(direction, "rl") ? min : max;
            this.updateValue(newValue);
          } else if (strict_equals(direction, "rl") && thumbValue > min) {
            this.updateValue(thumbValue - step);
          } else if (strict_equals(direction, "lr") && thumbValue < max) {
            this.updateValue(thumbValue + step);
          }
          break;
        case kbd_constants_exports.ARROW_UP:
          if (e.metaKey) {
            const newValue = strict_equals(direction, "tb") ? min : max;
            this.updateValue(newValue);
          } else if (strict_equals(direction, "tb") && thumbValue > min) {
            this.updateValue(thumbValue - step);
          } else if (strict_equals(direction, "tb", false) && thumbValue < max) {
            this.updateValue(thumbValue + step);
          }
          break;
        case kbd_constants_exports.ARROW_DOWN:
          if (e.metaKey) {
            const newValue = strict_equals(direction, "tb") ? max : min;
            this.updateValue(newValue);
          } else if (strict_equals(direction, "tb") && thumbValue < max) {
            this.updateValue(thumbValue + step);
          } else if (strict_equals(direction, "tb", false) && thumbValue > min) {
            this.updateValue(thumbValue - step);
          }
          break;
      }
      __privateGet(this, _root40).onValueCommit.current(__privateGet(this, _root40).value.current);
    });
    __privateAdd(this, _props130, derived(() => ({
      ...__privateGet(this, _root40).thumbsPropsArr[__privateGet(this, _index).current],
      id: __privateGet(this, _id83).current,
      onkeydown: __privateGet(this, _onkeydown37)
    })));
    __privateSet(this, _id83, props.id);
    __privateSet(this, _ref83, props.ref);
    __privateSet(this, _root40, root17);
    __privateSet(this, _index, props.index);
    useRefById({ id: __privateGet(this, _id83), ref: __privateGet(this, _ref83) });
  }
  get props() {
    return get(__privateGet(this, _props130));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props130)), owner, false);
  }
};
_id83 = new WeakMap();
_ref83 = new WeakMap();
_index = new WeakMap();
_root40 = new WeakMap();
_isDisabled10 = new WeakMap();
_onkeydown37 = new WeakMap();
_props130 = new WeakMap();
var _id84, _ref84, _index2, _root41, _props131;
var SliderTickState = class {
  constructor(props, root17) {
    __privateAdd(this, _id84);
    __privateAdd(this, _ref84);
    __privateAdd(this, _index2);
    __privateAdd(this, _root41);
    __privateAdd(this, _props131, derived(() => ({
      ...__privateGet(this, _root41).ticksPropsArr[__privateGet(this, _index2).current],
      id: __privateGet(this, _id84).current
    })));
    __privateSet(this, _id84, props.id);
    __privateSet(this, _ref84, props.ref);
    __privateSet(this, _root41, root17);
    __privateSet(this, _index2, props.index);
    useRefById({ id: __privateGet(this, _id84), ref: __privateGet(this, _ref84) });
  }
  get props() {
    return get(__privateGet(this, _props131));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props131)), owner, false);
  }
};
_id84 = new WeakMap();
_ref84 = new WeakMap();
_index2 = new WeakMap();
_root41 = new WeakMap();
_props131 = new WeakMap();
var [setSliderRootContext, getSliderRootContext] = createContext("Slider.Root");
function useSliderRoot(props) {
  return setSliderRootContext(new SliderRootState(props));
}
function useSliderRange(props) {
  return new SliderRangeState(props, getSliderRootContext());
}
function useSliderThumb(props) {
  return new SliderThumbState(props, getSliderRootContext());
}
function useSliderTick(props) {
  return new SliderTickState(props, getSliderRootContext());
}

// node_modules/bits-ui/dist/bits/slider/components/slider.svelte
mark_module_start();
Slider[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider.svelte";
var root_294 = add_locations(template(`<span><!></span>`), Slider[FILENAME], [[60, 1]]);
function Slider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Slider);
  validate_prop_bindings($$props, ["ref", "value"], [], Slider);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 31, () => proxy([])), onValueChange = prop($$props, "onValueChange", 3, noop2), onValueCommit = prop($$props, "onValueCommit", 3, noop2), disabled = prop($$props, "disabled", 3, false), min = prop($$props, "min", 3, 0), max = prop($$props, "max", 3, 100), step = prop($$props, "step", 3, 1), dir = prop($$props, "dir", 3, "ltr"), autoSort = prop($$props, "autoSort", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value",
      "onValueChange",
      "onValueCommit",
      "disabled",
      "min",
      "max",
      "step",
      "dir",
      "autoSort",
      "orientation",
      "controlledValue"
    ],
    "restProps"
  );
  const rootState = useSliderRoot({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    onValueCommit: box.with(() => onValueCommit()),
    disabled: box.with(() => disabled()),
    min: box.with(() => min()),
    max: box.with(() => max()),
    step: box.with(() => step()),
    dir: box.with(() => dir()),
    autoSort: box.with(() => autoSort()),
    orientation: box.with(() => orientation())
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_294();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider = hmr(Slider, () => Slider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider[HMR].source;
    set(Slider[HMR].source, module.default[HMR].original);
  });
}
var slider_default = Slider;
mark_module_end(Slider);

// node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte
mark_module_start();
Slider_range[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte";
var root_295 = add_locations(template(`<span><!></span>`), Slider_range[FILENAME], [[28, 1]]);
function Slider_range($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Slider_range);
  validate_prop_bindings($$props, ["ref"], [], Slider_range);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const rangeState = useSliderRange({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rangeState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_295();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_range = hmr(Slider_range, () => Slider_range[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_range[HMR].source;
    set(Slider_range[HMR].source, module.default[HMR].original);
  });
}
var slider_range_default = Slider_range;
mark_module_end(Slider_range);

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte
mark_module_start();
Slider_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte";
var root_296 = add_locations(template(`<span><!></span>`), Slider_thumb[FILENAME], [[33, 1]]);
function Slider_thumb($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Slider_thumb);
  validate_prop_bindings($$props, ["ref"], [], Slider_thumb);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index",
      "disabled"
    ],
    "restProps"
  );
  const thumbState = useSliderThumb({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index),
    disabled: box.with(() => disabled())
  });
  const mergedProps = derived(() => mergeProps(restProps, thumbState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_296();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_thumb = hmr(Slider_thumb, () => Slider_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_thumb[HMR].source;
    set(Slider_thumb[HMR].source, module.default[HMR].original);
  });
}
var slider_thumb_default = Slider_thumb;
mark_module_end(Slider_thumb);

// node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte
mark_module_start();
Slider_tick[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte";
var root_297 = add_locations(template(`<span><!></span>`), Slider_tick[FILENAME], [[31, 1]]);
function Slider_tick($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Slider_tick);
  validate_prop_bindings($$props, ["ref"], [], Slider_tick);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index"
    ],
    "restProps"
  );
  const tickState = useSliderTick({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index)
  });
  const mergedProps = derived(() => mergeProps(restProps, tickState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_297();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_tick = hmr(Slider_tick, () => Slider_tick[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_tick[HMR].source;
    set(Slider_tick[HMR].source, module.default[HMR].original);
  });
}
var slider_tick_default = Slider_tick;
mark_module_end(Slider_tick);

// node_modules/bits-ui/dist/bits/switch/exports.js
var exports_exports32 = {};
__export(exports_exports32, {
  Root: () => switch_default,
  Thumb: () => switch_thumb_default
});

// node_modules/bits-ui/dist/bits/switch/switch.svelte.js
var ROOT_ATTR9 = "data-switch-root";
var THUMB_ATTR = "data-switch-thumb";
var _id85, _ref85, _toggle2, _onkeydown38, _onclick18, _sharedProps2, _props132;
var SwitchRootState = class {
  constructor(props) {
    __privateAdd(this, _id85);
    __privateAdd(this, _ref85);
    __publicField(this, "checked");
    __publicField(this, "disabled");
    __publicField(this, "required");
    __publicField(this, "name");
    __publicField(this, "value");
    __privateAdd(this, _toggle2, () => {
      this.checked.current = !this.checked.current;
    });
    __privateAdd(this, _onkeydown38, (e) => {
      if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) || this.disabled.current) return;
      e.preventDefault();
      __privateGet(this, _toggle2).call(this);
    });
    __privateAdd(this, _onclick18, (e) => {
      if (this.disabled.current) return;
      __privateGet(this, _toggle2).call(this);
    });
    __privateAdd(this, _sharedProps2, derived(() => ({
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-state": getDataChecked(this.checked.current),
      "data-required": getDataRequired(this.required.current)
    })));
    __privateAdd(this, _props132, derived(() => ({
      ...this.sharedProps,
      id: __privateGet(this, _id85).current,
      role: "switch",
      disabled: getDisabled(this.disabled.current),
      "aria-checked": getAriaChecked(this.checked.current, false),
      "aria-required": getAriaRequired(this.required.current),
      [ROOT_ATTR9]: "",
      //
      onclick: __privateGet(this, _onclick18),
      onkeydown: __privateGet(this, _onkeydown38)
    })));
    this.checked = props.checked;
    this.disabled = props.disabled;
    this.required = props.required;
    this.name = props.name;
    this.value = props.value;
    __privateSet(this, _id85, props.id);
    __privateSet(this, _ref85, props.ref);
    useRefById({ id: __privateGet(this, _id85), ref: __privateGet(this, _ref85) });
  }
  get sharedProps() {
    return get(__privateGet(this, _sharedProps2));
  }
  set sharedProps(_) {
    throw new Error("Cannot update a derived property ('sharedProps')");
  }
  get props() {
    return get(__privateGet(this, _props132));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _sharedProps2)), owner, false);
    add_owner(get(__privateGet(this, _props132)), owner, false);
  }
};
_id85 = new WeakMap();
_ref85 = new WeakMap();
_toggle2 = new WeakMap();
_onkeydown38 = new WeakMap();
_onclick18 = new WeakMap();
_sharedProps2 = new WeakMap();
_props132 = new WeakMap();
var _root42, _shouldRender9, _props133;
var SwitchInputState = class {
  constructor(root17) {
    __privateAdd(this, _root42);
    __privateAdd(this, _shouldRender9, derived(() => strict_equals(__privateGet(this, _root42).name.current, void 0, false)));
    __privateAdd(this, _props133, derived(() => ({
      type: "checkbox",
      name: __privateGet(this, _root42).name.current,
      value: __privateGet(this, _root42).value.current,
      checked: __privateGet(this, _root42).checked.current,
      disabled: __privateGet(this, _root42).disabled.current,
      required: __privateGet(this, _root42).required.current,
      "aria-hidden": getAriaHidden(true),
      style: styleToString(srOnlyStyles)
    })));
    __privateSet(this, _root42, root17);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender9));
  }
  set shouldRender(_) {
    throw new Error("Cannot update a derived property ('shouldRender')");
  }
  get props() {
    return get(__privateGet(this, _props133));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _shouldRender9)), owner, false);
    add_owner(get(__privateGet(this, _props133)), owner, false);
  }
};
_root42 = new WeakMap();
_shouldRender9 = new WeakMap();
_props133 = new WeakMap();
var _id86, _ref86, _props134;
var SwitchThumbState = class {
  constructor(props, root17) {
    __privateAdd(this, _id86);
    __privateAdd(this, _ref86);
    __publicField(this, "root");
    __privateAdd(this, _props134, derived(() => ({
      ...this.root.sharedProps,
      id: __privateGet(this, _id86).current,
      [THUMB_ATTR]: ""
    })));
    this.root = root17;
    __privateSet(this, _id86, props.id);
    __privateSet(this, _ref86, props.ref);
    useRefById({ id: __privateGet(this, _id86), ref: __privateGet(this, _ref86) });
  }
  get props() {
    return get(__privateGet(this, _props134));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props134)), owner, false);
  }
};
_id86 = new WeakMap();
_ref86 = new WeakMap();
_props134 = new WeakMap();
var [setSwitchRootContext, getSwitchRootContext] = createContext("Switch.Root");
function useSwitchRoot(props) {
  return setSwitchRootContext(new SwitchRootState(props));
}
function useSwitchInput() {
  return new SwitchInputState(getSwitchRootContext());
}
function useSwitchThumb(props) {
  return new SwitchThumbState(props, getSwitchRootContext());
}

// node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte
mark_module_start();
Switch_input[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte";
var root_17 = add_locations(template(`<input>`), Switch_input[FILENAME], [[8, 1]]);
function Switch_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Switch_input);
  const inputState = useSwitchInput();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => inputState.shouldRender, ($$anchor2) => {
    var input = root_17();
    remove_input_defaults(input);
    let attributes;
    template_effect(() => attributes = set_attributes(input, attributes, { ...inputState.props }));
    append($$anchor2, input);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch_input = hmr(Switch_input, () => Switch_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch_input[HMR].source;
    set(Switch_input[HMR].source, module.default[HMR].original);
  });
}
var switch_input_default = Switch_input;
mark_module_end(Switch_input);

// node_modules/bits-ui/dist/bits/switch/components/switch.svelte
mark_module_start();
Switch[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch.svelte";
var root_298 = add_locations(template(`<button><!></button>`), Switch[FILENAME], [[54, 1]]);
var root16 = add_locations(template(`<!> <!>`, 1), Switch[FILENAME], []);
function Switch($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Switch);
  validate_prop_bindings($$props, ["ref", "checked"], [], Switch);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), checked = prop($$props, "checked", 15, false), value = prop($$props, "value", 3, "on"), name = prop($$props, "name", 3, void 0), type = prop($$props, "type", 3, "button"), onCheckedChange = prop($$props, "onCheckedChange", 3, noop2), controlledChecked = prop($$props, "controlledChecked", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "disabled",
      "required",
      "checked",
      "value",
      "name",
      "type",
      "onCheckedChange",
      "controlledChecked"
    ],
    "restProps"
  );
  const rootState = useSwitchRoot({
    checked: box.with(() => checked(), (v) => {
      var _a;
      if (controlledChecked()) {
        onCheckedChange()(v);
      } else {
        checked(v);
        (_a = onCheckedChange()) == null ? void 0 : _a(v);
      }
    }),
    disabled: box.with(() => disabled() ?? false),
    required: box.with(() => required()),
    value: box.with(() => value()),
    name: box.with(() => name()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props, { type: type() }));
  var fragment = root16();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        checked: rootState.checked.current
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_298();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => ({ checked: rootState.checked.current }));
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  var node_3 = sibling(node, 2);
  switch_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch = hmr(Switch, () => Switch[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch[HMR].source;
    set(Switch[HMR].source, module.default[HMR].original);
  });
}
var switch_default = Switch;
mark_module_end(Switch);

// node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte
mark_module_start();
Switch_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte";
var root_299 = add_locations(template(`<span><!></span>`), Switch_thumb[FILENAME], [[29, 1]]);
function Switch_thumb($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Switch_thumb);
  validate_prop_bindings($$props, ["ref"], [], Switch_thumb);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id"
    ],
    "restProps"
  );
  const thumbState = useSwitchThumb({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, thumbState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        checked: thumbState.root.checked.current
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var span = root_299();
      let attributes;
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop, () => ({ checked: thumbState.root.checked.current }));
      reset(span);
      template_effect(() => attributes = set_attributes(span, attributes, { ...get(mergedProps) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch_thumb = hmr(Switch_thumb, () => Switch_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch_thumb[HMR].source;
    set(Switch_thumb[HMR].source, module.default[HMR].original);
  });
}
var switch_thumb_default = Switch_thumb;
mark_module_end(Switch_thumb);

// node_modules/bits-ui/dist/bits/tabs/exports.js
var exports_exports33 = {};
__export(exports_exports33, {
  Content: () => tabs_content_default,
  List: () => tabs_list_default,
  Root: () => tabs_default,
  Trigger: () => tabs_trigger_default
});

// node_modules/bits-ui/dist/bits/tabs/tabs.svelte.js
var ROOT_ATTR10 = "data-tabs-root";
var LIST_ATTR3 = "data-tabs-list";
var TRIGGER_ATTR4 = "data-tabs-trigger";
var CONTENT_ATTR3 = "data-tabs-content";
var _id87, _triggerIds2, _props135;
var TabsRootState = class {
  constructor(props) {
    __privateAdd(this, _id87);
    __publicField(this, "ref");
    __publicField(this, "orientation");
    __publicField(this, "loop");
    __publicField(this, "activationMode");
    __publicField(this, "value");
    __publicField(this, "disabled");
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _triggerIds2, state(proxy([])));
    // holds the trigger ID for each value to associate it with the content
    __publicField(this, "valueToTriggerId", new SvelteMap());
    // holds the content ID for each value to associate it with the trigger
    __publicField(this, "valueToContentId", new SvelteMap());
    __publicField(this, "registerTrigger", (id, value) => {
      this.triggerIds.push(id);
      this.valueToTriggerId.set(value, id);
      return () => {
        this.triggerIds = this.triggerIds.filter((triggerId) => strict_equals(triggerId, id, false));
        this.valueToTriggerId.delete(value);
      };
    });
    __publicField(this, "registerContent", (id, value) => {
      this.valueToContentId.set(value, id);
      return () => {
        this.valueToContentId.delete(value);
      };
    });
    __publicField(this, "setValue", (v) => {
      this.value.current = v;
    });
    __privateAdd(this, _props135, derived(() => ({
      id: __privateGet(this, _id87).current,
      "data-orientation": getDataOrientation(this.orientation.current),
      [ROOT_ATTR10]: ""
    })));
    __privateSet(this, _id87, props.id);
    this.ref = props.ref;
    this.orientation = props.orientation;
    this.loop = props.loop;
    this.activationMode = props.activationMode;
    this.value = props.value;
    this.disabled = props.disabled;
    useRefById({ id: __privateGet(this, _id87), ref: this.ref });
    this.rovingFocusGroup = useRovingFocus({
      candidateAttr: TRIGGER_ATTR4,
      rootNodeId: __privateGet(this, _id87),
      loop: this.loop,
      orientation: this.orientation
    });
  }
  get triggerIds() {
    return get(__privateGet(this, _triggerIds2));
  }
  set triggerIds(value) {
    set(__privateGet(this, _triggerIds2), proxy(value, null, __privateGet(this, _triggerIds2)));
  }
  get props() {
    return get(__privateGet(this, _props135));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _triggerIds2)), owner, false);
    add_owner(get(__privateGet(this, _props135)), owner, false);
  }
};
_id87 = new WeakMap();
_triggerIds2 = new WeakMap();
_props135 = new WeakMap();
var _id88, _ref87, _root43, _isDisabled11, _props136;
var TabsListState = class {
  constructor(props, root17) {
    __privateAdd(this, _id88);
    __privateAdd(this, _ref87);
    __privateAdd(this, _root43);
    __privateAdd(this, _isDisabled11, derived(() => __privateGet(this, _root43).disabled.current));
    __privateAdd(this, _props136, derived(() => ({
      id: __privateGet(this, _id88).current,
      role: "tablist",
      "aria-orientation": getAriaOrientation(__privateGet(this, _root43).orientation.current),
      "data-orientation": getDataOrientation(__privateGet(this, _root43).orientation.current),
      [LIST_ATTR3]: "",
      "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled11)))
    })));
    __privateSet(this, _root43, root17);
    __privateSet(this, _id88, props.id);
    __privateSet(this, _ref87, props.ref);
    useRefById({ id: __privateGet(this, _id88), ref: __privateGet(this, _ref87) });
  }
  get props() {
    return get(__privateGet(this, _props136));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props136)), owner, false);
  }
};
_id88 = new WeakMap();
_ref87 = new WeakMap();
_root43 = new WeakMap();
_isDisabled11 = new WeakMap();
_props136 = new WeakMap();
var _root44, _id89, _ref88, _disabled14, _value10, _isActive3, _isDisabled12, _tabIndex3, _ariaControls2, _onfocus8, _onclick19, _onkeydown39, _props137;
var TabsTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _root44);
    __privateAdd(this, _id89);
    __privateAdd(this, _ref88);
    __privateAdd(this, _disabled14);
    __privateAdd(this, _value10);
    __privateAdd(this, _isActive3, derived(() => strict_equals(__privateGet(this, _root44).value.current, __privateGet(this, _value10).current)));
    __privateAdd(this, _isDisabled12, derived(() => __privateGet(this, _disabled14).current || __privateGet(this, _root44).disabled.current));
    __privateAdd(this, _tabIndex3, state(0));
    __privateAdd(this, _ariaControls2, derived(() => __privateGet(this, _root44).valueToContentId.get(__privateGet(this, _value10).current)));
    __publicField(this, "activate", () => {
      if (strict_equals(__privateGet(this, _root44).value.current, __privateGet(this, _value10).current)) return;
      __privateGet(this, _root44).setValue(__privateGet(this, _value10).current);
    });
    __privateAdd(this, _onfocus8, () => {
      if (strict_equals(__privateGet(this, _root44).activationMode.current, "automatic", false) || get(__privateGet(this, _isDisabled12))) return;
      this.activate();
    });
    __privateAdd(this, _onclick19, (e) => {
      if (get(__privateGet(this, _isDisabled12))) return;
      this.activate();
    });
    __privateAdd(this, _onkeydown39, (e) => {
      if (get(__privateGet(this, _isDisabled12))) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        e.preventDefault();
        this.activate();
        return;
      }
      __privateGet(this, _root44).rovingFocusGroup.handleKeydown(__privateGet(this, _ref88).current, e);
    });
    __privateAdd(this, _props137, derived(() => ({
      id: __privateGet(this, _id89).current,
      role: "tab",
      "data-state": getTabDataState(get(__privateGet(this, _isActive3))),
      "data-value": __privateGet(this, _value10).current,
      "data-orientation": getDataOrientation(__privateGet(this, _root44).orientation.current),
      "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled12))),
      "aria-selected": getAriaSelected(get(__privateGet(this, _isActive3))),
      "aria-controls": get(__privateGet(this, _ariaControls2)),
      [TRIGGER_ATTR4]: "",
      disabled: getDisabled(get(__privateGet(this, _isDisabled12))),
      tabindex: get(__privateGet(this, _tabIndex3)),
      //
      onclick: __privateGet(this, _onclick19),
      onfocus: __privateGet(this, _onfocus8),
      onkeydown: __privateGet(this, _onkeydown39)
    })));
    __privateSet(this, _root44, root17);
    __privateSet(this, _id89, props.id);
    __privateSet(this, _ref88, props.ref);
    __privateSet(this, _value10, props.value);
    __privateSet(this, _disabled14, props.disabled);
    useRefById({ id: __privateGet(this, _id89), ref: __privateGet(this, _ref88) });
    user_effect(() => {
      const id = __privateGet(this, _id89).current;
      const value = __privateGet(this, _value10).current;
      return untrack(() => {
        const deregister = __privateGet(this, _root44).registerTrigger(id, value);
        return () => {
          deregister();
        };
      });
    });
    user_effect(() => {
      __privateGet(this, _root44).triggerIds.length;
      if (get(__privateGet(this, _isActive3)) || !__privateGet(this, _root44).value.current) {
        set(__privateGet(this, _tabIndex3), 0);
      } else {
        set(__privateGet(this, _tabIndex3), -1);
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props137));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props137)), owner, false);
  }
};
_root44 = new WeakMap();
_id89 = new WeakMap();
_ref88 = new WeakMap();
_disabled14 = new WeakMap();
_value10 = new WeakMap();
_isActive3 = new WeakMap();
_isDisabled12 = new WeakMap();
_tabIndex3 = new WeakMap();
_ariaControls2 = new WeakMap();
_onfocus8 = new WeakMap();
_onclick19 = new WeakMap();
_onkeydown39 = new WeakMap();
_props137 = new WeakMap();
var _root45, _id90, _ref89, _value11, _isActive4, _ariaLabelledBy, _props138;
var TabsContentState = class {
  constructor(props, root17) {
    __privateAdd(this, _root45);
    __privateAdd(this, _id90);
    __privateAdd(this, _ref89);
    __privateAdd(this, _value11);
    __privateAdd(this, _isActive4, derived(() => strict_equals(__privateGet(this, _root45).value.current, __privateGet(this, _value11).current)));
    __privateAdd(this, _ariaLabelledBy, derived(() => __privateGet(this, _root45).valueToTriggerId.get(__privateGet(this, _value11).current)));
    __privateAdd(this, _props138, derived(() => ({
      id: __privateGet(this, _id90).current,
      role: "tabpanel",
      hidden: getHidden(!get(__privateGet(this, _isActive4))),
      tabindex: 0,
      "data-value": __privateGet(this, _value11).current,
      "data-state": getTabDataState(get(__privateGet(this, _isActive4))),
      "aria-labelledby": get(__privateGet(this, _ariaLabelledBy)),
      [CONTENT_ATTR3]: ""
    })));
    __privateSet(this, _root45, root17);
    __privateSet(this, _value11, props.value);
    __privateSet(this, _id90, props.id);
    __privateSet(this, _ref89, props.ref);
    useRefById({ id: __privateGet(this, _id90), ref: __privateGet(this, _ref89) });
    user_effect(() => {
      const id = __privateGet(this, _id90).current;
      const value = __privateGet(this, _value11).current;
      untrack(() => {
        const deregister = __privateGet(this, _root45).registerContent(id, value);
        return () => {
          deregister();
        };
      });
    });
  }
  get props() {
    return get(__privateGet(this, _props138));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props138)), owner, false);
  }
};
_root45 = new WeakMap();
_id90 = new WeakMap();
_ref89 = new WeakMap();
_value11 = new WeakMap();
_isActive4 = new WeakMap();
_ariaLabelledBy = new WeakMap();
_props138 = new WeakMap();
var [setTabsRootContext, getTabsRootContext] = createContext("Tabs.Root");
function useTabsRoot(props) {
  return setTabsRootContext(new TabsRootState(props));
}
function useTabsTrigger(props) {
  return new TabsTriggerState(props, getTabsRootContext());
}
function useTabsList(props) {
  return new TabsListState(props, getTabsRootContext());
}
function useTabsContent(props) {
  return new TabsContentState(props, getTabsRootContext());
}
function getTabDataState(condition) {
  return condition ? "active" : "inactive";
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte
mark_module_start();
Tabs[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte";
var root_2100 = add_locations(template(`<div><!></div>`), Tabs[FILENAME], [[52, 1]]);
function Tabs($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tabs);
  validate_prop_bindings($$props, ["ref", "value"], [], Tabs);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop2), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), activationMode = prop($$props, "activationMode", 3, "automatic"), disabled = prop($$props, "disabled", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "orientation",
      "loop",
      "activationMode",
      "disabled",
      "controlledValue",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = useTabsRoot({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    orientation: box.with(() => orientation()),
    loop: box.with(() => loop()),
    activationMode: box.with(() => activationMode()),
    disabled: box.with(() => disabled()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2100();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs = hmr(Tabs, () => Tabs[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs[HMR].source;
    set(Tabs[HMR].source, module.default[HMR].original);
  });
}
var tabs_default = Tabs;
mark_module_end(Tabs);

// node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte
mark_module_start();
Tabs_content[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte";
var root_2101 = add_locations(template(`<div><!></div>`), Tabs_content[FILENAME], [[31, 1]]);
function Tabs_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tabs_content);
  validate_prop_bindings($$props, ["ref"], [], Tabs_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value"
    ],
    "restProps"
  );
  const contentState = useTabsContent({
    value: box.with(() => $$props.value),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2101();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_content = hmr(Tabs_content, () => Tabs_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_content[HMR].source;
    set(Tabs_content[HMR].source, module.default[HMR].original);
  });
}
var tabs_content_default = Tabs_content;
mark_module_end(Tabs_content);

// node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte
mark_module_start();
Tabs_list[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte";
var root_2102 = add_locations(template(`<div><!></div>`), Tabs_list[FILENAME], [[29, 1]]);
function Tabs_list($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tabs_list);
  validate_prop_bindings($$props, ["ref"], [], Tabs_list);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const listState = useTabsList({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, listState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2102();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_list = hmr(Tabs_list, () => Tabs_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_list[HMR].source;
    set(Tabs_list[HMR].source, module.default[HMR].original);
  });
}
var tabs_list_default = Tabs_list;
mark_module_end(Tabs_list);

// node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte
mark_module_start();
Tabs_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte";
var root_2103 = add_locations(template(`<button><!></button>`), Tabs_trigger[FILENAME], [[34, 1]]);
function Tabs_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tabs_trigger);
  validate_prop_bindings($$props, ["ref"], [], Tabs_trigger);
  let disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, useId), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "disabled",
      "id",
      "type",
      "value",
      "ref"
    ],
    "restProps"
  );
  const triggerState = useTabsTrigger({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    value: box.with(() => $$props.value),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2103();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_trigger = hmr(Tabs_trigger, () => Tabs_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_trigger[HMR].source;
    set(Tabs_trigger[HMR].source, module.default[HMR].original);
  });
}
var tabs_trigger_default = Tabs_trigger;
mark_module_end(Tabs_trigger);

// node_modules/bits-ui/dist/bits/toggle/exports.js
var exports_exports34 = {};
__export(exports_exports34, {
  Root: () => toggle_default
});

// node_modules/bits-ui/dist/bits/toggle/toggle.svelte.js
var ROOT_ATTR11 = "data-toggle-root";
var _id91, _ref90, _disabled15, _togglePressed, _onclick20, _props139;
var ToggleRootState = class {
  constructor(props) {
    __privateAdd(this, _id91);
    __privateAdd(this, _ref90);
    __privateAdd(this, _disabled15);
    __publicField(this, "pressed");
    __privateAdd(this, _togglePressed, () => {
      if (!__privateGet(this, _disabled15).current) {
        this.pressed.current = !this.pressed.current;
      }
    });
    __privateAdd(this, _onclick20, () => {
      if (__privateGet(this, _disabled15).current) return;
      __privateGet(this, _togglePressed).call(this);
    });
    __privateAdd(this, _props139, derived(() => ({
      [ROOT_ATTR11]: "",
      id: __privateGet(this, _id91).current,
      "data-disabled": getDataDisabled(__privateGet(this, _disabled15).current),
      "aria-pressed": getAriaPressed(this.pressed.current),
      "data-state": getToggleDataState(this.pressed.current),
      disabled: getDisabled(__privateGet(this, _disabled15).current),
      onclick: __privateGet(this, _onclick20)
    })));
    __privateSet(this, _disabled15, props.disabled);
    this.pressed = props.pressed;
    __privateSet(this, _id91, props.id);
    __privateSet(this, _ref90, props.ref);
    useRefById({ id: __privateGet(this, _id91), ref: __privateGet(this, _ref90) });
  }
  get props() {
    return get(__privateGet(this, _props139));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props139)), owner, false);
  }
};
_id91 = new WeakMap();
_ref90 = new WeakMap();
_disabled15 = new WeakMap();
_togglePressed = new WeakMap();
_onclick20 = new WeakMap();
_props139 = new WeakMap();
function useToggleRoot(props) {
  return new ToggleRootState(props);
}
function getToggleDataState(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte
mark_module_start();
Toggle[FILENAME] = "node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte";
var root_2104 = add_locations(template(`<button><!></button>`), Toggle[FILENAME], [[47, 1]]);
function Toggle($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toggle);
  validate_prop_bindings($$props, ["ref", "pressed"], [], Toggle);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), pressed = prop($$props, "pressed", 15, false), onPressedChange = prop($$props, "onPressedChange", 3, noop2), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), controlledPressed = prop($$props, "controlledPressed", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "pressed",
      "onPressedChange",
      "disabled",
      "type",
      "controlledPressed",
      "children",
      "child"
    ],
    "restProps"
  );
  const toggleState = useToggleRoot({
    pressed: box.with(() => pressed(), (v) => {
      if (controlledPressed()) {
        onPressedChange()(v);
      } else {
        pressed(v);
        onPressedChange()(v);
      }
    }),
    disabled: box.with(() => disabled() ?? false),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, toggleState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        pressed: toggleState.pressed.current
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2104();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => ({ pressed: toggleState.pressed.current }));
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle = hmr(Toggle, () => Toggle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle[HMR].source;
    set(Toggle[HMR].source, module.default[HMR].original);
  });
}
var toggle_default = Toggle;
mark_module_end(Toggle);

// node_modules/bits-ui/dist/bits/toggle-group/exports.js
var exports_exports35 = {};
__export(exports_exports35, {
  Item: () => toggle_group_item_default,
  Root: () => toggle_group_default
});

// node_modules/bits-ui/dist/bits/toggle-group/toggle-group.svelte.js
var ROOT_ATTR12 = "data-toggle-group-root";
var ITEM_ATTR3 = "data-toggle-group-item";
var _props140;
var ToggleGroupBaseState = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "disabled");
    __publicField(this, "rovingFocus");
    __publicField(this, "loop");
    __publicField(this, "orientation");
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _props140, derived(() => ({
      id: this.id.current,
      [ROOT_ATTR12]: "",
      role: "group",
      "data-orientation": getDataOrientation(this.orientation.current),
      "data-disabled": getDataDisabled(this.disabled.current)
    })));
    this.id = props.id;
    this.ref = props.ref;
    this.disabled = props.disabled;
    this.rovingFocus = props.rovingFocus;
    this.loop = props.loop;
    this.orientation = props.orientation;
    this.rovingFocusGroup = useRovingFocus({
      candidateAttr: ITEM_ATTR3,
      rootNodeId: this.id,
      loop: this.loop,
      orientation: this.orientation
    });
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props140));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props140)), owner, false);
  }
};
_props140 = new WeakMap();
var _value12, _anyPressed;
var ToggleGroupSingleState = class extends ToggleGroupBaseState {
  constructor(props) {
    super(props);
    __privateAdd(this, _value12);
    __publicField(this, "isMulti", false);
    __privateAdd(this, _anyPressed, derived(() => strict_equals(__privateGet(this, _value12).current, "", false)));
    __publicField(this, "includesItem", (item) => {
      return strict_equals(__privateGet(this, _value12).current, item);
    });
    __publicField(this, "toggleItem", (item, id) => {
      if (this.includesItem(item)) {
        __privateGet(this, _value12).current = "";
      } else {
        __privateGet(this, _value12).current = item;
        this.rovingFocusGroup.setCurrentTabStopId(id);
      }
    });
    __privateSet(this, _value12, props.value);
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed));
  }
  set anyPressed(_) {
    throw new Error("Cannot update a derived property ('anyPressed')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _anyPressed)), owner, false);
  }
};
_value12 = new WeakMap();
_anyPressed = new WeakMap();
var _value13, _anyPressed2;
var ToggleGroupMultipleState = class extends ToggleGroupBaseState {
  constructor(props) {
    super(props);
    __privateAdd(this, _value13);
    __publicField(this, "isMulti", true);
    __privateAdd(this, _anyPressed2, derived(() => __privateGet(this, _value13).current.length > 0));
    __publicField(this, "includesItem", (item) => {
      return __privateGet(this, _value13).current.includes(item);
    });
    __publicField(this, "toggleItem", (item, id) => {
      if (this.includesItem(item)) {
        __privateGet(this, _value13).current = __privateGet(this, _value13).current.filter((v) => strict_equals(v, item, false));
      } else {
        __privateGet(this, _value13).current = [...__privateGet(this, _value13).current, item];
        this.rovingFocusGroup.setCurrentTabStopId(id);
      }
    });
    __privateSet(this, _value13, props.value);
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed2));
  }
  set anyPressed(_) {
    throw new Error("Cannot update a derived property ('anyPressed')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _anyPressed2)), owner, false);
  }
};
_value13 = new WeakMap();
_anyPressed2 = new WeakMap();
var _id92, _ref91, _root46, _value14, _disabled16, _isDisabled13, _onclick21, _onkeydown40, _isPressed, _ariaChecked, _ariaPressed, _tabIndex4, _props141;
var ToggleGroupItemState = class {
  constructor(props) {
    __privateAdd(this, _id92);
    __privateAdd(this, _ref91);
    __privateAdd(this, _root46);
    __privateAdd(this, _value14);
    __privateAdd(this, _disabled16);
    __privateAdd(this, _isDisabled13, derived(() => __privateGet(this, _disabled16).current || __privateGet(this, _root46).disabled.current));
    __publicField(this, "toggleItem", () => {
      if (get(__privateGet(this, _isDisabled13))) return;
      __privateGet(this, _root46).toggleItem(__privateGet(this, _value14).current, __privateGet(this, _id92).current);
    });
    __privateAdd(this, _onclick21, () => {
      if (get(__privateGet(this, _isDisabled13))) return;
      __privateGet(this, _root46).toggleItem(__privateGet(this, _value14).current, __privateGet(this, _id92).current);
    });
    __privateAdd(this, _onkeydown40, (e) => {
      if (get(__privateGet(this, _isDisabled13))) return;
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
        e.preventDefault();
        this.toggleItem();
        return;
      }
      if (!__privateGet(this, _root46).rovingFocus.current) return;
      __privateGet(this, _root46).rovingFocusGroup.handleKeydown(__privateGet(this, _ref91).current, e);
    });
    __privateAdd(this, _isPressed, derived(() => __privateGet(this, _root46).includesItem(__privateGet(this, _value14).current)));
    __privateAdd(this, _ariaChecked, derived(() => {
      return __privateGet(this, _root46).isMulti ? void 0 : getAriaChecked(this.isPressed, false);
    }));
    __privateAdd(this, _ariaPressed, derived(() => {
      return __privateGet(this, _root46).isMulti ? getAriaPressed(this.isPressed) : void 0;
    }));
    __privateAdd(this, _tabIndex4, state(0));
    __privateAdd(this, _props141, derived(() => ({
      id: __privateGet(this, _id92).current,
      role: __privateGet(this, _root46).isMulti ? void 0 : "radio",
      tabindex: get(__privateGet(this, _tabIndex4)),
      "data-orientation": getDataOrientation(__privateGet(this, _root46).orientation.current),
      "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled13))),
      "data-state": getToggleItemDataState(this.isPressed),
      "data-value": __privateGet(this, _value14).current,
      "aria-pressed": get(__privateGet(this, _ariaPressed)),
      "aria-checked": get(__privateGet(this, _ariaChecked)),
      disabled: getDisabled(get(__privateGet(this, _isDisabled13))),
      [ITEM_ATTR3]: "",
      //
      onclick: __privateGet(this, _onclick21),
      onkeydown: __privateGet(this, _onkeydown40)
    })));
    __privateSet(this, _value14, props.value);
    __privateSet(this, _disabled16, props.disabled);
    __privateSet(this, _root46, props.rootState);
    __privateSet(this, _id92, props.id);
    __privateSet(this, _ref91, props.ref);
    useRefById({ id: __privateGet(this, _id92), ref: __privateGet(this, _ref91) });
    user_effect(() => {
      if (!__privateGet(this, _root46).rovingFocus.current) {
        set(__privateGet(this, _tabIndex4), 0);
      } else {
        set(__privateGet(this, _tabIndex4), proxy(__privateGet(this, _root46).rovingFocusGroup.getTabIndex(__privateGet(this, _ref91).current), null, __privateGet(this, _tabIndex4)));
      }
    });
  }
  get isPressed() {
    return get(__privateGet(this, _isPressed));
  }
  set isPressed(_) {
    throw new Error("Cannot update a derived property ('isPressed')");
  }
  get props() {
    return get(__privateGet(this, _props141));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isPressed)), owner, false);
    add_owner(get(__privateGet(this, _props141)), owner, false);
  }
};
_id92 = new WeakMap();
_ref91 = new WeakMap();
_root46 = new WeakMap();
_value14 = new WeakMap();
_disabled16 = new WeakMap();
_isDisabled13 = new WeakMap();
_onclick21 = new WeakMap();
_onkeydown40 = new WeakMap();
_isPressed = new WeakMap();
_ariaChecked = new WeakMap();
_ariaPressed = new WeakMap();
_tabIndex4 = new WeakMap();
_props141 = new WeakMap();
function getToggleItemDataState(condition) {
  return condition ? "on" : "off";
}
var [
  setToggleGroupRootContext,
  getToggleGroupRootContext
] = createContext("ToggleGroup.Root");
function useToggleGroupRoot(props) {
  const { type, ...rest } = props;
  const rootState = strict_equals(type, "single") ? new ToggleGroupSingleState(rest) : new ToggleGroupMultipleState(rest);
  return setToggleGroupRootContext(rootState);
}
function useToggleGroupItem(props) {
  const rootState = getToggleGroupRootContext();
  return new ToggleGroupItemState({ ...props, rootState });
}

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte
mark_module_start();
Toggle_group[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte";
var root_2105 = add_locations(template(`<div><!></div>`), Toggle_group[FILENAME], [[64, 1]]);
function Toggle_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toggle_group);
  validate_prop_bindings($$props, ["ref", "value"], [], Toggle_group);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), disabled = prop($$props, "disabled", 3, false), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), rovingFocus = prop($$props, "rovingFocus", 3, true), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "type",
      "disabled",
      "loop",
      "orientation",
      "rovingFocus",
      "controlledValue",
      "child",
      "children"
    ],
    "restProps"
  );
  if (strict_equals(value(), void 0)) {
    const defaultValue = strict_equals($$props.type, "single") ? "" : [];
    if (controlledValue()) {
      onValueChange()(defaultValue);
    } else {
      value(defaultValue);
    }
  }
  const rootState = useToggleGroupRoot({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      var _a;
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        (_a = onValueChange()) == null ? void 0 : _a(v);
      }
    }),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    orientation: box.with(() => orientation()),
    rovingFocus: box.with(() => rovingFocus()),
    type: $$props.type,
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2105();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle_group = hmr(Toggle_group, () => Toggle_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle_group[HMR].source;
    set(Toggle_group[HMR].source, module.default[HMR].original);
  });
}
var toggle_group_default = Toggle_group;
mark_module_end(Toggle_group);

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte
mark_module_start();
Toggle_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte";
var root_2106 = add_locations(template(`<button><!></button>`), Toggle_group_item[FILENAME], [[34, 1]]);
function Toggle_group_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toggle_group_item);
  validate_prop_bindings($$props, ["ref"], [], Toggle_group_item);
  let ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, useId), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "value",
      "disabled",
      "id",
      "type"
    ],
    "restProps"
  );
  const itemState = useToggleGroupItem({
    id: box.with(() => id()),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, itemState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        pressed: itemState.isPressed
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2106();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => ({ pressed: itemState.isPressed }));
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle_group_item = hmr(Toggle_group_item, () => Toggle_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle_group_item[HMR].source;
    set(Toggle_group_item[HMR].source, module.default[HMR].original);
  });
}
var toggle_group_item_default = Toggle_group_item;
mark_module_end(Toggle_group_item);

// node_modules/bits-ui/dist/bits/toolbar/exports.js
var exports_exports36 = {};
__export(exports_exports36, {
  Button: () => toolbar_button_default,
  Group: () => toolbar_group_default,
  GroupItem: () => toolbar_group_item_default,
  Link: () => toolbar_link_default,
  Root: () => toolbar_default
});

// node_modules/bits-ui/dist/bits/toolbar/toolbar.svelte.js
var ROOT_ATTR13 = "data-toolbar-root";
var ITEM_ATTR4 = "data-toolbar-item";
var GROUP_ATTR2 = "data-toolbar-group";
var GROUP_ITEM_ATTR = "data-toolbar-group-item";
var LINK_ATTR2 = "data-toolbar-link";
var BUTTON_ATTR = "data-toolbar-button";
var _id93, _ref92, _loop3, _props142;
var ToolbarRootState = class {
  constructor(props) {
    __privateAdd(this, _id93);
    __privateAdd(this, _ref92);
    __publicField(this, "orientation");
    __privateAdd(this, _loop3);
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _props142, derived(() => ({
      id: __privateGet(this, _id93).current,
      role: "toolbar",
      "data-orientation": this.orientation.current,
      [ROOT_ATTR13]: ""
    })));
    __privateSet(this, _id93, props.id);
    this.orientation = props.orientation;
    __privateSet(this, _loop3, props.loop);
    __privateSet(this, _ref92, props.ref);
    useRefById({ id: __privateGet(this, _id93), ref: __privateGet(this, _ref92) });
    this.rovingFocusGroup = useRovingFocus({
      orientation: this.orientation,
      loop: __privateGet(this, _loop3),
      rootNodeId: __privateGet(this, _id93),
      candidateAttr: ITEM_ATTR4
    });
  }
  get props() {
    return get(__privateGet(this, _props142));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props142)), owner, false);
  }
};
_id93 = new WeakMap();
_ref92 = new WeakMap();
_loop3 = new WeakMap();
_props142 = new WeakMap();
var _props143;
var ToolbarGroupBaseState = class {
  constructor(props, root17) {
    __publicField(this, "id");
    __publicField(this, "ref");
    __publicField(this, "disabled");
    __publicField(this, "root");
    __privateAdd(this, _props143, derived(() => ({
      id: this.id.current,
      [GROUP_ATTR2]: "",
      role: "group",
      "data-orientation": getDataOrientation(this.root.orientation.current),
      "data-disabled": getDataDisabled(this.disabled.current)
    })));
    this.id = props.id;
    this.ref = props.ref;
    this.disabled = props.disabled;
    this.root = root17;
    useRefById({ id: this.id, ref: this.ref });
  }
  get props() {
    return get(__privateGet(this, _props143));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props143)), owner, false);
  }
};
_props143 = new WeakMap();
var _value15, _anyPressed3;
var ToolbarGroupSingleState = class extends ToolbarGroupBaseState {
  constructor(props, root17) {
    super(props, root17);
    __privateAdd(this, _value15);
    __publicField(this, "isMulti", false);
    __privateAdd(this, _anyPressed3, derived(() => strict_equals(__privateGet(this, _value15).current, "", false)));
    __publicField(this, "includesItem", (item) => {
      return strict_equals(__privateGet(this, _value15).current, item);
    });
    __publicField(this, "toggleItem", (item) => {
      if (this.includesItem(item)) {
        __privateGet(this, _value15).current = "";
      } else {
        __privateGet(this, _value15).current = item;
      }
    });
    __privateSet(this, _value15, props.value);
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed3));
  }
  set anyPressed(_) {
    throw new Error("Cannot update a derived property ('anyPressed')");
  }
  createItem(props) {
    return new ToolbarGroupItemState(props, this, this.root);
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _anyPressed3)), owner, false);
  }
};
_value15 = new WeakMap();
_anyPressed3 = new WeakMap();
var _value16, _anyPressed4;
var ToolbarGroupMultipleState = class extends ToolbarGroupBaseState {
  constructor(props, root17) {
    super(props, root17);
    __privateAdd(this, _value16);
    __publicField(this, "isMulti", true);
    __privateAdd(this, _anyPressed4, derived(() => __privateGet(this, _value16).current.length > 0));
    __publicField(this, "includesItem", (item) => {
      return __privateGet(this, _value16).current.includes(item);
    });
    __publicField(this, "toggleItem", (item) => {
      if (this.includesItem(item)) {
        __privateGet(this, _value16).current = __privateGet(this, _value16).current.filter((v) => strict_equals(v, item, false));
      } else {
        __privateGet(this, _value16).current = [...__privateGet(this, _value16).current, item];
      }
    });
    __privateSet(this, _value16, props.value);
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed4));
  }
  set anyPressed(_) {
    throw new Error("Cannot update a derived property ('anyPressed')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _anyPressed4)), owner, false);
  }
};
_value16 = new WeakMap();
_anyPressed4 = new WeakMap();
var _id94, _ref93, _group6, _root47, _value17, _disabled17, _isDisabled14, _onclick22, _onkeydown41, _isPressed2, _ariaChecked2, _ariaPressed2, _tabIndex5, _props144;
var ToolbarGroupItemState = class {
  constructor(props, group, root17) {
    __privateAdd(this, _id94);
    __privateAdd(this, _ref93);
    __privateAdd(this, _group6);
    __privateAdd(this, _root47);
    __privateAdd(this, _value17);
    __privateAdd(this, _disabled17);
    __privateAdd(this, _isDisabled14, derived(() => __privateGet(this, _disabled17).current || __privateGet(this, _group6).disabled.current));
    __publicField(this, "toggleItem", () => {
      if (get(__privateGet(this, _isDisabled14))) return;
      __privateGet(this, _group6).toggleItem(__privateGet(this, _value17).current);
    });
    __privateAdd(this, _onclick22, () => {
      if (get(__privateGet(this, _isDisabled14))) return;
      this.toggleItem();
    });
    __privateAdd(this, _onkeydown41, (e) => {
      if (get(__privateGet(this, _isDisabled14))) return;
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
        e.preventDefault();
        this.toggleItem();
        return;
      }
      __privateGet(this, _root47).rovingFocusGroup.handleKeydown(__privateGet(this, _ref93).current, e);
    });
    __privateAdd(this, _isPressed2, derived(() => __privateGet(this, _group6).includesItem(__privateGet(this, _value17).current)));
    __privateAdd(this, _ariaChecked2, derived(() => {
      return __privateGet(this, _group6).isMulti ? void 0 : getAriaChecked(this.isPressed, false);
    }));
    __privateAdd(this, _ariaPressed2, derived(() => {
      return __privateGet(this, _group6).isMulti ? getAriaPressed(this.isPressed) : void 0;
    }));
    __privateAdd(this, _tabIndex5, state(0));
    __privateAdd(this, _props144, derived(() => ({
      id: __privateGet(this, _id94).current,
      role: __privateGet(this, _group6).isMulti ? void 0 : "radio",
      tabindex: get(__privateGet(this, _tabIndex5)),
      "data-orientation": getDataOrientation(__privateGet(this, _root47).orientation.current),
      "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled14))),
      "data-state": getToggleItemDataState2(this.isPressed),
      "data-value": __privateGet(this, _value17).current,
      "aria-pressed": get(__privateGet(this, _ariaPressed2)),
      "aria-checked": get(__privateGet(this, _ariaChecked2)),
      [ITEM_ATTR4]: "",
      [GROUP_ITEM_ATTR]: "",
      disabled: getDisabled(get(__privateGet(this, _isDisabled14))),
      //
      onclick: __privateGet(this, _onclick22),
      onkeydown: __privateGet(this, _onkeydown41)
    })));
    __privateSet(this, _value17, props.value);
    __privateSet(this, _disabled17, props.disabled);
    __privateSet(this, _group6, group);
    __privateSet(this, _root47, root17);
    __privateSet(this, _id94, props.id);
    __privateSet(this, _ref93, props.ref);
    useRefById({ id: __privateGet(this, _id94), ref: __privateGet(this, _ref93) });
    user_effect(() => {
      set(__privateGet(this, _tabIndex5), proxy(__privateGet(this, _root47).rovingFocusGroup.getTabIndex(__privateGet(this, _ref93).current), null, __privateGet(this, _tabIndex5)));
    });
  }
  get isPressed() {
    return get(__privateGet(this, _isPressed2));
  }
  set isPressed(_) {
    throw new Error("Cannot update a derived property ('isPressed')");
  }
  get props() {
    return get(__privateGet(this, _props144));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isPressed2)), owner, false);
    add_owner(get(__privateGet(this, _props144)), owner, false);
  }
};
_id94 = new WeakMap();
_ref93 = new WeakMap();
_group6 = new WeakMap();
_root47 = new WeakMap();
_value17 = new WeakMap();
_disabled17 = new WeakMap();
_isDisabled14 = new WeakMap();
_onclick22 = new WeakMap();
_onkeydown41 = new WeakMap();
_isPressed2 = new WeakMap();
_ariaChecked2 = new WeakMap();
_ariaPressed2 = new WeakMap();
_tabIndex5 = new WeakMap();
_props144 = new WeakMap();
var _id95, _ref94, _root48, _onkeydown42, _role, _tabIndex6, _props145;
var ToolbarLinkState = class {
  constructor(props, root17) {
    __privateAdd(this, _id95);
    __privateAdd(this, _ref94);
    __privateAdd(this, _root48);
    __privateAdd(this, _onkeydown42, (e) => {
      __privateGet(this, _root48).rovingFocusGroup.handleKeydown(__privateGet(this, _ref94).current, e);
    });
    __privateAdd(this, _role, derived(() => {
      if (!__privateGet(this, _ref94).current) return void 0;
      const tagName = __privateGet(this, _ref94).current.tagName;
      if (strict_equals(tagName, "A", false)) return "link";
      return void 0;
    }));
    __privateAdd(this, _tabIndex6, state(0));
    __privateAdd(this, _props145, derived(() => ({
      id: __privateGet(this, _id95).current,
      [LINK_ATTR2]: "",
      [ITEM_ATTR4]: "",
      role: get(__privateGet(this, _role)),
      tabindex: get(__privateGet(this, _tabIndex6)),
      "data-orientation": getDataOrientation(__privateGet(this, _root48).orientation.current),
      //
      onkeydown: __privateGet(this, _onkeydown42)
    })));
    __privateSet(this, _root48, root17);
    __privateSet(this, _id95, props.id);
    __privateSet(this, _ref94, props.ref);
    useRefById({ id: __privateGet(this, _id95), ref: __privateGet(this, _ref94) });
    user_effect(() => {
      set(__privateGet(this, _tabIndex6), proxy(__privateGet(this, _root48).rovingFocusGroup.getTabIndex(__privateGet(this, _ref94).current), null, __privateGet(this, _tabIndex6)));
    });
  }
  get props() {
    return get(__privateGet(this, _props145));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props145)), owner, false);
  }
};
_id95 = new WeakMap();
_ref94 = new WeakMap();
_root48 = new WeakMap();
_onkeydown42 = new WeakMap();
_role = new WeakMap();
_tabIndex6 = new WeakMap();
_props145 = new WeakMap();
var _id96, _ref95, _root49, _disabled18, _onkeydown43, _tabIndex7, _role2, _props146;
var ToolbarButtonState = class {
  constructor(props, root17) {
    __privateAdd(this, _id96);
    __privateAdd(this, _ref95);
    __privateAdd(this, _root49);
    __privateAdd(this, _disabled18);
    __privateAdd(this, _onkeydown43, (e) => {
      __privateGet(this, _root49).rovingFocusGroup.handleKeydown(__privateGet(this, _ref95).current, e);
    });
    __privateAdd(this, _tabIndex7, state(0));
    __privateAdd(this, _role2, derived(() => {
      if (!__privateGet(this, _ref95).current) return void 0;
      const tagName = __privateGet(this, _ref95).current.tagName;
      if (strict_equals(tagName, "BUTTON", false)) return "button";
      return void 0;
    }));
    __privateAdd(this, _props146, derived(() => ({
      id: __privateGet(this, _id96).current,
      [ITEM_ATTR4]: "",
      [BUTTON_ATTR]: "",
      role: get(__privateGet(this, _role2)),
      tabindex: get(__privateGet(this, _tabIndex7)),
      "data-disabled": getDataDisabled(__privateGet(this, _disabled18).current),
      "data-orientation": getDataOrientation(__privateGet(this, _root49).orientation.current),
      disabled: getDisabled(__privateGet(this, _disabled18).current),
      //
      onkeydown: __privateGet(this, _onkeydown43)
    })));
    __privateSet(this, _id96, props.id);
    __privateSet(this, _ref95, props.ref);
    __privateSet(this, _disabled18, props.disabled);
    __privateSet(this, _root49, root17);
    useRefById({ id: __privateGet(this, _id96), ref: __privateGet(this, _ref95) });
    user_effect(() => {
      set(__privateGet(this, _tabIndex7), proxy(__privateGet(this, _root49).rovingFocusGroup.getTabIndex(__privateGet(this, _ref95).current), null, __privateGet(this, _tabIndex7)));
    });
  }
  get props() {
    return get(__privateGet(this, _props146));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props146)), owner, false);
  }
};
_id96 = new WeakMap();
_ref95 = new WeakMap();
_root49 = new WeakMap();
_disabled18 = new WeakMap();
_onkeydown43 = new WeakMap();
_tabIndex7 = new WeakMap();
_role2 = new WeakMap();
_props146 = new WeakMap();
function getToggleItemDataState2(condition) {
  return condition ? "on" : "off";
}
var [setToolbarRootContext, getToolbarRootContext] = createContext("Toolbar.Root");
var [
  setToolbarGroupContext,
  getToolbarGroupContext
] = createContext("Toolbar.Group");
function useToolbarRoot(props) {
  return setToolbarRootContext(new ToolbarRootState(props));
}
function useToolbarGroup(props) {
  const { type, ...rest } = props;
  const rootState = getToolbarRootContext();
  const groupState = strict_equals(type, "single") ? new ToolbarGroupSingleState(rest, rootState) : new ToolbarGroupMultipleState(rest, rootState);
  return setToolbarGroupContext(groupState);
}
function useToolbarGroupItem(props) {
  const group = getToolbarGroupContext();
  return new ToolbarGroupItemState(props, group, group.root);
}
function useToolbarButton(props) {
  return new ToolbarButtonState(props, getToolbarRootContext());
}
function useToolbarLink(props) {
  return new ToolbarLinkState(props, getToolbarRootContext());
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte
mark_module_start();
Toolbar[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte";
var root_2107 = add_locations(template(`<div><!></div>`), Toolbar[FILENAME], [[33, 1]]);
function Toolbar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toolbar);
  validate_prop_bindings($$props, ["ref"], [], Toolbar);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation",
      "loop",
      "child",
      "children"
    ],
    "restProps"
  );
  const rootState = useToolbarRoot({
    id: box.with(() => id()),
    orientation: box.with(() => orientation()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2107();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar = hmr(Toolbar, () => Toolbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar[HMR].source;
    set(Toolbar[HMR].source, module.default[HMR].original);
  });
}
var toolbar_default = Toolbar;
mark_module_end(Toolbar);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte
mark_module_start();
Toolbar_button[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte";
var root_2108 = add_locations(template(`<button><!></button>`), Toolbar_button[FILENAME], [[32, 1]]);
function Toolbar_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toolbar_button);
  validate_prop_bindings($$props, ["ref"], [], Toolbar_button);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "disabled",
      "type",
      "id",
      "ref"
    ],
    "restProps"
  );
  const buttonState = useToolbarButton({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, buttonState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2108();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_button = hmr(Toolbar_button, () => Toolbar_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_button[HMR].source;
    set(Toolbar_button[HMR].source, module.default[HMR].original);
  });
}
var toolbar_button_default = Toolbar_button;
mark_module_end(Toolbar_button);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte
mark_module_start();
Toolbar_link[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte";
var root_2109 = add_locations(template(`<a><!></a>`), Toolbar_link[FILENAME], [[30, 1]]);
function Toolbar_link($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toolbar_link);
  validate_prop_bindings($$props, ["ref"], [], Toolbar_link);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "href",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const linkState = useToolbarLink({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, linkState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var a2 = root_2109();
      let attributes;
      var node_2 = child(a2);
      snippet(node_2, () => $$props.children ?? noop);
      reset(a2);
      template_effect(() => attributes = set_attributes(a2, attributes, { href: $$props.href, ...get(mergedProps) }));
      append($$anchor2, a2);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_link = hmr(Toolbar_link, () => Toolbar_link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_link[HMR].source;
    set(Toolbar_link[HMR].source, module.default[HMR].original);
  });
}
var toolbar_link_default = Toolbar_link;
mark_module_end(Toolbar_link);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte
mark_module_start();
Toolbar_group[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte";
var root_2110 = add_locations(template(`<div><!></div>`), Toolbar_group[FILENAME], [[58, 1]]);
function Toolbar_group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toolbar_group);
  validate_prop_bindings($$props, ["ref", "value"], [], Toolbar_group);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop2), disabled = prop($$props, "disabled", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "type",
      "disabled",
      "controlledValue",
      "child",
      "children"
    ],
    "restProps"
  );
  if (strict_equals(value(), void 0)) {
    const defaultValue = strict_equals($$props.type, "single") ? "" : [];
    if (controlledValue()) {
      onValueChange()(defaultValue);
    } else {
      value(defaultValue);
    }
  }
  const groupState = useToolbarGroup({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      if (controlledValue()) {
        onValueChange()(v);
      } else {
        value(v);
        onValueChange()(v);
      }
    }),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_2110();
      let attributes;
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_group = hmr(Toolbar_group, () => Toolbar_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_group[HMR].source;
    set(Toolbar_group[HMR].source, module.default[HMR].original);
  });
}
var toolbar_group_default = Toolbar_group;
mark_module_end(Toolbar_group);

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte
mark_module_start();
Toolbar_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte";
var root_2111 = add_locations(template(`<button><!></button>`), Toolbar_group_item[FILENAME], [[34, 1]]);
function Toolbar_group_item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Toolbar_group_item);
  validate_prop_bindings($$props, ["ref"], [], Toolbar_group_item);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "disabled",
      "type",
      "id",
      "ref"
    ],
    "restProps"
  );
  const groupItemState = useToolbarGroupItem({
    id: box.with(() => id()),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, groupItemState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => $$props.child,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        pressed: groupItemState.isPressed
      }));
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var button = root_2111();
      let attributes;
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => ({ pressed: groupItemState.isPressed }));
      reset(button);
      template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_group_item = hmr(Toolbar_group_item, () => Toolbar_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_group_item[HMR].source;
    set(Toolbar_group_item[HMR].source, module.default[HMR].original);
  });
}
var toolbar_group_item_default = Toolbar_group_item;
mark_module_end(Toolbar_group_item);

// node_modules/bits-ui/dist/bits/tooltip/exports.js
var exports_exports37 = {};
__export(exports_exports37, {
  Arrow: () => tooltip_arrow_default,
  Content: () => tooltip_content_default,
  ContentStatic: () => tooltip_content_static_default,
  Portal: () => portal_default,
  Provider: () => tooltip_provider_default,
  Root: () => tooltip_default,
  Trigger: () => tooltip_trigger_default
});

// node_modules/bits-ui/dist/bits/tooltip/utils.js
var TOOLTIP_OPEN_EVENT = "tooltip.open";

// node_modules/bits-ui/dist/internal/use-timeout-fn.svelte.js
function useTimeoutFn(cb, interval, options = {}) {
  const { immediate = true } = options;
  const isPending = box(false);
  let timer;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.current = false;
    clear();
  }
  function start(...args) {
    clear();
    isPending.current = true;
    timer = setTimeout(
      () => {
        isPending.current = false;
        timer = null;
        cb(...args);
      },
      interval
    );
  }
  if (immediate) {
    isPending.current = true;
    if (isBrowser) start();
  }
  onDestroyEffect(() => {
    stop();
  });
  return {
    isPending: box.readonly(isPending),
    start,
    stop
  };
}

// node_modules/bits-ui/dist/bits/tooltip/tooltip.svelte.js
var CONTENT_ATTR4 = "data-tooltip-content";
var TRIGGER_ATTR5 = "data-tooltip-trigger";
var _isOpenDelayed2, _timerFn, _startTimer, _clearTimer;
var TooltipProviderState = class {
  constructor(props) {
    __publicField(this, "delayDuration");
    __publicField(this, "disableHoverableContent");
    __publicField(this, "disableCloseOnTriggerClick");
    __publicField(this, "disabled");
    __publicField(this, "ignoreNonKeyboardFocus");
    __publicField(this, "skipDelayDuration");
    __privateAdd(this, _isOpenDelayed2, state(true));
    __publicField(this, "isPointerInTransit", box(false));
    __privateAdd(this, _timerFn);
    __privateAdd(this, _startTimer, () => {
      __privateGet(this, _timerFn).start();
    });
    __privateAdd(this, _clearTimer, () => {
      __privateGet(this, _timerFn).stop();
    });
    __publicField(this, "onOpen", () => {
      __privateGet(this, _clearTimer).call(this);
      this.isOpenDelayed = false;
    });
    __publicField(this, "onClose", () => {
      __privateGet(this, _startTimer).call(this);
    });
    this.delayDuration = props.delayDuration;
    this.disableHoverableContent = props.disableHoverableContent;
    this.disableCloseOnTriggerClick = props.disableCloseOnTriggerClick;
    this.disabled = props.disabled;
    this.ignoreNonKeyboardFocus = props.ignoreNonKeyboardFocus;
    this.skipDelayDuration = props.skipDelayDuration;
    __privateSet(this, _timerFn, useTimeoutFn(
      () => {
        this.isOpenDelayed = true;
      },
      this.skipDelayDuration.current,
      { immediate: false }
    ));
  }
  get isOpenDelayed() {
    return get(__privateGet(this, _isOpenDelayed2));
  }
  set isOpenDelayed(value) {
    set(__privateGet(this, _isOpenDelayed2), proxy(value, null, __privateGet(this, _isOpenDelayed2)));
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _isOpenDelayed2)), owner, false);
  }
};
_isOpenDelayed2 = new WeakMap();
_timerFn = new WeakMap();
_startTimer = new WeakMap();
_clearTimer = new WeakMap();
var _delayDuration, _disableHoverableContent, _disableCloseOnTriggerClick, _disabled19, _ignoreNonKeyboardFocus, _contentNode11, _triggerNode8, _wasOpenDelayed, _timerFn2, _stateAttr, _handleDelayedOpen;
var TooltipRootState = class {
  constructor(props, provider) {
    __publicField(this, "open");
    __publicField(this, "_delayDuration");
    __publicField(this, "_disableHoverableContent");
    __publicField(this, "_disableCloseOnTriggerClick");
    __publicField(this, "_disabled");
    __publicField(this, "_ignoreNonKeyboardFocus");
    __publicField(this, "provider");
    __privateAdd(this, _delayDuration, derived(() => this._delayDuration.current ?? this.provider.delayDuration.current));
    __privateAdd(this, _disableHoverableContent, derived(() => this._disableHoverableContent.current ?? this.provider.disableHoverableContent.current));
    __privateAdd(this, _disableCloseOnTriggerClick, derived(() => this._disableCloseOnTriggerClick.current ?? this.provider.disableCloseOnTriggerClick.current));
    __privateAdd(this, _disabled19, derived(() => this._disabled.current ?? this.provider.disabled.current));
    __privateAdd(this, _ignoreNonKeyboardFocus, derived(() => this._ignoreNonKeyboardFocus.current ?? this.provider.ignoreNonKeyboardFocus.current));
    __privateAdd(this, _contentNode11, state(null));
    __privateAdd(this, _triggerNode8, state(null));
    __privateAdd(this, _wasOpenDelayed, state(false));
    __privateAdd(this, _timerFn2);
    __privateAdd(this, _stateAttr, derived(() => {
      if (!this.open.current) return "closed";
      return get(__privateGet(this, _wasOpenDelayed)) ? "delayed-open" : "instant-open";
    }));
    __publicField(this, "handleOpen", () => {
      __privateGet(this, _timerFn2).stop();
      set(__privateGet(this, _wasOpenDelayed), false);
      this.open.current = true;
    });
    __publicField(this, "handleClose", () => {
      __privateGet(this, _timerFn2).stop();
      this.open.current = false;
    });
    __privateAdd(this, _handleDelayedOpen, () => {
      __privateGet(this, _timerFn2).start();
    });
    __publicField(this, "onTriggerEnter", () => {
      __privateGet(this, _handleDelayedOpen).call(this);
    });
    __publicField(this, "onTriggerLeave", () => {
      if (this.disableHoverableContent) {
        this.handleClose();
      } else {
        __privateGet(this, _timerFn2).stop();
      }
    });
    this.provider = provider;
    this.open = props.open;
    this._delayDuration = props.delayDuration;
    this._disableHoverableContent = props.disableHoverableContent;
    this._disableCloseOnTriggerClick = props.disableCloseOnTriggerClick;
    this._disabled = props.disabled;
    this._ignoreNonKeyboardFocus = props.ignoreNonKeyboardFocus;
    __privateSet(this, _timerFn2, useTimeoutFn(
      () => {
        set(__privateGet(this, _wasOpenDelayed), true);
        this.open.current = true;
      },
      this.delayDuration ?? 0,
      { immediate: false }
    ));
    user_effect(() => {
      if (strict_equals(this.delayDuration, void 0, false)) {
        untrack(() => {
          __privateSet(this, _timerFn2, useTimeoutFn(
            () => {
              set(__privateGet(this, _wasOpenDelayed), true);
              this.open.current = true;
            },
            this.delayDuration,
            { immediate: false }
          ));
        });
      }
    });
    user_effect(() => {
      this.open.current;
      untrack(() => {
        if (!this.provider.onClose) return;
        const isOpen = this.open.current;
        if (isOpen) {
          this.provider.onOpen();
          document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN_EVENT));
        } else {
          this.provider.onClose();
        }
      });
    });
  }
  get delayDuration() {
    return get(__privateGet(this, _delayDuration));
  }
  set delayDuration(_) {
    throw new Error("Cannot update a derived property ('delayDuration')");
  }
  get disableHoverableContent() {
    return get(__privateGet(this, _disableHoverableContent));
  }
  set disableHoverableContent(_) {
    throw new Error("Cannot update a derived property ('disableHoverableContent')");
  }
  get disableCloseOnTriggerClick() {
    return get(__privateGet(this, _disableCloseOnTriggerClick));
  }
  set disableCloseOnTriggerClick(_) {
    throw new Error("Cannot update a derived property ('disableCloseOnTriggerClick')");
  }
  get disabled() {
    return get(__privateGet(this, _disabled19));
  }
  set disabled(_) {
    throw new Error("Cannot update a derived property ('disabled')");
  }
  get ignoreNonKeyboardFocus() {
    return get(__privateGet(this, _ignoreNonKeyboardFocus));
  }
  set ignoreNonKeyboardFocus(_) {
    throw new Error("Cannot update a derived property ('ignoreNonKeyboardFocus')");
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode11));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode11), proxy(value, null, __privateGet(this, _contentNode11)));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode8));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode8), proxy(value, null, __privateGet(this, _triggerNode8)));
  }
  get stateAttr() {
    return get(__privateGet(this, _stateAttr));
  }
  set stateAttr(_) {
    throw new Error("Cannot update a derived property ('stateAttr')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _delayDuration)), owner, false);
    add_owner(get(__privateGet(this, _disableHoverableContent)), owner, false);
    add_owner(get(__privateGet(this, _disableCloseOnTriggerClick)), owner, false);
    add_owner(get(__privateGet(this, _disabled19)), owner, false);
    add_owner(get(__privateGet(this, _ignoreNonKeyboardFocus)), owner, false);
    add_owner(get(__privateGet(this, _contentNode11)), owner, false);
    add_owner(get(__privateGet(this, _triggerNode8)), owner, false);
    add_owner(get(__privateGet(this, _stateAttr)), owner, false);
  }
};
_delayDuration = new WeakMap();
_disableHoverableContent = new WeakMap();
_disableCloseOnTriggerClick = new WeakMap();
_disabled19 = new WeakMap();
_ignoreNonKeyboardFocus = new WeakMap();
_contentNode11 = new WeakMap();
_triggerNode8 = new WeakMap();
_wasOpenDelayed = new WeakMap();
_timerFn2 = new WeakMap();
_stateAttr = new WeakMap();
_handleDelayedOpen = new WeakMap();
var _id97, _ref96, _root50, _isPointerDown2, _hasPointerMoveOpened, _disabled20, _isDisabled15, _onpointerup14, _onpointerdown20, _onpointermove11, _onpointerleave8, _onfocus9, _onblur6, _onclick23, _props147;
var TooltipTriggerState = class {
  constructor(props, root17) {
    __privateAdd(this, _id97);
    __privateAdd(this, _ref96);
    __privateAdd(this, _root50);
    __privateAdd(this, _isPointerDown2, box(false));
    __privateAdd(this, _hasPointerMoveOpened, state(false));
    __privateAdd(this, _disabled20);
    __privateAdd(this, _isDisabled15, derived(() => __privateGet(this, _disabled20).current || __privateGet(this, _root50).disabled));
    __publicField(this, "handlePointerUp", () => {
      __privateGet(this, _isPointerDown2).current = false;
    });
    __privateAdd(this, _onpointerup14, () => {
      if (get(__privateGet(this, _isDisabled15))) return;
      __privateGet(this, _isPointerDown2).current = false;
    });
    __privateAdd(this, _onpointerdown20, () => {
      if (get(__privateGet(this, _isDisabled15))) return;
      __privateGet(this, _isPointerDown2).current = true;
      document.addEventListener(
        "pointerup",
        () => {
          this.handlePointerUp();
        },
        { once: true }
      );
    });
    __privateAdd(this, _onpointermove11, (e) => {
      if (get(__privateGet(this, _isDisabled15))) return;
      if (strict_equals(e.pointerType, "touch")) return;
      if (get(__privateGet(this, _hasPointerMoveOpened)) || __privateGet(this, _root50).provider.isPointerInTransit.current) return;
      __privateGet(this, _root50).onTriggerEnter();
      set(__privateGet(this, _hasPointerMoveOpened), true);
    });
    __privateAdd(this, _onpointerleave8, () => {
      if (get(__privateGet(this, _isDisabled15))) return;
      __privateGet(this, _root50).onTriggerLeave();
      set(__privateGet(this, _hasPointerMoveOpened), false);
    });
    __privateAdd(this, _onfocus9, (e) => {
      if (__privateGet(this, _isPointerDown2).current || get(__privateGet(this, _isDisabled15))) return;
      if (__privateGet(this, _root50).ignoreNonKeyboardFocus && !isFocusVisible(e.currentTarget)) return;
      __privateGet(this, _root50).handleOpen();
    });
    __privateAdd(this, _onblur6, () => {
      if (get(__privateGet(this, _isDisabled15))) return;
      __privateGet(this, _root50).handleClose();
    });
    __privateAdd(this, _onclick23, () => {
      if (__privateGet(this, _root50).disableCloseOnTriggerClick || get(__privateGet(this, _isDisabled15))) return;
      __privateGet(this, _root50).handleClose();
    });
    __privateAdd(this, _props147, derived(() => {
      var _a;
      return {
        id: __privateGet(this, _id97).current,
        "aria-describedby": __privateGet(this, _root50).open.current ? (_a = __privateGet(this, _root50).contentNode) == null ? void 0 : _a.id : void 0,
        "data-state": __privateGet(this, _root50).stateAttr,
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled15))),
        "data-delay-duration": `${__privateGet(this, _root50).delayDuration}`,
        [TRIGGER_ATTR5]: "",
        tabindex: get(__privateGet(this, _isDisabled15)) ? void 0 : 0,
        disabled: __privateGet(this, _disabled20).current,
        onpointerup: __privateGet(this, _onpointerup14),
        onpointerdown: __privateGet(this, _onpointerdown20),
        onpointermove: __privateGet(this, _onpointermove11),
        onpointerleave: __privateGet(this, _onpointerleave8),
        onfocus: __privateGet(this, _onfocus9),
        onblur: __privateGet(this, _onblur6),
        onclick: __privateGet(this, _onclick23)
      };
    }));
    __privateSet(this, _id97, props.id);
    __privateSet(this, _ref96, props.ref);
    __privateSet(this, _disabled20, props.disabled);
    __privateSet(this, _root50, root17);
    useRefById({
      id: __privateGet(this, _id97),
      ref: __privateGet(this, _ref96),
      onRefChange: (node) => {
        __privateGet(this, _root50).triggerNode = node;
      }
    });
  }
  get props() {
    return get(__privateGet(this, _props147));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _props147)), owner, false);
  }
};
_id97 = new WeakMap();
_ref96 = new WeakMap();
_root50 = new WeakMap();
_isPointerDown2 = new WeakMap();
_hasPointerMoveOpened = new WeakMap();
_disabled20 = new WeakMap();
_isDisabled15 = new WeakMap();
_onpointerup14 = new WeakMap();
_onpointerdown20 = new WeakMap();
_onpointermove11 = new WeakMap();
_onpointerleave8 = new WeakMap();
_onfocus9 = new WeakMap();
_onblur6 = new WeakMap();
_onclick23 = new WeakMap();
_props147 = new WeakMap();
var _id98, _ref97, _snippetProps21, _props148;
var TooltipContentState = class {
  constructor(props, root17) {
    __publicField(this, "root");
    __privateAdd(this, _id98);
    __privateAdd(this, _ref97);
    __privateAdd(this, _snippetProps21, derived(() => ({ open: this.root.open.current })));
    __privateAdd(this, _props148, derived(() => ({
      id: __privateGet(this, _id98).current,
      "data-state": this.root.stateAttr,
      "data-disabled": getDataDisabled(this.root.disabled),
      style: { pointerEvents: "auto", outline: "none" },
      [CONTENT_ATTR4]: ""
    })));
    this.root = root17;
    __privateSet(this, _id98, props.id);
    __privateSet(this, _ref97, props.ref);
    useRefById({
      id: __privateGet(this, _id98),
      ref: __privateGet(this, _ref97),
      onRefChange: (node) => {
        this.root.contentNode = node;
      },
      deps: () => this.root.open.current
    });
    user_effect(() => {
      if (!this.root.open.current) return;
      if (this.root.disableHoverableContent) return;
      const { isPointerInTransit, onPointerExit } = useGraceArea(() => this.root.triggerNode, () => this.root.contentNode);
      this.root.provider.isPointerInTransit = isPointerInTransit;
      onPointerExit(() => {
        this.root.handleClose();
      });
    });
    user_effect(() => {
      useEventListener(window, "scroll", (e) => {
        const target = e.target;
        if (!isElement(target)) return;
        if (target.contains(this.root.triggerNode)) {
          this.root.handleClose();
        }
      });
      useEventListener(window, TOOLTIP_OPEN_EVENT, this.root.handleClose);
    });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps21));
  }
  set snippetProps(_) {
    throw new Error("Cannot update a derived property ('snippetProps')");
  }
  get props() {
    return get(__privateGet(this, _props148));
  }
  set props(_) {
    throw new Error("Cannot update a derived property ('props')");
  }
  [ADD_OWNER](owner) {
    add_owner(get(__privateGet(this, _snippetProps21)), owner, false);
    add_owner(get(__privateGet(this, _props148)), owner, false);
  }
};
_id98 = new WeakMap();
_ref97 = new WeakMap();
_snippetProps21 = new WeakMap();
_props148 = new WeakMap();
var [
  setTooltipProviderContext,
  getTooltipProviderContext
] = createContext("Tooltip.Provider");
var [setTooltipRootContext, getTooltipRootContext] = createContext("Tooltip.Root");
function useTooltipProvider(props) {
  return setTooltipProviderContext(new TooltipProviderState(props));
}
function useTooltipRoot(props) {
  return setTooltipRootContext(new TooltipRootState(props, getTooltipProviderContext()));
}
function useTooltipTrigger(props) {
  return new TooltipTriggerState(props, getTooltipRootContext());
}
function useTooltipContent(props) {
  return new TooltipContentState(props, getTooltipRootContext());
}

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte
mark_module_start();
Tooltip[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte";
function Tooltip($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip);
  validate_prop_bindings($$props, ["open"], [], Tooltip);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop2), controlledOpen = prop($$props, "controlledOpen", 3, false);
  useTooltipRoot({
    open: box.with(() => open(), (v) => {
      if (controlledOpen()) {
        onOpenChange()(v);
      } else {
        open(v);
        onOpenChange()(v);
      }
    }),
    delayDuration: box.with(() => $$props.delayDuration),
    disableCloseOnTriggerClick: box.with(() => $$props.disableCloseOnTriggerClick),
    disableHoverableContent: box.with(() => $$props.disableHoverableContent),
    ignoreNonKeyboardFocus: box.with(() => $$props.ignoreNonKeyboardFocus),
    disabled: box.with(() => $$props.disabled)
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Tooltip, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip = hmr(Tooltip, () => Tooltip[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip[HMR].source;
    set(Tooltip[HMR].source, module.default[HMR].original);
  });
}
var tooltip_default = Tooltip;
mark_module_end(Tooltip);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte
mark_module_start();
Tooltip_content[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte";
var root_420 = add_locations(template(`<div><!></div>`), Tooltip_content[FILENAME], [[84, 4]]);
var root_915 = add_locations(template(`<div><!></div>`), Tooltip_content[FILENAME], [[111, 4]]);
function Tooltip_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_content);
  validate_prop_bindings($$props, ["ref"], [], Tooltip_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = useTooltipContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const floatingProps = derived(() => ({
    side: side(),
    sideOffset: sideOffset(),
    align: align(),
    avoidCollisions: avoidCollisions(),
    arrowPadding: arrowPadding(),
    sticky: sticky(),
    hideWhenDetached: hideWhenDetached(),
    collisionPadding: collisionPadding()
  }));
  const mergedProps = derived(() => mergeProps(restProps, get(floatingProps), contentState.props));
  function handleInteractOutside(e) {
    var _a;
    (_a = $$props.onInteractOutside) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  function handleEscapeKeydown(e) {
    var _a;
    (_a = $$props.onEscapeKeydown) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Tooltip_content, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("tooltip")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_420();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps2) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get enabled() {
            return contentState.root.open.current;
          },
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onOpenAutoFocus: (e) => e.preventDefault(),
          onCloseAutoFocus: (e) => e.preventDefault(),
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Tooltip_content, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = comment();
              const mergedProps2 = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("tooltip")
              }));
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_915();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(mergedProps2) }));
                  append($$anchor5, div_1);
                }
              );
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              get present() {
                return contentState.root.open.current;
              },
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onOpenAutoFocus: (e) => e.preventDefault(),
              onCloseAutoFocus: (e) => e.preventDefault(),
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_content = hmr(Tooltip_content, () => Tooltip_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_content[HMR].source;
    set(Tooltip_content[HMR].source, module.default[HMR].original);
  });
}
var tooltip_content_default = Tooltip_content;
mark_module_end(Tooltip_content);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content-static.svelte
mark_module_start();
Tooltip_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content-static.svelte";
var root_421 = add_locations(template(`<div><!></div>`), Tooltip_content_static[FILENAME], [[85, 4]]);
var root_916 = add_locations(template(`<div><!></div>`), Tooltip_content_static[FILENAME], [[113, 4]]);
function Tooltip_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_content_static);
  validate_prop_bindings($$props, ["ref"], [], Tooltip_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = useTooltipContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const floatingProps = derived(() => ({
    side: side(),
    sideOffset: sideOffset(),
    align: align(),
    avoidCollisions: avoidCollisions(),
    arrowPadding: arrowPadding(),
    sticky: sticky(),
    hideWhenDetached: hideWhenDetached(),
    collisionPadding: collisionPadding()
  }));
  const mergedProps = derived(() => mergeProps(restProps, get(floatingProps), contentState.props));
  function handleInteractOutside(e) {
    var _a;
    (_a = $$props.onInteractOutside) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  function handleEscapeKeydown(e) {
    var _a;
    (_a = $$props.onEscapeKeydown) == null ? void 0 : _a.call($$props, e);
    if (e.defaultPrevented) return;
    contentState.root.handleClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    forceMount,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Tooltip_content_static, ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("tooltip")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => $$props.child,
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              append($$anchor4, fragment_3);
            },
            ($$anchor4) => {
              var div = root_421();
              let attributes;
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              template_effect(() => attributes = set_attributes(div, attributes, { ...get(mergedProps2) }));
              append($$anchor4, div);
            }
          );
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          isStatic: true,
          get enabled() {
            return contentState.root.open.current;
          },
          get id() {
            return id();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onOpenAutoFocus: (e) => e.preventDefault(),
          onCloseAutoFocus: (e) => e.preventDefault(),
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      if_block(
        node_5,
        () => !forceMount(),
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Tooltip_content_static, ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_6 = comment();
              const mergedProps2 = derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("tooltip")
              }));
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              if_block(
                node_7,
                () => $$props.child,
                ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  snippet(node_8, () => $$props.child, () => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  append($$anchor5, fragment_7);
                },
                ($$anchor5) => {
                  var div_1 = root_916();
                  let attributes_1;
                  var node_9 = child(div_1);
                  snippet(node_9, () => $$props.children ?? noop);
                  reset(div_1);
                  template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...get(mergedProps2) }));
                  append($$anchor5, div_1);
                }
              );
              append($$anchor4, fragment_6);
            });
            popper_layer_default(node_6, spread_props(() => get(mergedProps), {
              isStatic: true,
              get present() {
                return contentState.root.open.current;
              },
              get id() {
                return id();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onOpenAutoFocus: (e) => e.preventDefault(),
              onCloseAutoFocus: (e) => e.preventDefault(),
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_5);
        },
        null,
        true
      );
      append($$anchor2, fragment_4);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_content_static = hmr(Tooltip_content_static, () => Tooltip_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_content_static[HMR].source;
    set(Tooltip_content_static[HMR].source, module.default[HMR].original);
  });
}
var tooltip_content_static_default = Tooltip_content_static;
mark_module_end(Tooltip_content_static);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte
mark_module_start();
Tooltip_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte";
var root_320 = add_locations(template(`<button><!></button>`), Tooltip_trigger[FILENAME], [[34, 2]]);
function Tooltip_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_trigger);
  validate_prop_bindings($$props, ["ref"], [], Tooltip_trigger);
  let id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "disabled",
      "type",
      "ref"
    ],
    "restProps"
  );
  const triggerState = useTooltipTrigger({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    children: wrap_snippet(Tooltip_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => $$props.child,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var button = root_320();
          let attributes;
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          template_effect(() => attributes = set_attributes(button, attributes, { ...get(mergedProps) }));
          append($$anchor3, button);
        }
      );
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_trigger = hmr(Tooltip_trigger, () => Tooltip_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_trigger[HMR].source;
    set(Tooltip_trigger[HMR].source, module.default[HMR].original);
  });
}
var tooltip_trigger_default = Tooltip_trigger;
mark_module_end(Tooltip_trigger);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte
mark_module_start();
Tooltip_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte";
function Tooltip_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_arrow);
  validate_prop_bindings($$props, ["ref"], [], Tooltip_arrow);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    add_owner_effect(ref, floating_layer_arrow_default);
    floating_layer_arrow_default(node, spread_props(
      {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      },
      () => restProps
    ));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_arrow = hmr(Tooltip_arrow, () => Tooltip_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_arrow[HMR].source;
    set(Tooltip_arrow[HMR].source, module.default[HMR].original);
  });
}
var tooltip_arrow_default = Tooltip_arrow;
mark_module_end(Tooltip_arrow);

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-provider.svelte
mark_module_start();
Tooltip_provider[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-provider.svelte";
function Tooltip_provider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_provider);
  validate_prop_bindings($$props, [], [], Tooltip_provider);
  let delayDuration = prop($$props, "delayDuration", 3, 700), disableCloseOnTriggerClick = prop($$props, "disableCloseOnTriggerClick", 3, false), disableHoverableContent = prop($$props, "disableHoverableContent", 3, false), disabled = prop($$props, "disabled", 3, false), ignoreNonKeyboardFocus = prop($$props, "ignoreNonKeyboardFocus", 3, false), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300);
  useTooltipProvider({
    delayDuration: box.with(() => delayDuration()),
    disableCloseOnTriggerClick: box.with(() => disableCloseOnTriggerClick()),
    disableHoverableContent: box.with(() => disableHoverableContent()),
    disabled: box.with(() => disabled()),
    ignoreNonKeyboardFocus: box.with(() => ignoreNonKeyboardFocus()),
    skipDelayDuration: box.with(() => skipDelayDuration())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_provider = hmr(Tooltip_provider, () => Tooltip_provider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_provider[HMR].source;
    set(Tooltip_provider[HMR].source, module.default[HMR].original);
  });
}
var tooltip_provider_default = Tooltip_provider;
mark_module_end(Tooltip_provider);
export {
  exports_exports as Accordion,
  exports_exports2 as AlertDialog,
  exports_exports3 as AspectRatio,
  exports_exports4 as Avatar,
  exports_exports5 as Button,
  exports_exports6 as Calendar,
  exports_exports7 as Checkbox,
  exports_exports8 as Collapsible,
  exports_exports9 as Combobox,
  exports_exports10 as Command,
  exports_exports11 as ContextMenu,
  exports_exports12 as DateField,
  exports_exports13 as DatePicker,
  exports_exports14 as DateRangeField,
  exports_exports15 as DateRangePicker,
  exports_exports16 as Dialog,
  exports_exports17 as DropdownMenu,
  exports_exports18 as Label,
  exports_exports19 as LinkPreview,
  exports_exports20 as Menubar,
  exports_exports21 as NavigationMenu,
  exports_exports22 as Pagination,
  exports_exports23 as PinInput,
  exports_exports24 as Popover,
  portal_default as Portal,
  exports_exports25 as Progress,
  REGEXP_ONLY_CHARS,
  REGEXP_ONLY_DIGITS,
  REGEXP_ONLY_DIGITS_AND_CHARS,
  exports_exports26 as RadioGroup,
  exports_exports27 as RangeCalendar,
  exports_exports28 as ScrollArea,
  exports_exports29 as Select,
  exports_exports30 as Separator,
  exports_exports31 as Slider,
  exports_exports32 as Switch,
  exports_exports33 as Tabs,
  exports_exports34 as Toggle,
  exports_exports35 as ToggleGroup,
  exports_exports36 as Toolbar,
  exports_exports37 as Tooltip,
  mergeProps,
  useId
};
//# sourceMappingURL=bits-ui.js.map
